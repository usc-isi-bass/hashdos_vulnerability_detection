import os
import json
import itertools
import networkx as nx
from networkx.readwrite import json_graph

class HashFuncDiscoverer:

    def __init__(self, proj, cfg):
        self._proj = proj
        self._cfg = cfg

        self._hash_func_models = self.generate_models()
        #self.model_checks(self._hash_func_models)
        self._subgraph_isos_cache = FuncHashFuncModelGraphIsomorphismCache()
        self._func_model_features = {} # Store the features we observed for a function with respect to a model

    def discover_hash_funcs(self):
        discovered_hash_funcs = {}
        for func_addr, func in self._cfg.functions.items():
            self._func_model_features[func_addr] = {}
            for hash_func_model in self._hash_func_models:
                hash_alg_name = hash_func_model.hash_alg_name
                if self.check_model(func, hash_func_model):
                    if hash_alg_name not in discovered_hash_funcs:
                        discovered_hash_funcs[hash_alg_name] = []
                    discovered_hash_func_model_features = self._func_model_features[func.addr][hash_func_model.model_id]
                    discovered_hash_funcs[hash_alg_name].append((func, func.addr, 100, discovered_hash_func_model_features))
        return discovered_hash_funcs

    def check_model(self, func, hash_func_model):
        assert hash_func_model.model_id not in self._func_model_features[func.addr], "Did we already check this model? Or are there duplicate model IDs?"
        self._func_model_features[func.addr][hash_func_model.model_id] = {}
        subcallgraph_eccentricity = self.get_subcallgraph_eccentricity(func)
        self._func_model_features[func.addr][hash_func_model.model_id]['subcallgraph_eccentricity'] = subcallgraph_eccentricity
        imm_mnem_sets = hash_func_model.imm_mnem_sets
        imm_mnem_set_to_insns = {}
        for imm_mnem_set in imm_mnem_sets:
            imm_to_insns = self.contains_all_imm_mnem_sets(func, imm_mnem_set)
            # We only care about the immediates for which we could find all the other immedates in the set as well
            if imm_to_insns is None:
                continue
            imm_mnem_set_to_insns[imm_mnem_set] = imm_to_insns
        # We could not find any complete set constants
        if len(imm_mnem_set_to_insns) == 0:
            return False
        #print("{}@0x{:x}".format(func.name, func.addr))
        #print("  {}".format(hash_func_model.hash_alg_name))
        #print("  {}".format(imm_mnem_set_to_insns))


        # The subgraphs of the function that are isomorphic to a graph in the hash function model
        isomorphic_subgraphs = []
        hash_func_graphs = hash_func_model.graphs
        #print("edges: {}".format(func.graph.edges()))
        for hash_func_graph in hash_func_graphs:
            is_isomorphic = self._subgraph_isos_cache.check_isomorphic(func, hash_func_graph)
            #print("model nodes: {} is_isomorphic: {}".format(len(hash_func_graph.nodes()), is_isomorphic))
            if is_isomorphic:
                #for nodes_map in digraph_matcher.subgraph_isomorphisms_iter():
                for nodes_map in self._subgraph_isos_cache.get_subgraph_isos(func, hash_func_graph):
                    isomorphic_subgraph = func.graph.subgraph(nodes_map.keys())
                    isomorphic_subgraphs.append(isomorphic_subgraph)

        # We could not find a subgraph that is isomorphic to one of the hash function graphs
        if len(isomorphic_subgraphs) == 0:
            return False

        any_imm_set_in_subgraph = False
        largest_isomorphic_subgraph = None
        # Go through every set of immediates and make sure that for at least one set, all immedates occur in a (any single) isomorphic subgraph.
        for imm_to_insns in imm_mnem_set_to_insns.values():
            # The imms in imm_to_insns should be all the immedates of a set
            # Is this imm set in any subgraph?
            imm_set_in_any_subgraph = False
            # Go through every isomorphic subgraph and check if this immediate appears in any of them
            for graph in isomorphic_subgraphs:
                graph_addrs = set([node.addr for node in graph.nodes()])
                imm_set_in_this_subgraph = True
                # Go through the instructions (where immediate is used) of every immediate in this set
                # The instructions where the immediate is used
                for insns in imm_to_insns.values():
                    insn_block_addrs = set([self._cfg.model.get_any_node(insn.address, anyaddr=True).addr for insn in insns])
                    # If there is an immediate for which none of the instructions appear in this subgraph, this immediate set is not in this subgraph
                    if not any(insn_block_addr in graph_addrs for insn_block_addr in insn_block_addrs):
                        imm_set_in_this_subgraph = False
                        #break

                if imm_set_in_this_subgraph:
                    imm_set_in_any_subgraph = True
                    if largest_isomorphic_subgraph is None or len(graph.nodes()) > len(largest_isomorphic_subgraph.nodes()):
                        largest_isomorphic_subgraph = graph
                    #break
            if imm_set_in_any_subgraph:
                any_imm_set_in_subgraph = True
                #break

        if not any_imm_set_in_subgraph:
            return False
        assert largest_isomorphic_subgraph is not None, "The immediate set is in a subgraph, but the saved largest isomorphic subgraph is None"
        self._func_model_features[func.addr][hash_func_model.model_id]['largest_isomorphic_subgraph_node_addrs'] = set(node.addr for node in largest_isomorphic_subgraph.nodes())

        return True


    def get_subcallgraph_eccentricity(self, func):
        callgraph = self._proj.kb.callgraph
        func_call_descendants = list(nx.descendants(callgraph, func.addr))
        #print(func_call_descendants)
        subcallgraph = callgraph.subgraph([func.addr] + func_call_descendants)
        #print(type(subcallgraph))
        #print(subcallgraph.nodes())
        #print(func.addr)
        return nx.eccentricity(subcallgraph, func.addr)



    def contains_all_imm_mnem_sets(self, func, imm_mnem_sets):
        # imm_mnem_sets is a tuple (imm, (mnem1, mnem2, ...)) where imm is the immediate (constant) to search for and the mnems are the mnemonics that it may be used with
        imm_to_insns = {}
        for imm, mnems in imm_mnem_sets:
            imm_mnems = (imm, mnems)
            found_insns = self.find_imm_mnem_set(func, imm_mnems)

            if len(found_insns) == 0:
                return None
            assert imm not in imm_to_insns, "immediates must be unique! You should union their mnemonics."
            imm_to_insns[imm] = found_insns
        return imm_to_insns




    def find_imm_mnem_set(self, func, imm_mnems):
        imm, mnems = imm_mnems
        found_insns = []
        for block in func.blocks:
            insns = block.capstone.insns
            for insn in insns:
                if insn.mnemonic[0] == 'j':
                    # Probably a jump instruction
                    continue
                for op in insn.operands:
                    if op.type == 2: # Capstone uses 2 for immediate operand types
                        if op.imm == imm:
                            if any((mnem in insn.mnemonic) or (insn.mnemonic in mnem) for mnem in mnems):
                                found_insns.append(insn)
        return found_insns

    def generate_models(self):
        models_file_name = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'hash_func_models.json')
        hash_func_models = []
        with open(models_file_name) as fd:
            hash_func_models_dict = json.loads(fd.read())
            graph_name_to_graph = {}
            for graph_name, graph_json in hash_func_models_dict['graphs'].items():
                graph_name_to_graph[graph_name] = json_graph.node_link_graph(graph_json)
            for hash_alg_name in hash_func_models_dict['hash_models']:
                hash_alg_models = hash_func_models_dict['hash_models'][hash_alg_name]['models']
                
                for i, hash_alg_model in enumerate(hash_alg_models):
                    # Converting the immediates to ints
                    imm_mnems_sets = []
                    for imm_mnems_set_str in hash_alg_model['constants']:
                        imm_mnems_set = []
                        for imm, mnems in imm_mnems_set_str.items():
                            imm_mnems_set.append((int(imm), tuple(mnems)))
                        imm_mnems_sets.append(tuple(imm_mnems_set))

                    #constant_mnem_sets = [constant_mnems_set.items() for constant_mnems_set in hash_alg_model['constants']]
                    #print(imm_mnems_sets)
                    model_id = hash_alg_name
                    if len(hash_alg_models) > 1:
                        model_id += "_{}".format(i)

                    graphs = []
                    graph_names = hash_alg_model['graph_names']
                    for graph_name in graph_names:
                        graph = graph_name_to_graph[graph_name]
                        graphs.append(graph)

                    hfm = HashFuncModel(model_id, hash_alg_name, imm_mnems_sets, graphs)
                    hash_func_models.append(hfm)
        return hash_func_models

    def model_checks(self, hash_func_models):
        all_graphs = [graph for hash_func_model in hash_func_models for graph in hash_func_model.graphs]
        print("Total num graphs: {}".format(len(all_graphs)))
        for g1, g2 in itertools.combinations(all_graphs, 2):
            # For our model graphs, we want isomorphic graphs to be equal
            g1_g2_isomorphic = nx.is_isomorphic(g1, g2)
            g1_g2_equal = self.graphs_equal(g1, g2)
            assert g1_g2_isomorphic == g1_g2_equal, "We want hash func model graphs to be equal, if they are isomorphic"


    def graphs_equal(self, g1, g2):
        return set(g1.nodes()) == set(g2.nodes()) and set(g1.edges()) == set(g2.edges())


class HashFuncModel:
    # imm_mnem_sets is an iterable of tuples [[(imm1, (mnem11, mnem12, ...), (imm2, (mnem21, mnem22)))], [(imm3, (mnem31, ...))]]
    # All imms sets in the same inner list MUST appear in the same hash function (with one of their allowed mnems)
    # All these sets show the allowed sets that we will check if one of appears in the function
    def __init__(self, model_id, hash_alg_name, imm_mnem_sets, graphs):
        self.model_id = model_id
        self.hash_alg_name = hash_alg_name
        self.imm_mnem_sets = imm_mnem_sets
        self.graphs = graphs
        pass


class FuncHashFuncModelGraphIsomorphismCache():

    def __init__(self):
        self._cache = {}
        self._subgraph_isos_cache = {}


    def check_isomorphic(self, func, hash_func_model_graph):
        if self._check_cache(func, hash_func_model_graph):
            #print("Used cached result!")
            return self._get_cache(func, hash_func_model_graph)

        digraph_matcher = nx.algorithms.isomorphism.DiGraphMatcher(func.graph, hash_func_model_graph)
        is_isomorphic = digraph_matcher.subgraph_is_isomorphic()
        self._add_cache(func, hash_func_model_graph, is_isomorphic)
        if is_isomorphic:
            nodes_map = list(digraph_matcher.subgraph_isomorphisms_iter())
            self._add_subgraph_isos_cache(func, hash_func_model_graph, nodes_map)

        return is_isomorphic




    def _check_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        if func_addr_graph in self._cache:
            return True
        return False

    def _get_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._cache, "{} not in cache, did you check with _check_cache first?".format(func_addr_graph)
        return self._cache[func_addr_graph]

    def _add_cache(self, func, hash_func_model_graph, is_isomorphic):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._cache, "{} already in cache, did you check with _check_cache first?".format(func_addr_graph)
        self._cache[func_addr_graph] = is_isomorphic
        assert self._check_cache(func, hash_func_model_graph), "Add cache failed"

    def get_subgraph_isos(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._subgraph_isos_cache, "{} not in subgraph isomorphisms cache, did you check with check_isomorphic first?".format(func_addr_graph)
        return self._subgraph_isos_cache[func_addr_graph]

    def _add_subgraph_isos_cache(self, func, hash_func_model_graph, subgraph_isos):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._subgraph_isos_cache, "{} already in subgraph isomorphisms cache, did you check with _check_cache first?".format(func_addr_graph)
        self._subgraph_isos_cache[func_addr_graph] = subgraph_isos



    def _graph_to_tuples(self, graph):
        return (tuple(graph.nodes()), tuple(graph.edges()))

