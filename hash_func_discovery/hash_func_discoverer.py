import angr
import claripy
import os
import json
import itertools
import bitstring
import networkx as nx
from networkx.readwrite import json_graph

class HashFuncDiscoverer:

    def __init__(self, proj, cfg):
        self._proj = proj
        self._cfg = cfg

        self._hash_func_models = self.generate_models()
        self.model_checks(self._hash_func_models)
        self._subgraph_isos_cache = FuncHashFuncModelGraphIsomorphismCache()
        self._func_model_features = {} # Store the features we observed for a function with respect to a model

    def discover_hash_funcs(self):
        discovered_hash_funcs = {}
        #print(self._proj.loader.main_object)
        for func_addr, func in self._cfg.functions.items():
            self._func_model_features[func_addr] = {}
            for hash_func_model in self._hash_func_models:
                hash_alg_name = hash_func_model.hash_alg_name
                if self.check_model(func, hash_func_model):
                    if hash_alg_name not in discovered_hash_funcs:
                        discovered_hash_funcs[hash_alg_name] = []
                        discovered_hash_func_model_features = self._func_model_features[func.addr][hash_func_model.model_id]
                    discovered_hash_funcs[hash_alg_name].append((func, func.addr, 100, discovered_hash_func_model_features))
        return discovered_hash_funcs

    def check_model(self, func, hash_func_model):
        assert hash_func_model.model_id not in self._func_model_features[func.addr], "Did we already check this model? Or are there duplicate model IDs?"
        self._func_model_features[func.addr][hash_func_model.model_id] = {}
        subcallgraph_eccentricity = self.get_subcallgraph_eccentricity(func)
        self._func_model_features[func.addr][hash_func_model.model_id]['subcallgraph_eccentricity'] = subcallgraph_eccentricity
        imm_mnem_sets = hash_func_model.imm_mnem_sets
        imm_mnem_set_to_insns = {}
        for imm_mnem_set in imm_mnem_sets:
            imm_to_insns = self.contains_all_imm_mnem_sets(func, imm_mnem_set)
            # We only care about the immediates for which we could find all the other immedates in the set as well
            if imm_to_insns is None:
                continue
            imm_mnem_set_to_insns[imm_mnem_set] = imm_to_insns
        # We could not find any complete set constants
        if len(imm_mnem_set_to_insns) == 0:
            return False
        #print("{}@0x{:x}".format(func.name, func.addr))
        #print("  {}".format(hash_func_model.hash_alg_name))
        #print("  {}".format(imm_mnem_set_to_insns))


        # The subgraphs of the function that are isomorphic to a scc in the hash function model
        isomorphic_subgraphs = []
        hash_func_sccs = hash_func_model.sccs
        #print("edges: {}".format(func.graph.edges()))
        for hash_func_scc in hash_func_sccs:
            is_isomorphic = self._subgraph_isos_cache.check_isomorphic(func, hash_func_scc)
            #print("model nodes: {} is_isomorphic: {}".format(len(hash_func_graph.nodes()), is_isomorphic))
            if is_isomorphic:
                #for nodes_map in digraph_matcher.subgraph_isomorphisms_iter():
                for nodes_map in self._subgraph_isos_cache.get_subgraph_isos(func, hash_func_scc):
                    isomorphic_subgraph = func.graph.subgraph(nodes_map.keys())
                    isomorphic_subgraphs.append(isomorphic_subgraph)

        # We could not find a subgraph that is isomorphic to one of the hash function graphs
        if len(isomorphic_subgraphs) == 0:
            return False

        # We have to disable this check for sccs since the constants may legitimately not be used in one
        '''
        any_imm_set_in_subgraph = False
        imm_sets_in_subgraph = []
        # Go through every set of immediates and make sure that for at least one set, all immedates occur in a (any single) isomorphic subgraph.
        for imm_to_insns in imm_mnem_set_to_insns.values():
            # The imms in imm_to_insns should be all the immedates of a set
            # Is this imm set in any subgraph?
            imm_set_in_any_subgraph = False
            # Go through every isomorphic subgraph and check if this immediate appears in any of them
            for graph in isomorphic_subgraphs:
                graph_addrs = set([node.addr for node in graph.nodes()])
                imm_set_in_this_subgraph = True
                # Go through the instructions (where immediate is used) of every immediate in this set
                # The instructions where the immediate is used
                for insns in imm_to_insns.values():
                    insn_block_addrs = set([self._cfg.model.get_any_node(insn.address, anyaddr=True).addr for insn in insns])
                    # If there is an immediate for which none of the instructions appear in this subgraph, this immediate set is not in this subgraph
                    if not any(insn_block_addr in graph_addrs for insn_block_addr in insn_block_addrs):
                        imm_set_in_this_subgraph = False
                        break

                if imm_set_in_this_subgraph:
                    imm_set_in_any_subgraph = True
                    break
            if imm_set_in_any_subgraph:
                any_imm_set_in_subgraph = True
                imm_sets_in_subgraph.append(imm_to_insns)
                #break

        if not any_imm_set_in_subgraph:
            return False
        '''
        #initial_state = self._proj.factory.call_state(addr=func.addr)
        #initial_state.regs.rsp = claripy.BVS('rsp', size=64)
        #initial_state.add_constraints(initial_state.regs.rsp == 0x77777777)
        #initial_state.regs.rbp = claripy.BVS('rbp', size=64)
        #initial_state.add_constraints(initial_state.regs.rbp == 0x77777777)
        #cfg_slow = self._proj.analyses.CFGEmulated(starts=[func.addr], initial_state=initial_state, keep_state=True, state_add_options=angr.sim_options.refs, state_remove_options=[angr.sim_options.OPTIMIZE_IR], iropt_level=0)
        #for scc in nx.strongly_connected_components(cfg_slow.graph):
        #    if len(scc) <= 1:
        #        continue
        #    print("SCC: {}".format(scc))
        #    for node in scc:
        #        print(" node: {}".format(node))
        #        for state in node.final_states:
        #            print("  state: {}".format(state))
        #            state_history = state.history
        #            for action in state_history.actions:
        #                if isinstance(action, angr.state_plugins.SimActionData) and action.type == angr.state_plugins.SimActionData.MEM:
        #                    #addr = state.solver.eval(action.addr)
        #                    addr = action.addr
        #                    data = action.data
        #                    print("    mem: {} addr: {} data: {}".format(action, addr, data))

        #                if isinstance(action, angr.state_plugins.SimActionData) and action.type == angr.state_plugins.SimActionData.REG:
        #                    #addr = state.solver.eval(action.addr)
        #                    data = action.data
        #                    print("    reg: {} {}".format(action, data))
        '''
        ddg = self._proj.analyses.DDG(cfg_slow, start=func.addr, call_depth=0)
        for imm_to_insns in imm_sets_in_subgraph:
            for imm, insns in imm_to_insns.items():
                print("imm: {} insns: {}".format(imm, insns))
                for insn in insns:
                    insn_nodes = cfg_slow.model.get_all_nodes(addr=insn.address, anyaddr=True)
                    print("insn nodes: {}".format(insn_nodes))
                    for insn_node in insn_nodes:
                        print("insn node: {}".format(insn_node))
                        insn_block_addr = insn_node.addr
                        #block = self._proj.factory.block(addr=insn_block_addr, opt_level=1)
                        #block = proj.factory.block(addr=node.addr)
                        block = insn_node.block

                        insn_vex_stmts = self.find_vex_for_insn(block, insn)
                        print("insn vex stmts:")
                        for i, stmt in insn_vex_stmts:
                            print("  {}: {} ({})".format(i, stmt, stmt.tag))
                        vex_stmts = self.find_vex_const(insn_vex_stmts, imm)
                        print("Vex statements for imm: {} (0x{:x}) insn: {} (addr: 0x{:x})".format(imm, imm, insn, insn.address))
                        for i, stmt in vex_stmts:
                            code_location = angr.code_location.CodeLocation(insn_block_addr, i)
                            print(i, end=' ')
                            stmt.pp()
                            data_graph_contains = False
                            for pv_node in ddg.data_graph.nodes():
                                pv_code_location = pv_node.location
                                if pv_code_location.block_addr == insn_block_addr and pv_code_location.stmt_idx == i:
                                    data_graph_contains = True
                            print("DDG has (0x{:x}, {}) : statement graph: {} data graph: {}".format(insn_block_addr, i, ddg.graph.has_node(code_location), data_graph_contains))
        '''
        '''
        for imm_to_insns in imm_sets_in_subgraph:
            for imm, insns in imm_to_insns.items():
                print("imm: {} (0x{:x}) insns: {}".format(imm, imm, insns))
                for insn in insns:
                    insn_block_addr = self._cfg.model.get_any_node(addr=insn.address, anyaddr=True).addr
                    print("insn: {} (addr: 0x{:x} block_addr: 0x{:x})".format(insn, insn.address, insn_block_addr))
                    vex_stmts = self.find_vex_const(self._proj, self._cfg, insn, imm)
                    start_state = self._proj.factory.blank_state(addr=insn_block_addr)
                    print("vex stmts: {}".format(vex_stmts))
                    def memwrite_bp(state):
                        if state.addr == insn.address or state.addr == insn_block_addr:
                            print("mem write expr: {} (state addr: 0x{:x})".format(state.inspect.mem_write_expr, state.addr))
                    def regwrite_bp(state):
                        if state.addr == insn.address or state.addr == insn_block_addr:
                            print("reg write expr: {} (state addr: 0x{:x})".format(state.inspect.reg_write_expr, state.addr))
                    def tmpwrite_bp(state):
                        if state.addr == insn.address or state.addr == insn_block_addr:
                            print("tmp write expr: {} (state addr: 0x{:x})".format(state.inspect.tmp_write_expr, state.addr))
                    #start_state.inspect.b('mem_write', when=angr.BP_BEFORE, action=memwrite_bp)
                    #start_state.inspect.b('reg_write', when=angr.BP_BEFORE, action=regwrite_bp)
                    #start_state.inspect.b('tmp_write', when=angr.BP_BEFORE, action=tmpwrite_bp)
                    found_state = [False]
                    def statement_bp(state):
                        stmt_idx = state.inspect.statement
                        state_block_addr = self._cfg.model.get_any_node(addr=state.addr, anyaddr=True).addr
                        block = self._proj.factory.block(addr=state_block_addr, opt_level=0)
                        irsb = block.vex
                        stmt = irsb.statements[stmt_idx]
                        print("statement_bp: [{}] (0x{:x} 0x{:x} 0x{:x}) ".format(stmt_idx, state.addr, insn.address, insn_block_addr))
                        #if  any(stmt_idx == i[0] for i in vex_stmts):
                        if imm in [c.value for c in stmt.constants]:
                            found_state[0] = True
                            stmt_tag = stmt.tag
                            print("found statement: {} {} tag: {} constants: {}".format(stmt_idx, stmt, stmt.tag, imm in [c.value for c in stmt.constants]))
                            if stmt_tag == 'Ist_WrTmp':
                                pass
                            elif stmt_tag == 'Ist_Store':
                                pass
                            elif stmt_tag == 'Ist_Put':
                                pass
                            else:
                                raise Exception("in statement_bp, we do not know how to handle statement with tag: {}".format(stmt_tag))
                    start_state.inspect.b('statement', when=angr.BP_AFTER, action=statement_bp)
                    simgr = self._proj.factory.simulation_manager(start_state)
                    while not found_state[0]:
                        simgr.step()
        '''



        return True

    def find_vex_for_insn(self, block, insn):
        vex_stmts = []
        irsb = block.vex
        irsb.pp()
        for i in range(len(irsb.statements)):
            stmt = irsb.statements[i]
            if stmt.tag == 'Ist_IMark' and stmt.addr == insn.address:
                break
        insn_vex_start = i
                
        for i in range(insn_vex_start + 1, len(irsb.statements)): # Skip the IMark
            stmt = irsb.statements[i]
            if stmt.tag == 'Ist_IMark':
                break
            vex_stmts.append((i, stmt))

        if len(vex_stmts) == 0:
            #print("0x{:x}".format(imm))
            #print(irsb)
            raise Exception("Could vex statements for insn: {} address 0x{:x}".format(insn, insn.address))
        return vex_stmts

    def find_vex_const(self, vex_stmts, imm):
       const_vex_stmts = []
       for i, stmt in vex_stmts: 
            constants = set([const.value for const in stmt.constants]).union(set([bitstring.Bits(uint=const.value, length=const.size).int for const in stmt.constants]))
            #constants = set([bitstring.bits(uint=const.value, length=const.size).int for const in stmt.constants])
            #[const.pp() for const in stmt.constants]
            #print(i, stmt, constants)

            if imm in constants:
                const_vex_stmts.append((i, stmt))
                #return i, stmt
                #return vex_stmts

       if len(const_vex_stmts) == 0:
            #print("0x{:x}".format(imm))
            #print(irsb)
            raise Exception("Could not find imm in vex statements")

       return const_vex_stmts

    def get_subcallgraph_eccentricity(self, func):
        callgraph = self._proj.kb.callgraph
        func_call_descendants = list(nx.descendants(callgraph, func.addr))
        #print(func_call_descendants)
        subcallgraph = callgraph.subgraph([func.addr] + func_call_descendants)
        #print(type(subcallgraph))
        #print(subcallgraph.nodes())
        #print(func.addr)
        return nx.eccentricity(subcallgraph, func.addr)



    def contains_all_imm_mnem_sets(self, func, imm_mnem_sets):
        # imm_mnem_sets is a tuple (imm, (mnem1, mnem2, ...)) where imm is the immediate (constant) to search for and the mnems are the mnemonics that it may be used with
        imm_to_insns = {}
        for imm, mnems in imm_mnem_sets:
            imm_mnems = (imm, mnems)
            found_insns = self.find_imm_mnem_set(func, imm_mnems)

            if len(found_insns) == 0:
                return None
            assert imm not in imm_to_insns, "immediates must be unique! You should union their mnemonics."
            imm_to_insns[imm] = found_insns
        return imm_to_insns




    def find_imm_mnem_set(self, func, imm_mnems):
        imm, mnems = imm_mnems
        found_insns = []
        for block in func.blocks:
            insns = block.capstone.insns
            for insn in insns:
                if insn.mnemonic[0] == 'j':
                    # Probably a jump instruction
                    continue
                for op in insn.operands:
                    if op.type == 2: # Capstone uses 2 for immediate operand types
                        if op.imm == imm:
                            if any((mnem in insn.mnemonic) or (insn.mnemonic in mnem) for mnem in mnems):
                                found_insns.append(insn)
        return found_insns

    def generate_models(self):
        models_file_name = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'hash_func_models.json')
        hash_func_models = []
        with open(models_file_name) as fd:
            hash_func_models_dict = json.loads(fd.read())
            for hash_alg_name in hash_func_models_dict['hash_models']:
                hash_alg_models = hash_func_models_dict['hash_models'][hash_alg_name]['models']
                
                for i, hash_alg_model in enumerate(hash_alg_models):
                    # Converting the immediates to ints
                    imm_mnems_sets = []
                    for imm_mnems_set_str in hash_alg_model['constants']:
                        imm_mnems_set = []
                        for imm, mnems in imm_mnems_set_str.items():
                            imm_mnems_set.append((int(imm), tuple(mnems)))
                        imm_mnems_sets.append(tuple(imm_mnems_set))

                    #constant_mnem_sets = [constant_mnems_set.items() for constant_mnems_set in hash_alg_model['constants']]
                    #print(imm_mnems_sets)
                    model_id = hash_alg_name
                    if len(hash_alg_models) > 1:
                        model_id += "_{}".format(i)

                    graphs = []
                    graph_json_strs = hash_alg_model['graphs']
                    for graph_json_str in graph_json_strs:
                        graph = json_graph.node_link_graph(graph_json_str)
                        graphs.append(graph)
                    sccs = []
                    scc_json_strs = hash_alg_model['sccs']
                    for scc_json_str in scc_json_strs:
                        scc = json_graph.node_link_graph(scc_json_str)
                        sccs.append(scc)

                    hfm = HashFuncModel(model_id, hash_alg_name, imm_mnems_sets, graphs, sccs)
                    hash_func_models.append(hfm)
        return hash_func_models

    def model_checks(self, hash_func_models):
        all_graphs = [graph for hash_func_model in hash_func_models for graph in hash_func_model.graphs]
        for g1, g2 in itertools.combinations(all_graphs, 2):
            # For our model graphs, we want isomorphic graphs to be equal
            g1_g2_isomorphic = nx.is_isomorphic(g1, g2)
            g1_g2_equal = self.graphs_equal(g1, g2)
            assert g1_g2_isomorphic == g1_g2_equal, "We want hash func model graphs to be equal, if they are isomorphic"


    def graphs_equal(self, g1, g2):
        return set(g1.nodes()) == set(g2.nodes()) and set(g1.edges()) == set(g2.edges())


class HashFuncModel:
    # imm_mnem_sets is an iterable of tuples [[(imm1, (mnem11, mnem12, ...), (imm2, (mnem21, mnem22)))], [(imm3, (mnem31, ...))]]
    # All imms sets in the same inner list MUST appear in the same hash function (with one of their allowed mnems)
    # All these sets show the allowed sets that we will check if one of appears in the function
    def __init__(self, model_id, hash_alg_name, imm_mnem_sets, graphs, sccs):
        self.model_id = model_id
        self.hash_alg_name = hash_alg_name
        self.imm_mnem_sets = imm_mnem_sets
        self.graphs = graphs
        self.sccs = sccs
        pass


class FuncHashFuncModelGraphIsomorphismCache():

    def __init__(self):
        self._cache = {}
        self._subgraph_isos_cache = {}


    def check_isomorphic(self, func, hash_func_model_graph):
        if self._check_cache(func, hash_func_model_graph):
            #print("Used cached result!")
            return self._get_cache(func, hash_func_model_graph)

        digraph_matcher = nx.algorithms.isomorphism.DiGraphMatcher(func.graph, hash_func_model_graph)
        is_isomorphic = digraph_matcher.subgraph_is_isomorphic()
        self._add_cache(func, hash_func_model_graph, is_isomorphic)
        if is_isomorphic:
            nodes_map = list(digraph_matcher.subgraph_isomorphisms_iter())
            self._add_subgraph_isos_cache(func, hash_func_model_graph, nodes_map)

        return is_isomorphic




    def _check_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        if func_addr_graph in self._cache:
            return True
        return False

    def _get_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._cache, "{} not in cache, did you check with _check_cache first?".format(func_addr_graph)
        return self._cache[func_addr_graph]

    def _add_cache(self, func, hash_func_model_graph, is_isomorphic):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._cache, "{} already in cache, did you check with _check_cache first?".format(func_addr_graph)
        self._cache[func_addr_graph] = is_isomorphic
        assert self._check_cache(func, hash_func_model_graph), "Add cache failed"

    def get_subgraph_isos(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._subgraph_isos_cache, "{} not in subgraph isomorphisms cache, did you check with check_isomorphic first?".format(func_addr_graph)
        return self._subgraph_isos_cache[func_addr_graph]

    def _add_subgraph_isos_cache(self, func, hash_func_model_graph, subgraph_isos):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._subgraph_isos_cache, "{} already in subgraph isomorphisms cache, did you check with _check_cache first?".format(func_addr_graph)
        self._subgraph_isos_cache[func_addr_graph] = subgraph_isos



    def _graph_to_tuples(self, graph):
        return (tuple(graph.nodes()), tuple(graph.edges()))

