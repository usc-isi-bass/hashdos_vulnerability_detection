import angr
import os
import json
import itertools
import networkx as nx
from networkx.readwrite import json_graph

from hash_func_discovery.static_memory_access_analysis import TmpSrcReg,TmpSrcConst,TmpSrcLoadConst
from hash_func_discovery.static_memory_access_analysis import find_mem_accesses

class HashFuncDiscoverer:

    def __init__(self, proj, cfg):
        self._proj = proj
        self._cfg = cfg

        self._hash_func_models = self.generate_models()
        #self.model_checks(self._hash_func_models)
        self._subgraph_isos_cache = FuncHashFuncModelGraphIsomorphismCache()
        self._func_model_features = {} # Store the features we observed for a function with respect to a model

    def discover_hash_funcs(self):
        discovered_hash_funcs = {}
        funcs_matching_weak_hash_alg_template = {}
        for func_addr, func in self._cfg.functions.items():
            passed_sccs_to_mem_accs = self.match_func_weak_hash_alg_template(func)
            if len(passed_sccs_to_mem_accs) > 0:
                assert func_addr not in funcs_matching_weak_hash_alg_template
                funcs_matching_weak_hash_alg_template[func_addr] = passed_sccs_to_mem_accs

        func_addr_to_imm_mnem_pairs = {}
        for func_addr in funcs_matching_weak_hash_alg_template:
            func = self._cfg.functions.function(addr=func_addr)
            imm_mnem_pair_to_insn = self.extract_imm_mnem_pairs(func)
            if len(imm_mnem_pair_to_insn) > 0:
                func_addr_to_imm_mnem_pairs[func_addr] = imm_mnem_pair_to_insn


        for func_addr in func_addr_to_imm_mnem_pairs:
            imm_mnem_pair_to_insn = func_addr_to_imm_mnem_pairs[func_addr]
            passed_sccs_to_mem_accs = funcs_matching_weak_hash_alg_template[func_addr]

            self._func_model_features[func_addr] = {}
            func = self._cfg.functions.function(addr=func_addr)
            assert func is not None, "Could not find hash func at addr: {}".format(func_addr)
            for hash_func_model in self._hash_func_models:
                hash_alg_name = hash_func_model.hash_alg_name
                if self.check_model(func, hash_func_model, imm_mnem_pair_to_insn, passed_sccs_to_mem_accs):
                    if hash_alg_name not in discovered_hash_funcs:
                        discovered_hash_funcs[hash_alg_name] = []
                    discovered_hash_func_model_features = self._func_model_features[func.addr][hash_func_model.model_id]
                    discovered_hash_funcs[hash_alg_name].append((func, func.addr, 100, discovered_hash_func_model_features))
        return discovered_hash_funcs

    def match_func_weak_hash_alg_template(self, func):
        func_graph_sccs = list(filter(lambda scc: len(func.graph.subgraph(scc).edges()) > 0, nx.strongly_connected_components(func.graph)))

        #func_graph_cond = nx.condensation(func.graph, scc=func_graph_sccs)
        any_scc_passes = False
        largest_passed_scc_node_addrs = None

        passed_sccs_to_mem_accs = {}
        for scc in func_graph_sccs:
            #print("SCC: {}".format(scc))
            regs_write = set()
            regs_read = set()
            consts_only_write = set()
            consts_only_read = set()

            for block_node in scc:
                block_addr = block_node.addr
                block = self._proj.factory.block(addr=block_addr, opt_level=-1)
                mem_accesses = find_mem_accesses(self._proj, block)
                for macc in mem_accesses:
                    stmt = macc.stmt
                    stmt_i = macc.stmt_i
                    access_type = macc.access_type
                    assert access_type == 'read' or access_type == 'write', "Unknown access_type: {}".format(access_type)
                    #print("{}:: {}: {} @ 0x{:x}".format(macc.access_type.upper(), stmt_i, stmt, macc.insn_addr))
                    #print('mem loc srcs: {}'.format(list((src, src.stmt, src.stmt_i) for src in macc.mem_loc_srcs)))
                    for src in macc.mem_loc_srcs:
                        if isinstance(src, TmpSrcReg):
                            # If the memory access uses a tmp for the address and that tmp is traced back to a reg
                            reg_offset = src.reg_offset
                            reg_name = self._proj.arch.translate_register_name(reg_offset)
                            if access_type == 'read':
                                regs_read.add(reg_name)
                            elif access_type == 'write':
                                regs_write.add(reg_name)
                            #print("  {}: {} [tmps: {}] reg: {}".format(src.stmt_i, src.stmt, src.tracked_tmps, reg_name))
                        elif isinstance(src, TmpSrcLoadConst):
                            raise Exception('Logic error: I assumed this is not possible to trace the address of a VEX memory read/write from a tmp back to a constant being loaded. However, statement {} in block {} at insn addr {} seems to contradict this.'.format(stmt_i, block_addr, macc.insn_addr))
                        elif isinstance(src, TmpSrcConst):
                            # If the source of the memory access is a tmp, traced back to a constant, but there are no registers also being read from.
                            if not any(isinstance(src, TmpSrcReg) for src in macc.mem_loc_srcs):
                                const = src.const.value
                                #print("  {}: {} [tmps: {}] const: {}".format(src.stmt_i, src.stmt, src.tracked_tmps, src.const))
                                if access_type == 'read':
                                    consts_only_read.add(const)
                                elif access_type == 'write':
                                    consts_only_write.add(const)
                        elif isinstance(src, MemLocConstSrc):
                            # If the source if the memory access is an immediate constant
                            const = src.const.value
                            if access_type == 'read':
                                consts_only_read.add(const)
                            elif access_type == 'write':
                                consts_only_write.add(const)
            #print("Regs write: {}".format(regs_write))
            #print("Regs read: {}".format(regs_read))
            #print("Consts write: {}".format(consts_only_write))
            #print("Consts read: {}".format(consts_only_read))
            scc_passes = self.check_mem_acc_legality(consts_only_read, consts_only_write, regs_read, regs_write)
            scc_addrs = tuple(block_node.addr for block_node in scc)

            mem_accs = {
                'regs_write': tuple(regs_write), # Registers being written to
                'regs_read': tuple(regs_read), # Registers being read from
                'consts_only_write': tuple(consts_only_write), # Constants that are the only source of a memory write
                'consts_only_read': tuple(consts_only_read), # Constants that are the only source of a memory read
                'passes': scc_passes
            }

            if scc_passes:
                assert scc_addrs not in passed_sccs_to_mem_accs, "Logic error: SCC {} already in map".format(scc_addrs)
                passed_sccs_to_mem_accs[scc_addrs] = mem_accs

        return passed_sccs_to_mem_accs

    def extract_imm_mnem_pairs(self, func):
        imm_mnem_pairs = {}
        for block in func.blocks:
            insns = block.capstone.insns
            for insn in insns:
                if insn.mnemonic[0] == 'j':
                    # Probably a jump instruction
                    continue
                for op in insn.operands:
                    if op.type == 2: # Capstone uses 2 for immediate operand types
                        imm_mnem_pairs[(op.imm, insn.mnemonic)] = insn
        return imm_mnem_pairs



    def check_model(self, func, hash_func_model, func_imm_mnem_pair_to_insn, passed_sccs_to_mem_accs):
        assert hash_func_model.model_id not in self._func_model_features[func.addr], "Did we already check this model? Or are there duplicate model IDs?"
        self._func_model_features[func.addr][hash_func_model.model_id] = {}
        imm_mnem_sets = hash_func_model.imm_mnem_sets
        imm_mnem_set_to_insns = {}
        for imm_mnem_set in imm_mnem_sets:
            imm_to_insns = self.contains_all_imm_mnem_sets(func, func_imm_mnem_pair_to_insn, imm_mnem_set)
            # We only care about the immediates for which we could find all the other immedates in the set as well
            if imm_to_insns is None:
                continue
            imm_mnem_set_to_insns[imm_mnem_set] = imm_to_insns
        # We could not find any complete set constants
        if len(imm_mnem_set_to_insns) == 0:
            return False

        self._func_model_features[func.addr][hash_func_model.model_id]['passed_sccs_mem_accs'] = passed_sccs_to_mem_accs
        largest_passed_scc_node_addrs = None
        for passed_scc in passed_sccs_to_mem_accs:
                if largest_passed_scc_node_addrs is None or len(passed_scc) > len(largest_passed_scc_node_addrs):
                    largest_passed_scc_node_addrs = passed_scc

        self._func_model_features[func.addr][hash_func_model.model_id]['largest_passed_scc_node_addrs'] = largest_passed_scc_node_addrs

        return True


    def check_mem_acc_legality(self, consts_only_read, consts_only_write, regs_read, regs_write):
            # We do not expect a hash func to write to a constant memory address
            if len(consts_only_write) > 0:
                return False
            # We do not expect a hash func to write to memory addresses contained in non-stack regs
            non_stack_regs_write = list(filter(lambda reg_name: not(reg_name.endswith('sp') or reg_name.endswith('bp')), regs_write))
            if len(non_stack_regs_write) > 0:
                return False
            return True


    def get_subcallgraph_eccentricity(self, func):
        callgraph = self._proj.kb.callgraph
        func_call_descendants = list(nx.descendants(callgraph, func.addr))
        #print(func_call_descendants)
        subcallgraph = callgraph.subgraph([func.addr] + func_call_descendants)
        #print(type(subcallgraph))
        #print(subcallgraph.nodes())
        #print(func.addr)
        return nx.eccentricity(subcallgraph, func.addr)



    def contains_all_imm_mnem_sets(self, func, func_imm_mnem_pair_to_insn, imm_mnem_sets):
        # imm_mnem_sets is a tuple (imm, (mnem1, mnem2, ...)) where imm is the immediate (constant) to search for and the mnems are the mnemonics that it may be used with
        imm_to_insns = {}
        for imm, mnems in imm_mnem_sets:
            imm_mnems = (imm, mnems)
            found_insns = self.find_imm_mnem_set(func, func_imm_mnem_pair_to_insn, imm_mnems)

            if len(found_insns) == 0:
                return None
            assert imm not in imm_to_insns, "immediates must be unique! You should union their mnemonics."
            imm_to_insns[imm] = found_insns
        return imm_to_insns




    def find_imm_mnem_set(self, func, func_imm_mnem_pairs, imm_mnems):
        imm, mnems = imm_mnems
        found_insns = []
        for func_imm, func_mnem in func_imm_mnem_pairs:
            if func_imm == imm:
                if any((mnem in func_mnem) or (func_mnem in mnem) for mnem in mnems):
                    insn = func_imm_mnem_pairs[func_imm, func_mnem]
                    found_insns.append(insn)
        return found_insns

    def generate_models(self):
        models_file_name = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'hash_func_models.json')
        hash_func_models = []
        with open(models_file_name) as fd:
            hash_func_models_dict = json.loads(fd.read())
            graph_name_to_graph = {}
            for graph_name, graph_json in hash_func_models_dict['graphs'].items():
                graph_name_to_graph[graph_name] = json_graph.node_link_graph(graph_json)
            for hash_alg_name in hash_func_models_dict['hash_models']:
                hash_alg_models = hash_func_models_dict['hash_models'][hash_alg_name]['models']

                for i, hash_alg_model in enumerate(hash_alg_models):
                    # Converting the immediates to ints
                    imm_mnems_sets = []
                    for imm_mnems_set_str in hash_alg_model['constants']:
                        imm_mnems_set = []
                        for imm, mnems in imm_mnems_set_str.items():
                            imm_mnems_set.append((int(imm), tuple(mnems)))
                        imm_mnems_sets.append(tuple(imm_mnems_set))

                    #constant_mnem_sets = [constant_mnems_set.items() for constant_mnems_set in hash_alg_model['constants']]
                    #print(imm_mnems_sets)
                    model_id = hash_alg_name
                    if len(hash_alg_models) > 1:
                        model_id += "_{}".format(i)

                    graphs = []
                    graph_names = hash_alg_model['graph_names']
                    for graph_name in graph_names:
                        graph = graph_name_to_graph[graph_name]
                        graphs.append(graph)

                    hfm = HashFuncModel(model_id, hash_alg_name, imm_mnems_sets, graphs)
                    hash_func_models.append(hfm)
        return hash_func_models

    def model_checks(self, hash_func_models):
        all_graphs = [graph for hash_func_model in hash_func_models for graph in hash_func_model.graphs]
        #print("Total num graphs: {}".format(len(all_graphs)))
        for g1, g2 in itertools.combinations(all_graphs, 2):
            # For our model graphs, we want isomorphic graphs to be equal
            g1_g2_isomorphic = nx.is_isomorphic(g1, g2)
            g1_g2_equal = self.graphs_equal(g1, g2)
            assert g1_g2_isomorphic == g1_g2_equal, "We want hash func model graphs to be equal, if they are isomorphic"


    def graphs_equal(self, g1, g2):
        return set(g1.nodes()) == set(g2.nodes()) and set(g1.edges()) == set(g2.edges())


class HashFuncModel:
    # imm_mnem_sets is an iterable of tuples [[(imm1, (mnem11, mnem12, ...), (imm2, (mnem21, mnem22)))], [(imm3, (mnem31, ...))]]
    # All imms sets in the same inner list MUST appear in the same hash function (with one of their allowed mnems)
    # All these sets show the allowed sets that we will check if one of appears in the function
    def __init__(self, model_id, hash_alg_name, imm_mnem_sets, graphs):
        self.model_id = model_id
        self.hash_alg_name = hash_alg_name
        self.imm_mnem_sets = imm_mnem_sets
        self.graphs = graphs
        pass


class FuncHashFuncModelGraphIsomorphismCache():

    def __init__(self):
        self._cache = {}
        self._subgraph_isos_cache = {}


    def check_isomorphic(self, func, hash_func_model_graph):
        if self._check_cache(func, hash_func_model_graph):
            #print("Used cached result!")
            return self._get_cache(func, hash_func_model_graph)

        digraph_matcher = nx.algorithms.isomorphism.DiGraphMatcher(func.graph, hash_func_model_graph)
        #is_isomorphic = digraph_matcher.subgraph_is_isomorphic()
        is_isomorphic = digraph_matcher.subgraph_is_monomorphic()
        self._add_cache(func, hash_func_model_graph, is_isomorphic)
        if is_isomorphic:
            #nodes_map = list(digraph_matcher.subgraph_isomorphisms_iter())
            nodes_map = list(digraph_matcher.subgraph_monomorphisms_iter())
            self._add_subgraph_isos_cache(func, hash_func_model_graph, nodes_map)

        return is_isomorphic


    def _check_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        if func_addr_graph in self._cache:
            return True
        return False

    def _get_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._cache, "{} not in cache, did you check with _check_cache first?".format(func_addr_graph)
        return self._cache[func_addr_graph]

    def _add_cache(self, func, hash_func_model_graph, is_isomorphic):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._cache, "{} already in cache, did you check with _check_cache first?".format(func_addr_graph)
        self._cache[func_addr_graph] = is_isomorphic
        assert self._check_cache(func, hash_func_model_graph), "Add cache failed"

    def get_subgraph_isos(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._subgraph_isos_cache, "{} not in subgraph isomorphisms cache, did you check with check_isomorphic first?".format(func_addr_graph)
        return self._subgraph_isos_cache[func_addr_graph]

    def _add_subgraph_isos_cache(self, func, hash_func_model_graph, subgraph_isos):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._subgraph_isos_cache, "{} already in subgraph isomorphisms cache, did you check with _check_cache first?".format(func_addr_graph)
        self._subgraph_isos_cache[func_addr_graph] = subgraph_isos



    def _graph_to_tuples(self, graph):
        return (tuple(graph.nodes()), tuple(graph.edges()))

