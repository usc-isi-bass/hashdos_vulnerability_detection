import angr
import os
import json
import itertools
import networkx as nx
from networkx.readwrite import json_graph

from hash_func_discovery.static_memory_access_analysis import TmpSrcReg,TmpSrcLoadConst
from hash_func_discovery.static_memory_access_analysis import find_mem_accesses

class HashFuncDiscoverer:

    def __init__(self, proj, cfg):
        self._proj = proj
        self._cfg = cfg

        self._hash_func_models = self.generate_models()
        #self.model_checks(self._hash_func_models)
        self._subgraph_isos_cache = FuncHashFuncModelGraphIsomorphismCache()
        self._func_model_features = {} # Store the features we observed for a function with respect to a model

    def discover_hash_funcs(self):
        discovered_hash_funcs = {}
        for func_addr, func in self._cfg.functions.items():
            self._func_model_features[func_addr] = {}
            for hash_func_model in self._hash_func_models:
                hash_alg_name = hash_func_model.hash_alg_name
                if self.check_model(func, hash_func_model):
                    if hash_alg_name not in discovered_hash_funcs:
                        discovered_hash_funcs[hash_alg_name] = []
                    discovered_hash_func_model_features = self._func_model_features[func.addr][hash_func_model.model_id]
                    discovered_hash_funcs[hash_alg_name].append((func, func.addr, 100, discovered_hash_func_model_features))
        return discovered_hash_funcs

    def check_model(self, func, hash_func_model):
        assert hash_func_model.model_id not in self._func_model_features[func.addr], "Did we already check this model? Or are there duplicate model IDs?"
        self._func_model_features[func.addr][hash_func_model.model_id] = {}
        subcallgraph_eccentricity = self.get_subcallgraph_eccentricity(func)
        self._func_model_features[func.addr][hash_func_model.model_id]['subcallgraph_eccentricity'] = subcallgraph_eccentricity
        imm_mnem_sets = hash_func_model.imm_mnem_sets
        imm_mnem_set_to_insns = {}
        for imm_mnem_set in imm_mnem_sets:
            imm_to_insns = self.contains_all_imm_mnem_sets(func, imm_mnem_set)
            # We only care about the immediates for which we could find all the other immedates in the set as well
            if imm_to_insns is None:
                continue
            imm_mnem_set_to_insns[imm_mnem_set] = imm_to_insns
        # We could not find any complete set constants
        if len(imm_mnem_set_to_insns) == 0:
            return False
        #print("func: {}@0x{:x}".format(func.name, func.addr))
        #print("  {}".format(hash_func_model.hash_alg_name))
        #print("  {}".format(imm_mnem_set_to_insns))
        func_graph_sccs = list(nx.strongly_connected_components(func.graph))
        func_graph_cond = nx.condensation(func.graph, scc=func_graph_sccs)
        in_range_sccs = []
        # Go through all constant-mnemonic finger prints found
        for imm_to_insns in imm_mnem_set_to_insns.values():
            # Go through SCCs and check if an instruction for every set of instructions is within range of the SCC (filter out trivial SCCs)
            for cond_scc_node, scc in enumerate(func_graph_sccs):
                if len(func.graph.subgraph(scc).edges()) == 0:
                    continue
                #print("scc: {}".format(scc))
                all_insn_sets_in_range = True
                # Go through the found instructions for every immediate
                for insns in imm_to_insns.values():
                    insn_nodes = set([self._cfg.model.get_any_node(insn.address, anyaddr=True) for insn in insns])
                    insn_block_nodes = [angr.codenode.BlockNode(node.addr, node.size) for node in insn_nodes]
                    #print('block nodes: {}'.format(insn_block_nodes))

                    # Check if any of them are in range of the SCC
                    any_insn_node_in_range = False
                    for insn_node in insn_block_nodes:
                        #print(insn_node)
                        cond_insn_node = func_graph_cond.graph['mapping'][insn_node]
                        if nx.has_path(func_graph_cond, cond_insn_node, cond_scc_node):
                            shortest_path = nx.shortest_path(func_graph_cond, cond_insn_node, cond_scc_node)
                            #print('shortest path len: {}'.format(len(shortest_path)))
                            if len(shortest_path) <= 2:
                                any_insn_node_in_range = True
                                break
                        else:
                            #print(func_graph_cond.edges())
                            #print(func_graph_cond.nodes[cond_insn_node])
                            #print(func_graph_cond.nodes[cond_scc_node])
                            #print("No path from {} to {}".format(cond_insn_node, cond_scc_node))
                            pass
                    if not any_insn_node_in_range:
                        all_insn_sets_in_range = False
                        break

                if all_insn_sets_in_range:
                    #print("in range scc: {} ({})".format(scc, imm_to_insns))
                    in_range_sccs.append(scc)
        #print("in range sccs: {}".format(in_range_sccs))
        any_scc_passes = False
        self._func_model_features[func.addr][hash_func_model.model_id]['in_range_sccs_mem_accs'] = {}
        for scc in in_range_sccs:
            #print("SCC: {}".format(scc))
            regs_write = set()
            regs_read = set()
            consts_write = set()
            consts_read = set()

            for block_node in scc:
                block_addr = block_node.addr
                block = self._proj.factory.block(addr=block_addr, opt_level=-1)
                mem_accesses = find_mem_accesses(self._proj, block)
                for macc in mem_accesses:
                    stmt = macc.stmt
                    stmt_i = macc.stmt_i
                    access_type = macc.access_type
                    assert access_type == 'read' or access_type == 'write', "Unknown access_type: {}".format(access_type)
                    #print("{}:: {}: {} @ 0x{:x}".format(macc.access_type.upper(), stmt_i, stmt, macc.insn_addr))
                    for src in macc.mem_loc_srcs:
                        if isinstance(src, TmpSrcReg):
                            reg_offset = src.reg_offset
                            reg_name = self._proj.arch.translate_register_name(reg_offset)
                            if access_type == 'read':
                                regs_read.add(reg_name)
                            elif access_type == 'write':
                                regs_write.add(reg_name)
                            #print("  {}: {} [tmps: {}] reg: {}".format(src.stmt_i, src.stmt, src.tracked_tmps, reg_name))
                        elif isinstance(src, TmpSrcLoadConst):
                            #print("  {}: {} [tmps: {}] const: {}".format(src.stmt_i, src.stmt, src.tracked_tmps, src.const))
                            if access_type == 'read':
                                consts_read.add(reg_name)
                            elif access_type == 'write':
                                consts_write.add(reg_name)
            #print("Regs write: {}".format(regs_write))
            #print("Regs read: {}".format(regs_read))
            #print("Consts write: {}".format(consts_write))
            #print("Consts read: {}".format(consts_read))
            scc_passes = self.check_mem_acc_legality(consts_read, consts_write, regs_read, regs_write)

            scc_addrs = tuple(block_node.addr for block_node in scc)
            self._func_model_features[func.addr][hash_func_model.model_id]['in_range_sccs_mem_accs'][scc_addrs] = {
                'regs_write': tuple(regs_write),
                'regs_read': tuple(regs_read),
                'consts_write': tuple(consts_write),
                'consts_read': tuple(consts_read),
                'passes': scc_passes
            }

            any_scc_passes = any_scc_passes or scc_passes

        return any_scc_passes


    def check_mem_acc_legality(self, consts_read, consts_write, regs_read, regs_write):
            # We do not expect a hash func to load from or write to a constant memory address
            if len(consts_write) > 0 or len(consts_read) > 0:
                return False
            # We do not expect a hash func to write to memory addresses contained in non-stack regs
            non_stack_regs_write = list(filter(lambda reg_name: not(reg_name.endswith('sp') or reg_name.endswith('bp')), regs_write))
            if len(non_stack_regs_write) > 0:
                return False
            # We do not expect a hash func to read from memory addresses contained in more than one non-stack regs
            non_stack_regs_read = list(filter(lambda reg_name: not(reg_name.endswith('sp') or reg_name.endswith('bp')), regs_read))
            if len(non_stack_regs_read) > 1:
                return False
            return True


    def get_subcallgraph_eccentricity(self, func):
        callgraph = self._proj.kb.callgraph
        func_call_descendants = list(nx.descendants(callgraph, func.addr))
        #print(func_call_descendants)
        subcallgraph = callgraph.subgraph([func.addr] + func_call_descendants)
        #print(type(subcallgraph))
        #print(subcallgraph.nodes())
        #print(func.addr)
        return nx.eccentricity(subcallgraph, func.addr)



    def contains_all_imm_mnem_sets(self, func, imm_mnem_sets):
        # imm_mnem_sets is a tuple (imm, (mnem1, mnem2, ...)) where imm is the immediate (constant) to search for and the mnems are the mnemonics that it may be used with
        imm_to_insns = {}
        for imm, mnems in imm_mnem_sets:
            imm_mnems = (imm, mnems)
            found_insns = self.find_imm_mnem_set(func, imm_mnems)

            if len(found_insns) == 0:
                return None
            assert imm not in imm_to_insns, "immediates must be unique! You should union their mnemonics."
            imm_to_insns[imm] = found_insns
        return imm_to_insns




    def find_imm_mnem_set(self, func, imm_mnems):
        imm, mnems = imm_mnems
        found_insns = []
        for block in func.blocks:
            insns = block.capstone.insns
            for insn in insns:
                if insn.mnemonic[0] == 'j':
                    # Probably a jump instruction
                    continue
                for op in insn.operands:
                    if op.type == 2: # Capstone uses 2 for immediate operand types
                        if op.imm == imm:
                            if any((mnem in insn.mnemonic) or (insn.mnemonic in mnem) for mnem in mnems):
                                found_insns.append(insn)
        return found_insns

    def generate_models(self):
        models_file_name = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'hash_func_models.json')
        hash_func_models = []
        with open(models_file_name) as fd:
            hash_func_models_dict = json.loads(fd.read())
            graph_name_to_graph = {}
            for graph_name, graph_json in hash_func_models_dict['graphs'].items():
                graph_name_to_graph[graph_name] = json_graph.node_link_graph(graph_json)
            for hash_alg_name in hash_func_models_dict['hash_models']:
                hash_alg_models = hash_func_models_dict['hash_models'][hash_alg_name]['models']
                
                for i, hash_alg_model in enumerate(hash_alg_models):
                    # Converting the immediates to ints
                    imm_mnems_sets = []
                    for imm_mnems_set_str in hash_alg_model['constants']:
                        imm_mnems_set = []
                        for imm, mnems in imm_mnems_set_str.items():
                            imm_mnems_set.append((int(imm), tuple(mnems)))
                        imm_mnems_sets.append(tuple(imm_mnems_set))

                    #constant_mnem_sets = [constant_mnems_set.items() for constant_mnems_set in hash_alg_model['constants']]
                    #print(imm_mnems_sets)
                    model_id = hash_alg_name
                    if len(hash_alg_models) > 1:
                        model_id += "_{}".format(i)

                    graphs = []
                    graph_names = hash_alg_model['graph_names']
                    for graph_name in graph_names:
                        graph = graph_name_to_graph[graph_name]
                        graphs.append(graph)

                    hfm = HashFuncModel(model_id, hash_alg_name, imm_mnems_sets, graphs)
                    hash_func_models.append(hfm)
        return hash_func_models

    def model_checks(self, hash_func_models):
        all_graphs = [graph for hash_func_model in hash_func_models for graph in hash_func_model.graphs]
        #print("Total num graphs: {}".format(len(all_graphs)))
        for g1, g2 in itertools.combinations(all_graphs, 2):
            # For our model graphs, we want isomorphic graphs to be equal
            g1_g2_isomorphic = nx.is_isomorphic(g1, g2)
            g1_g2_equal = self.graphs_equal(g1, g2)
            assert g1_g2_isomorphic == g1_g2_equal, "We want hash func model graphs to be equal, if they are isomorphic"


    def graphs_equal(self, g1, g2):
        return set(g1.nodes()) == set(g2.nodes()) and set(g1.edges()) == set(g2.edges())


class HashFuncModel:
    # imm_mnem_sets is an iterable of tuples [[(imm1, (mnem11, mnem12, ...), (imm2, (mnem21, mnem22)))], [(imm3, (mnem31, ...))]]
    # All imms sets in the same inner list MUST appear in the same hash function (with one of their allowed mnems)
    # All these sets show the allowed sets that we will check if one of appears in the function
    def __init__(self, model_id, hash_alg_name, imm_mnem_sets, graphs):
        self.model_id = model_id
        self.hash_alg_name = hash_alg_name
        self.imm_mnem_sets = imm_mnem_sets
        self.graphs = graphs
        pass


class FuncHashFuncModelGraphIsomorphismCache():

    def __init__(self):
        self._cache = {}
        self._subgraph_isos_cache = {}


    def check_isomorphic(self, func, hash_func_model_graph):
        if self._check_cache(func, hash_func_model_graph):
            #print("Used cached result!")
            return self._get_cache(func, hash_func_model_graph)

        digraph_matcher = nx.algorithms.isomorphism.DiGraphMatcher(func.graph, hash_func_model_graph)
        #is_isomorphic = digraph_matcher.subgraph_is_isomorphic()
        is_isomorphic = digraph_matcher.subgraph_is_monomorphic()
        self._add_cache(func, hash_func_model_graph, is_isomorphic)
        if is_isomorphic:
            #nodes_map = list(digraph_matcher.subgraph_isomorphisms_iter())
            nodes_map = list(digraph_matcher.subgraph_monomorphisms_iter())
            self._add_subgraph_isos_cache(func, hash_func_model_graph, nodes_map)

        return is_isomorphic


    def _check_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        if func_addr_graph in self._cache:
            return True
        return False

    def _get_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._cache, "{} not in cache, did you check with _check_cache first?".format(func_addr_graph)
        return self._cache[func_addr_graph]

    def _add_cache(self, func, hash_func_model_graph, is_isomorphic):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._cache, "{} already in cache, did you check with _check_cache first?".format(func_addr_graph)
        self._cache[func_addr_graph] = is_isomorphic
        assert self._check_cache(func, hash_func_model_graph), "Add cache failed"

    def get_subgraph_isos(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._subgraph_isos_cache, "{} not in subgraph isomorphisms cache, did you check with check_isomorphic first?".format(func_addr_graph)
        return self._subgraph_isos_cache[func_addr_graph]

    def _add_subgraph_isos_cache(self, func, hash_func_model_graph, subgraph_isos):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._subgraph_isos_cache, "{} already in subgraph isomorphisms cache, did you check with _check_cache first?".format(func_addr_graph)
        self._subgraph_isos_cache[func_addr_graph] = subgraph_isos



    def _graph_to_tuples(self, graph):
        return (tuple(graph.nodes()), tuple(graph.edges()))

