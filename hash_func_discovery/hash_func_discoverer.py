import os
import json
import itertools
import networkx as nx
from networkx.readwrite import json_graph

class HashFuncDiscoverer:

    def __init__(self, proj, cfg):
        self._proj = proj
        self._cfg = cfg

        self._hash_func_models = self.generate_models()
        self.model_checks(self._hash_func_models)
        self._subgraph_isos_cache = FuncHashFuncModelGraphIsomorphismCache()

    def discover_hash_funcs(self):
        discovered_hash_funcs = {}
        for func_addr, func in self._cfg.functions.items():
            for hash_func_model in self._hash_func_models:
                hash_alg_name = hash_func_model.hash_alg_name
                if self.check_model(func, hash_func_model):
                    if hash_alg_name not in discovered_hash_funcs:                    
                        discovered_hash_funcs[hash_alg_name] = []
                    discovered_hash_funcs[hash_alg_name].append((func, func.addr, 100))
        return discovered_hash_funcs
            
    def check_model(self, func, hash_func_model):
        imm_mnem_sets = hash_func_model.imm_mnem_sets
        imm_mnem_set_to_insns = {}
        for imm_mnem_set in imm_mnem_sets:
            imm_to_insns = self.contains_all_imm_mnem_sets(func, imm_mnem_set)
            # We only care about the immediates for which we could find all the other immedates in the set as well
            if imm_to_insns is None:
                continue
            imm_mnem_set_to_insns[imm_mnem_set] = imm_to_insns
        # We could not find any complete set constants
        if len(imm_mnem_set_to_insns) == 0:
            return False
        #print("{}@0x{:x}".format(func.name, func.addr))
        #print("  {}".format(hash_func_model.hash_alg_name))
        #print("  {}".format(imm_mnem_set_to_insns))


        # The subgraphs of the function that are isomorphic to a graph in the hash function model
        isomorphic_subgraphs = []
        hash_func_graphs = hash_func_model.graphs
        #print("edges: {}".format(func.graph.edges()))
        for hash_func_graph in hash_func_graphs:
            is_isomorphic = self._subgraph_isos_cache.check_isomorphic(func, hash_func_graph)
            #print("model nodes: {} is_isomorphic: {}".format(len(hash_func_graph.nodes()), is_isomorphic))
            if is_isomorphic:
                #for nodes_map in digraph_matcher.subgraph_isomorphisms_iter():
                for nodes_map in self._subgraph_isos_cache.get_subgraph_isos(func, hash_func_graph):
                    isomorphic_subgraph = func.graph.subgraph(nodes_map.keys())
                    isomorphic_subgraphs.append(isomorphic_subgraph)

        # We could not find a subgraph that is isomorphic to one of the hash function graphs
        if len(isomorphic_subgraphs) == 0:
            return False

        return True



            


    def contains_all_imm_mnem_sets(self, func, imm_mnem_sets):
        # imm_mnem_sets is a tuple (imm, (mnem1, mnem2, ...)) where imm is the immediate (constant) to search for and the mnems are the mnemonics that it may be used with
        imm_to_insns = {}
        for imm, mnems in imm_mnem_sets:
            imm_mnems = (imm, mnems)
            found_insns = self.find_imm_mnem_set(func, imm_mnems)

            if len(found_insns) == 0:
                return None
            assert imm not in imm_to_insns, "immediates must be unique! You should union their mnemonics."
            imm_to_insns[imm] = found_insns
        return imm_to_insns 




    def find_imm_mnem_set(self, func, imm_mnems):
        imm, mnems = imm_mnems
        found_insns = []
        for block in func.blocks:
            insns = block.capstone.insns
            for insn in insns:
                if insn.mnemonic[0] == 'j':
                    # Probably a jump instruction
                    continue
                for op in insn.operands:
                    if op.type == 2: # Capstone uses 2 for immediate operand types
                        if op.imm == imm:
                            if any((mnem in insn.mnemonic) or (insn.mnemonic in mnem) for mnem in mnems):
                                found_insns.append(insn)        
        return found_insns

    def generate_models(self):
        models_file_name = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'hash_func_models.json')
        hash_func_models = []
        with open(models_file_name) as fd:
            hash_func_models_dict = json.loads(fd.read())
            for hash_alg_name in hash_func_models_dict['hash_models']:
                hash_alg_models = hash_func_models_dict['hash_models'][hash_alg_name]['models']
                for hash_alg_model in hash_alg_models:
                    # Converting the immediates to ints
                    imm_mnems_sets = []
                    for imm_mnems_set_str in hash_alg_model['constants']:
                        imm_mnems_set = []
                        for imm, mnems in imm_mnems_set_str.items():
                            imm_mnems_set.append((int(imm), tuple(mnems)))
                        imm_mnems_sets.append(tuple(imm_mnems_set))

                    #constant_mnem_sets = [constant_mnems_set.items() for constant_mnems_set in hash_alg_model['constants']]
                    #print(imm_mnems_sets)

                    graphs = []
                    graph_json_strs = hash_alg_model['graphs']
                    for graph_json_str in graph_json_strs:
                        graph = json_graph.node_link_graph(graph_json_str)
                        graphs.append(graph)

                    hfm = HashFuncModel(hash_alg_name, imm_mnems_sets, graphs)
                    hash_func_models.append(hfm)
        return hash_func_models

    def model_checks(self, hash_func_models):
        all_graphs = [graph for hash_func_model in hash_func_models for graph in hash_func_model.graphs]
        for g1, g2 in itertools.combinations(all_graphs, 2):
            # For our model graphs, we want isomorphic graphs to be equal
            g1_g2_isomorphic = nx.is_isomorphic(g1, g2)
            g1_g2_equal = self.graphs_equal(g1, g2)
            assert g1_g2_isomorphic == g1_g2_equal, "We want hash func model graphs to be equal, if they are isomorphic"


    def graphs_equal(self, g1, g2):
        return set(g1.nodes()) == set(g2.nodes()) and set(g1.edges()) == set(g2.edges())
        

class HashFuncModel:
    # imm_mnem_sets is an iterable of tuples [[(imm1, (mnem11, mnem12, ...), (imm2, (mnem21, mnem22)))], [(imm3, (mnem31, ...))]]
    # All imms sets in the same inner list MUST appear in the same hash function (with one of their allowed mnems)
    # All these sets show the allowed sets that we will check if one of appears in the function
    def __init__(self, hash_alg_name, imm_mnem_sets, graphs):
        self.hash_alg_name = hash_alg_name
        self.imm_mnem_sets = imm_mnem_sets
        self.graphs = graphs
        pass

class FuncHashFuncModelGraphIsomorphismCache():

    def __init__(self):
        self._cache = {}
        self._subgraph_isos_cache = {}


    def check_isomorphic(self, func, hash_func_model_graph):
        if self._check_cache(func, hash_func_model_graph):
            #print("Used cached result!")
            return self._get_cache(func, hash_func_model_graph)

        digraph_matcher = nx.algorithms.isomorphism.DiGraphMatcher(func.graph, hash_func_model_graph)
        is_isomorphic = digraph_matcher.subgraph_is_isomorphic()
        self._add_cache(func, hash_func_model_graph, is_isomorphic)
        if is_isomorphic:
            nodes_map = list(digraph_matcher.subgraph_isomorphisms_iter())
            self._add_subgraph_isos_cache(func, hash_func_model_graph, nodes_map)

        return is_isomorphic
            



    def _check_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        if func_addr_graph in self._cache:
            return True
        return False

    def _get_cache(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._cache, "{} not in cache, did you check with _check_cache first?".format(func_addr_graph)
        return self._cache[func_addr_graph]

    def _add_cache(self, func, hash_func_model_graph, is_isomorphic):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._cache, "{} already in cache, did you check with _check_cache first?".format(func_addr_graph)
        self._cache[func_addr_graph] = is_isomorphic
        assert self._check_cache(func, hash_func_model_graph), "Add cache failed"

    def get_subgraph_isos(self, func, hash_func_model_graph):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph in self._subgraph_isos_cache, "{} not in subgraph isomorphisms cache, did you check with check_isomorphic first?".format(func_addr_graph)
        return self._subgraph_isos_cache[func_addr_graph]

    def _add_subgraph_isos_cache(self, func, hash_func_model_graph, subgraph_isos):
        func_addr_graph = (func.addr, self._graph_to_tuples(hash_func_model_graph))
        assert func_addr_graph not in self._subgraph_isos_cache, "{} already in subgraph isomorphisms cache, did you check with _check_cache first?".format(func_addr_graph)
        self._subgraph_isos_cache[func_addr_graph] = subgraph_isos



    def _graph_to_tuples(self, graph):
        return (tuple(graph.nodes()), tuple(graph.edges()))

