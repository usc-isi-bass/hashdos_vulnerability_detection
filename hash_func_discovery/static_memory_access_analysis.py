import angr

def find_mem_accesses(proj, block):
    mem_accesses = []
    irsb = block.vex
    load_tmp_idxs = []
    stmts = list(irsb.statements)
    for i, stmt in enumerate(stmts):
        # This statement stores to memory
        if stmt.tag == 'Ist_Store':
            if stmt.addr.tag == 'Iex_RdTmp':
                # The store target is a tmp, search for its source
                srcs = find_tmp_src(stmts, i, stmt.addr.tmp)
                insn_addr = get_insn_addr(stmts, i)
                mem_access = MemWriteAccess(stmt, i, insn_addr, srcs)
                mem_accesses.append(mem_access)
            elif stmt.addr.tag == 'Iex_Const':
                # The store target is a const
                const = load_expr.addr
                src = MemLocConstSrc(stmt, i, const)
                insn_addr = get_insn_addr(stmts, i)
                mem_access = MemWriteAccess(stmt, i, insn_addr, [src])
                mem_accesses.append(mem_access)
            else:
                raise Exception('Logic Error: I assumed a Store statement\'s store location would be either a RdTmp or Const expression')
        # This statement (has an expression that) loads from memory
        # For all load expressions that read from a tmp
        for load_expr in filter(lambda expr: expr.tag == 'Iex_Load', stmt.expressions):
            if load_expr.addr.tag == 'Iex_RdTmp':
                # The load source is a tmp, search for its source
                srcs = find_tmp_src(stmts, i, load_expr.addr.tmp)
                insn_addr = get_insn_addr(stmts, i)
                mem_access = MemReadAccess(stmt, i, insn_addr, srcs)
                mem_accesses.append(mem_access)
            elif load_expr.addr.tag == 'Iex_Const':
                # The load source is a const
                const = load_expr.addr
                src = MemLocConstSrc(stmt, i, const)
                insn_addr = get_insn_addr(stmts, i)
                mem_access = MemReadAccess(stmt, i, insn_addr, [src])
                mem_accesses.append(mem_access)
            else:
                raise Exception('Logic error: I assumed a load expression\'s address would be either a RdTmp or a Const. But now I found one with tag: {}'.format(load_expr.addr.tag))
           
            
    return mem_accesses

def find_tmp_src(stmts, stmt_idx, tmp):
    tmp_srcs = []
    tracked_tmps = set([tmp])
    # Search for reg reads and mem loads before load:
    for i, stmt in enumerate(reversed(stmts[0:stmt_idx + 1])): # Do include stmt_idx
        # Stop when we reach the start of the instruction
        if stmt.tag == 'Ist_IMark':
            break
        if stmt.tag == 'Ist_WrTmp' and stmt.tmp in tracked_tmps:
            # If this statement reads from a tmp and writes to a tracked tmp, track the read-from tmp (remember, we're going backwards)
            for rdtmp_expr in filter(lambda expr: expr.tag == 'Iex_RdTmp', stmt.expressions):
                tracked_tmps.add(rdtmp_expr.tmp)

            # If we use a constant when writing to a tracked tmp, then this const is a src
            for const_expr in filter(lambda expr: expr.tag == 'Iex_Const', stmt.expressions):
                    const_stmt_i = stmt_idx - i
                    const = const_expr.con
                    src = TmpSrcConst(stmt, const_stmt_i, const, tracked_tmps)
                    tmp_srcs.append(src)

        # For the statements that read from registers, if it reads it writes to a tracked tmp, this is a dependent register
        for reg_rd_expr in filter(lambda expr: expr.tag == 'Iex_Get', stmt.expressions):
            assert stmt.tag == 'Ist_WrTmp', "Logic error: I assumed that when we have a Get expression, we'll write to a temp."
            # stmt.tmp is the tmp being written to for this write tmp statement
            if stmt.tmp in tracked_tmps:
                # The source of the tmp is a Get from a reg
                reg_rd_stmt_i = stmt_idx - i
                reg_offset = reg_rd_expr.offset
                src = TmpSrcReg(stmt, reg_rd_stmt_i, reg_offset, tracked_tmps)
                tmp_srcs.append(src)
        # For the statements that load from memory, if it loads from a constant, track this constant as the source for the tmp
        for load_expr in filter(lambda expr: expr.tag == 'Iex_Load', stmt.expressions):
            assert stmt.tag == 'Ist_WrTmp', "Logic error: I assumed that when we have a Load expression, we'll write to a temp."
            if stmt.tmp in tracked_tmps:
                if load_expr.addr.tag == 'Iex_RdTmp':
                    #raise Exception('Logic error: The source of our tmp, is a load from another tmp. I assumed this cannot happen because you cannot deref two levels in one insn')
                    pass # We haven't found the source yet, we're loading from a tmp
                elif load_expr.addr.tag == 'Iex_Const':
                    const_stmt_i = stmt_idx - i
                    const = load_expr.addr
                    src = TmpSrcLoadConst(stmt, const_stmt_i, const, tracked_tmps)
                    tmp_srcs.append(src)
                else:
                    raise Exception('Logic error: I assumed a load expression\'s address would be either a RdTmp or a Const. But now I found one with tag: {}'.format(load_expr.addr.tag))
    return tmp_srcs



def get_insn_addr(block_stmts, stmt_idx):
    for stmt in reversed(block_stmts[0:stmt_idx + 1]):
        if stmt.tag == 'Ist_IMark':
            return stmt.addr
    raise Exception("Could not find IMark in block before stmt idx: {}".format(stmt_idx))

class MemAccess:

    def __init__(self, access_type, stmt, stmt_i, insn_addr, mem_loc_srcs):
        self.access_type = access_type
        assert access_type == 'read' or access_type == 'write'
        self.stmt = stmt
        self.stmt_i = stmt_i
        self.insn_addr = insn_addr
        self.mem_loc_srcs = mem_loc_srcs

class MemReadAccess(MemAccess):

    def __init__(self, stmt, stmt_i, insn_addr, mem_loc_srcs):
        super().__init__('read', stmt, stmt_i, insn_addr, mem_loc_srcs)

class MemWriteAccess(MemAccess):

    def __init__(self, stmt, stmt_i, insn_addr, mem_loc_srcs):
        super().__init__('write', stmt, stmt_i, insn_addr, mem_loc_srcs)

class MemLocSrc:
    def __init__(self, stmt, stmt_i):
        self.stmt = stmt
        self.stmt_i = stmt_i

class MemLocConstSrc(MemLocSrc):

    def __init__(self, stmt, stmt_i, const):
        super().__init__(stmt, stmt_i)
        self.const = const

class TmpSrc(MemLocSrc):

    def __init__(self, stmt, stmt_i, tracked_tmps):
        super().__init__(stmt, stmt_i)
        self.tracked_tmps = tracked_tmps

class TmpSrcReg(TmpSrc):

    def __init__(self, stmt, stmt_i, reg_offset, tracked_tmps):
        super().__init__(stmt, stmt_i, tracked_tmps)
        self.reg_offset = reg_offset
 
class TmpSrcLoadConst(TmpSrc):

    def __init__(self, stmt, stmt_i, const, tracked_tmps):
        super().__init__(stmt, stmt_i, tracked_tmps)
        self.const = const

class TmpSrcConst(TmpSrc):

    def __init__(self, stmt, stmt_i, const, tracked_tmps):
        super().__init__(stmt, stmt_i, tracked_tmps)
        self.const = const  

    

class MemAccessViaReg:

    def __init__(self, load_stmt_i, reg_rd_stmt_i, reg_offset, insn_addr, tracked_tmps):
        self.load_stmt_i = load_stmt_i
        self.reg_rd_stmt_i = reg_rd_stmt_i
        self.reg_offset = reg_offset
        self.insn_addr = insn_addr
        self.tracked_tmps = tracked_tmps

