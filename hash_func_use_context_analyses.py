import angr
import claripy
import networkx as nx
import logging

l = logging.getLogger(name=__name__)
l.setLevel('DEBUG')

# The idea of this analysis is that if hash functions are used in hash tables, then the hash value is typically used to compute an index in the table.
# Therefore, we create a symbolic variable for the return value of the hash function and see if it's ever used in a memory read or write.
def analyze(elf_file, get_hash_funcs):
    result_dict = {}   
    result_dict['analysis_metrics'] = {}
    result_dict['analysis_metrics']['hit'] = False
    result_dict['mem_hash_deps'] = []

    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        cfg_fast = proj.analyses.CFGFast()
        for hash_func in get_hash_funcs(proj, cfg_fast, result_dict):
            
            for hash_func, hash_func_pred, hash_func_call_site, hash_func_ret_site in get_func_contexts(cfg_fast, hash_func): 
                l.debug("Hash func: {}".format(hash_func.name))
                l.debug("Calling func: {}".format(hash_func_pred.name))
                l.debug("Hash call site: 0x{:x}".format(hash_func_call_site))
                l.debug("Hash ret site: 0x{:x}".format(hash_func_ret_site))
                partial_results_dict = {
                    'hash_func': label_func(hash_func),
                    'hash_func_caller':  label_func(hash_func_pred), 
                    'callsite': fmt_addr(hash_func_call_site), 
                    'retsite': fmt_addr(hash_func_ret_site), 
                    'mem_read_hash_deps': None, 
                    'mem_write_hash_deps':None
                }
                result_dict['mem_hash_deps'].append(partial_results_dict)

                mem_read_hash_deps = []
                mem_write_hash_deps = []
                # A break point for memory reads. Flag if the address being read from depends on the hash return value.
                def mem_read_break(state):
                    read_addr = state.inspect.mem_read_address
                    if symbolic_addr_depends_on_varname(read_addr, 'hash_ret_val'):
                        mem_read_hash_deps.append(state.addr)
                        l.debug("Mem read: state Addr: 0x{:x} read addr: {}".format(state.addr, read_addr))
                # A break point for memory writes. Flag if the address being written to depends on the hash return value.
                def mem_write_break(state):
                    write_addr = state.inspect.mem_write_address
                    if symbolic_addr_depends_on_varname(write_addr, 'hash_ret_val'):
                        mem_write_hash_deps.append(state.addr)
                        l.debug("Mem write: state Addr: 0x{:x} read addr: {}".format(state.addr, write_addr))

                return_state = proj.factory.blank_state(addr=hash_func_ret_site)
                return_state.inspect.b('mem_read', when=angr.BP_BEFORE, action=mem_read_break)
                return_state.inspect.b('mem_write', when=angr.BP_BEFORE, action=mem_write_break)
                hash_return_val = claripy.BVS('hash_ret_val', size=proj.arch.bits)
                #return_state.regs.rax = hash_return_val
                set_state_ret_reg(proj, return_state, hash_return_val)
                simgr = proj.factory.simulation_manager(return_state)
                #def stop_condition(simgr):
                #    return discovered_hash_dep_load[0]
                #simgr.run(until=stop_condition)
                for i in range(10):
                    l.debug(simgr.active)
                    if len(simgr.active) <= 0:
                        break
                    simgr.step()
                partial_results_dict['mem_read_hash_deps'] = [fmt_addr(addr) for addr in mem_read_hash_deps]
                partial_results_dict['mem_write_hash_deps'] = [fmt_addr(addr) for addr in mem_write_hash_deps]
                if len(mem_read_hash_deps) > 0 or len(mem_write_hash_deps) > 0:
                    result_dict['analysis_metrics']['hit'] = True
    except Exception as e:
        #raise e
        l.debug("Exception: {}".format(str(e)))
        add_error(result_dict, str(e))
    return result_dict

# Returns a set of tuples, each containing (called_func, calling_func, called_func_call_site, called_func_ret_site)
# calling_func is the function calling called_func
# called_func_call_site is the call site of called_func in calling_func
# called_func_ret_site is the site to which the call_site returns
def get_func_contexts(cfg, called_func):
    contexts = set()
    callgraph = cfg.functions.callgraph
    called_func_addr = called_func.addr
    called_func_pred_addrs = callgraph.predecessors(called_func_addr)
    for called_func_pred_addr in called_func_pred_addrs:            
        called_func_pred_node = cfg.model.get_any_node(called_func_pred_addr)
        called_func_pred_func_addr = called_func_pred_node.function_address
        calling_func = cfg.functions.function(called_func_pred_func_addr)
        if calling_func is None:
            l.error("Could not find calling function of called function {} at address 0x{:x}".format(called_func.name, func_pred_addr))
            continue
            
        # Find the return sites of the called function
        called_func_call_sites = get_call_sites_for(calling_func, called_func)
        for called_func_call_site in called_func_call_sites:
            called_func_ret_site = calling_func.get_call_return(called_func_call_site)
            contexts.add((called_func, calling_func, called_func_call_site, called_func_ret_site))
    return contexts
 

# Determines if a symbolic address addr depends on the variable with var_name
def symbolic_addr_depends_on_varname(addr, var_name):
    if isinstance(addr, int):
        return False
    for addr_dep_variable_name in addr.variables:
        if var_name in addr_dep_variable_name:
            return True
    return False


def get_call_sites_for(caller_func, callee_func):
    call_sites = []
    for call_site in caller_func.get_call_sites():
        call_target = caller_func.get_call_target(call_site)
        if call_target == callee_func.addr:
            call_sites.append(call_site)
    return call_sites

# Return a set of tuples (block_addr, stmt_idx) that point to load VEX statements
def get_func_load_stmts(func):
    load_stmts = set()
    for block in func.blocks:
        block_vex = block.vex
        for i, stmt in enumerate(block_vex.statements):
            if stmt.tag == 'Iex_Load' or any(expr.tag == 'Iex_Load' for expr in stmt.expressions):
                load_stmts.add((block.addr, i))
    return load_stmts

# Sets the register that is used for return values to val
def set_state_ret_reg(proj, state, val):
    bits = proj.arch.bits
    if bits == 32:
        state.regs.eax = val
    elif bits == 64:
        state.regs.rax = val
    else:
        raise Exception("I don't know what the return register is for {} bits".format(bits))

def add_error(result_dict, err_msg):
    if 'err' in result_dict:
        result_dict['err'].append(err_msg)
    else:
        result_dict['err'] = [err_msg]

# Creates a label for a function name@address
def label_func(func):
    return "{}@{}".format(func.name, fmt_addr(func.addr))

def fmt_addr(addr):
    return "0x{:x}".format(addr)
