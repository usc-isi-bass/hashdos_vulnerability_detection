import angr
import claripy
import networkx as nx
import logging

l = logging.getLogger(name=__name__)
l.setLevel('DEBUG')

# The idea of this analysis is that if hash functions are used in hash tables, then the hash value is typically used to compute an index in the table.
# Therefore, we create a symbolic variable for the return value of the hash function and see if it's ever used in a memory read or write.
def analyze(elf_file, get_hash_funcs):
    result_dict = {}   
    result_dict['analysis_metrics'] = {}
    result_dict['analysis_metrics']['hit'] = False
    result_dict['mem_hash_deps'] = []

    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        cfg_fast = proj.analyses.CFGFast()
        callgraph = cfg_fast.functions.callgraph
        for hash_func in get_hash_funcs(proj, cfg_fast, result_dict):
            l.debug("Hash func: {}".format(hash_func.name))
            
            hash_addr = hash_func.addr
            # Create a set of functions that call the hash function
            hash_func_preds = set()
            hash_predecessor_addrs = callgraph.predecessors(hash_addr)
            for hash_pred_addr in hash_predecessor_addrs:            
                hash_pred_node = cfg_fast.model.get_any_node(hash_pred_addr)
                hash_func_pred_addr = hash_pred_node.function_address
                hash_func_pred = cfg_fast.functions.function(hash_func_pred_addr)
                if hash_func_pred is None:
                    err_msg = "Could not find the hash_func caller at addr: 0x{:x}".format(hash_func_pred_addr)
                    add_error(result_dict, err_msg)
                    
                hash_func_preds.add(hash_func_pred)
            for hash_func_pred in hash_func_preds:
                l.debug("Hash calling func: {}".format(hash_func_pred.name))
                # Get all the load statements in the calling function
                #load_stmts = get_func_load_stmts(hash_func_pred)

                
                # Find the return sites of the hash function
                hash_func_call_sites = get_call_sites_for(hash_func_pred, hash_func)
                for hash_func_call_site in hash_func_call_sites:
                    partial_results_dict = {
                        'hash_func': label_func(hash_func),
                        'hash_func_caller':  label_func(hash_func_pred), 
                        'callsite': fmt_addr(hash_func_call_site), 
                        'retsite': None, 
                        'mem_read_hash_deps': None, 
                        'mem_write_hash_deps':None
                    }
                    result_dict['mem_hash_deps'].append(partial_results_dict)
                    hash_func_ret_site = hash_func_pred.get_call_return(hash_func_call_site)
                    partial_results_dict['retsite'] = fmt_addr(hash_func_ret_site)
                    l.debug("Hash ret site: 0x{:x}".format(hash_func_ret_site))

                    mem_read_hash_deps = []
                    mem_write_hash_deps = []
                    # A break point for memory reads. Flag if the address being read from depends on the hash return value.
                    def mem_read_break(state):
                        read_addr = state.inspect.mem_read_address
                        if symbolic_addr_depends_on_varname(read_addr, 'hash_ret_val'):
                            mem_read_hash_deps.append(state.addr)
                            l.debug("Mem read: state Addr: 0x{:x} read addr: {}".format(state.addr, read_addr))
                    # A break point for memory writes. Flag if the address being written to depends on the hash return value.
                    def mem_write_break(state):
                        write_addr = state.inspect.mem_write_address
                        if symbolic_addr_depends_on_varname(write_addr, 'hash_ret_val'):
                            mem_write_hash_deps.append(state.addr)
                            l.debug("Mem write: state Addr: 0x{:x} read addr: {}".format(state.addr, write_addr))

                    return_state = proj.factory.blank_state(addr=hash_func_ret_site)
                    return_state.inspect.b('mem_read', when=angr.BP_BEFORE, action=mem_read_break)
                    return_state.inspect.b('mem_write', when=angr.BP_BEFORE, action=mem_write_break)
                    hash_return_val = claripy.BVS('hash_ret_val', size=proj.arch.bits)
                    #return_state.regs.rax = hash_return_val
                    set_state_ret_reg(proj, return_state, hash_return_val)
                    simgr = proj.factory.simulation_manager(return_state)
                    #def stop_condition(simgr):
                    #    return discovered_hash_dep_load[0]
                    #simgr.run(until=stop_condition)
                    for i in range(10):
                        l.debug(simgr.active)
                        if len(simgr.active) <= 0:
                            break
                        simgr.step()
                    partial_results_dict['mem_read_hash_deps'] = [fmt_addr(addr) for addr in mem_read_hash_deps]
                    partial_results_dict['mem_write_hash_deps'] = [fmt_addr(addr) for addr in mem_write_hash_deps]
                    if len(mem_read_hash_deps) > 0 or len(mem_write_hash_deps) > 0:
                        result_dict['analysis_metrics']['hit'] = True
    except Exception as e:
        #raise e
        l.debug("Exception: {}".format(str(e)))
        add_error(result_dict, str(e))
    return result_dict

# Determines if a symbolic address addr depends on the variable with var_name
def symbolic_addr_depends_on_varname(addr, var_name):
    if isinstance(addr, int):
        return False
    for addr_dep_variable_name in addr.variables:
        if var_name in addr_dep_variable_name:
            return True
    return False


def get_call_sites_for(caller_func, callee_func):
    call_sites = []
    for call_site in caller_func.get_call_sites():
        call_target = caller_func.get_call_target(call_site)
        if call_target == callee_func.addr:
            call_sites.append(call_site)
    return call_sites

# Return a set of tuples (block_addr, stmt_idx) that point to load VEX statements
def get_func_load_stmts(func):
    load_stmts = set()
    for block in func.blocks:
        block_vex = block.vex
        for i, stmt in enumerate(block_vex.statements):
            if stmt.tag == 'Iex_Load' or any(expr.tag == 'Iex_Load' for expr in stmt.expressions):
                load_stmts.add((block.addr, i))
    return load_stmts

# Sets the register that is used for return values to val
def set_state_ret_reg(proj, state, val):
    bits = proj.arch.bits
    if bits == 32:
        state.regs.eax = val
    elif bits == 64:
        state.regs.rax = val
    else:
        raise Exception("I don't know what the return register is for {} bits".format(bits))

def add_error(result_dict, err_msg):
    if 'err' in result_dict:
        result_dict['err'].append(err_msg)
    else:
        result_dict['err'] = [err_msg]

# Creates a label for a function name@address
def label_func(func):
    return "{}@{}".format(func.name, fmt_addr(func.addr))

def fmt_addr(addr):
    return "0x{:x}".format(addr)
