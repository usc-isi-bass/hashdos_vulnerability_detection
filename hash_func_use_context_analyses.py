import angr
import claripy
import networkx as nx
import logging
import ipdb
import pickle
import base64

l = logging.getLogger(name=__name__)
l.setLevel('DEBUG')

# The idea of this analysis is that if hash functions are used in hash tables, then the hash value is typically used to compute an index in the table.
# Therefore, we create a symbolic variable for the return value of the hash function and see if it's ever used in a memory read or write.
def analyze(elf_file, get_hash_funcs):
    result_dict = {}
    result_dict['analysis_metrics'] = {}
    result_dict['analysis_metrics']['hit'] = False
    result_dict['mem_hash_deps'] = []

    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        cfg_fast = proj.analyses.CFGFast()
        for hash_func in get_hash_funcs(proj, cfg_fast, result_dict):

            for hash_func, hash_func_pred, hash_func_call_site, hash_func_ret_site in get_func_contexts(cfg_fast, hash_func):
                l.debug("Hash func: {}".format(hash_func.name))
                l.debug("Calling func: {}".format(hash_func_pred.name))
                l.debug("Hash call site: 0x{:x}".format(hash_func_call_site))
                l.debug("Hash ret site: 0x{:x}".format(hash_func_ret_site))
                partial_results_dict = {
                    'hash_func': label_func(hash_func),
                    'hash_func_caller':  label_func(hash_func_pred),
                    'callsite': fmt_addr(hash_func_call_site),
                    'retsite': fmt_addr(hash_func_ret_site),
                    'callsite_constraints': None,
                    'mem_read_hash_deps': None,
                    'mem_write_hash_deps':None,
                    'file_seek_hash_deps':None
                }
                result_dict['mem_hash_deps'].append(partial_results_dict)

                hash_func_call_site_constraints = analyze_hash_func_call_pred(proj, hash_func_pred, hash_func, hash_func_call_site, 100)
                partial_results_dict['callsite_constraints'] = hash_func_call_site_constraints


                mem_read_hash_deps, mem_write_hash_deps, file_seek_hash_deps = analyze_hash_func_return_value_usage(proj, cfg_fast, hash_func_ret_site, 10)
                partial_results_dict['mem_read_hash_deps'] = [fmt_addr(addr) for addr in mem_read_hash_deps]
                partial_results_dict['mem_write_hash_deps'] = [fmt_addr(addr) for addr in mem_write_hash_deps]
                partial_results_dict['file_seek_hash_deps'] = [fmt_addr(addr) for addr in file_seek_hash_deps]
                if len(mem_read_hash_deps) > 0 or len(mem_write_hash_deps) or len(file_seek_hash_deps) > 0:
                    result_dict['analysis_metrics']['hit'] = True
    except Exception as e:
        #raise e
        l.debug("Exception: {}".format(str(e)))
        add_error(result_dict, str(e))
    return result_dict

def analyze_hash_func_call_pred(proj, hash_func_pred, hash_func, hash_func_call_site, num_block_upperbound):
    hash_func_call_site_constraints = []
    # We create 4 symbolic variables for the arguments passed to the calling function (hash_func_pred)
    # Note that 4 is chosen arbitrarily
    # We give each symbolic variable a size as if it was a address, but there's no reason why this should be the case.
    # TODO can we get a better idea of how many and what type of arugments the calling function takes?
    calling_func_args_name_base = "{}_arg_".format(hash_func_pred.name)
    arg1 = claripy.BVS(name="{}{}".format(calling_func_args_name_base, 1), size=proj.arch.bits)
    arg2 = claripy.BVS(name="{}{}".format(calling_func_args_name_base, 2), size=proj.arch.bits)
    arg3 = claripy.BVS(name="{}{}".format(calling_func_args_name_base, 3), size=proj.arch.bits)
    arg4 = claripy.BVS(name="{}{}".format(calling_func_args_name_base, 4), size=proj.arch.bits)
    start_state = proj.factory.call_state(hash_func_pred.addr, arg1, arg2, arg3, arg4)
    def call_break(state):
        func_addr = state.inspect.function_address
        func_addr_int = None
        if isinstance(func_addr, int):
            func_addr_int = func_addr
        if isinstance(func_addr, claripy.ast.bv.BV):
            func_addr_int = state.solver.eval(func_addr)
        if func_addr_int is not None and func_addr_int == hash_func.addr:
            #hash_func_call_site_constraints.append((str(state.solver.constraints), base64.encodebytes(pickle.dumps(state)).decode('utf-8').strip()))
            hash_func_call_site_constraints.append((str(state.solver.constraints), base64.encodebytes(pickle.dumps(state.solver.constraints)).decode('utf-8').strip()))

    start_state.inspect.b('call', when=angr.BP_BEFORE, action=call_break)
    simgr = proj.factory.simulation_manager(start_state)
    for i in range(num_block_upperbound):
        l.debug(simgr.active)
        if len(simgr.active) <= 0:
            break
        # We really don't want to be symbolically executing the hash function
        for state in simgr.active:
            if state.addr == hash_func.addr:
                simgr.move(from_stash='active', to_stash='hash_func_start', filter_func=lambda s : s == state)

        simgr.step()

    return hash_func_call_site_constraints






def analyze_hash_func_return_value_usage(proj, cfg, hash_func_ret_site, num_block_upperbound):
    mem_read_hash_deps = []
    mem_write_hash_deps = []
    file_seek_hash_deps = []
    # A break point for memory reads. Flag if the address being read from depends on the hash return value.
    def mem_read_break(state):
        read_addr = state.inspect.mem_read_address
        if symbolic_var_depends_on_varname(read_addr, 'hash_ret_val'):
            mem_read_hash_deps.append(state.addr)
            l.debug("Mem read: state Addr: 0x{:x} read addr: {}".format(state.addr, read_addr))
    # A break point for memory writes. Flag if the address being written to depends on the hash return value.
    def mem_write_break(state):
        write_addr = state.inspect.mem_write_address
        if symbolic_var_depends_on_varname(write_addr, 'hash_ret_val'):
            mem_write_hash_deps.append(state.addr)
            l.debug("Mem write: state Addr: 0x{:x} read addr: {}".format(state.addr, write_addr))

    class FseekHook(angr.SimProcedure):
        def run(self, stream, offset, origin):
            if symbolic_var_depends_on_varname(offset, 'hash_ret_val'):
                # state.addr is in the library the predecessor is in the PLT and the next predecessor is the call site we want
                l.debug(list(self.state.history.lineage))
                call_site = list(self.state.history.lineage)[-3]
                l.debug("Fseek: state Addr: 0x{:x} offset: {}".format(call_site.addr, offset))
                file_seek_hash_deps.append(call_site.addr)
    class LseekHook(angr.SimProcedure):
        def run(self, fd, offset, whence):
            if symbolic_var_depends_on_varname(offset, 'hash_ret_val'):
                # state.addr is in the library the predecessor is in the PLT and the next predecessor is the call site we want
                l.debug(list(self.state.history.lineage))
                call_site = list(self.state.history.lineage)[-3]
                l.debug("Lseek: state Addr: 0x{:x} offset: {}".format(call_site.addr, offset))
                file_seek_hash_deps.append(call_site.addr)




    return_state = proj.factory.blank_state(addr=hash_func_ret_site)
    return_state.inspect.b('mem_read', when=angr.BP_BEFORE, action=mem_read_break)
    return_state.inspect.b('mem_write', when=angr.BP_BEFORE, action=mem_write_break)
    #return_state.inspect.b('call', when=angr.BP_BEFORE, action=call_break)
    proj.hook_symbol('fseek', FseekHook())
    proj.hook_symbol('lseek', LseekHook())
    hash_return_val = claripy.BVS('hash_ret_val', size=proj.arch.bits)
    #return_state.regs.rax = hash_return_val
    set_state_ret_reg(proj, return_state, hash_return_val)
    simgr = proj.factory.simulation_manager(return_state)
    #def stop_condition(simgr):
    #    return discovered_hash_dep_load[0]
    #simgr.run(until=stop_condition)
    for i in range(num_block_upperbound):
        l.debug(simgr.active)
        if len(simgr.active) <= 0:
            break
        simgr.step()
    proj.unhook_symbol('fseek')
    proj.unhook_symbol('lseek')
    return mem_read_hash_deps, mem_write_hash_deps, file_seek_hash_deps


# Returns a set of tuples, each containing (called_func, calling_func, called_func_call_site, called_func_ret_site)
# calling_func is the function calling called_func
# called_func_call_site is the call site of called_func in calling_func
# called_func_ret_site is the site to which the call_site returns
def get_func_contexts(cfg, called_func):
    contexts = set()
    callgraph = cfg.functions.callgraph
    called_func_addr = called_func.addr
    called_func_pred_addrs = callgraph.predecessors(called_func_addr)
    for called_func_pred_addr in called_func_pred_addrs:
        called_func_pred_node = cfg.model.get_any_node(called_func_pred_addr)
        called_func_pred_func_addr = called_func_pred_node.function_address
        calling_func = cfg.functions.function(called_func_pred_func_addr)
        if calling_func is None:
            l.error("Could not find calling function of called function {} at address 0x{:x}".format(called_func.name, func_pred_addr))
            continue

        # Find the return sites of the called function
        called_func_call_sites = get_call_sites_for(calling_func, called_func)
        for called_func_call_site in called_func_call_sites:
            called_func_ret_site = calling_func.get_call_return(called_func_call_site)
            contexts.add((called_func, calling_func, called_func_call_site, called_func_ret_site))
    return contexts


# Determines if a symbolic variable depends on the variable with var_name
def symbolic_var_depends_on_varname(symvar, var_name):
    if isinstance(symvar, int):
        return False
    for symvar_dep_variable_name in symvar.variables:
        if var_name in symvar_dep_variable_name:
            return True
    return False


# Finds the call sites in caller_func to the function callee_func
def get_call_sites_for(caller_func, callee_func):
    call_sites = []
    for call_site in caller_func.get_call_sites():
        call_target = caller_func.get_call_target(call_site)
        if call_target == callee_func.addr:
            call_sites.append(call_site)
    return call_sites

# Return a set of tuples (block_addr, stmt_idx) that point to load VEX statements
def get_func_load_stmts(func):
    load_stmts = set()
    for block in func.blocks:
        block_vex = block.vex
        for i, stmt in enumerate(block_vex.statements):
            if stmt.tag == 'Iex_Load' or any(expr.tag == 'Iex_Load' for expr in stmt.expressions):
                load_stmts.add((block.addr, i))
    return load_stmts

# Sets the register that is used for return values to val
def set_state_ret_reg(proj, state, val):
    bits = proj.arch.bits
    if bits == 32:
        state.regs.eax = val
    elif bits == 64:
        state.regs.rax = val
    else:
        raise Exception("I don't know what the return register is for {} bits".format(bits))

def add_error(result_dict, err_msg):
    if 'err' in result_dict:
        result_dict['err'].append(err_msg)
    else:
        result_dict['err'] = [err_msg]

# Creates a label for a function name@address
def label_func(func):
    return "{}@{}".format(func.name, fmt_addr(func.addr))

def fmt_addr(addr):
    return "0x{:x}".format(addr)
