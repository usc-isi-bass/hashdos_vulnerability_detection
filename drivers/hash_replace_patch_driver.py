import os
import sys
import time
import datetime
import argparse
import angr
import logging
import binascii
import re

# Because apparently python only adds the parent directory of the running script to the PATH.
# We want the parent of the parent to be added, because that's where input_dependence ans hash_table_discovery is
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from hash_patcher.static_patcher import StaticPatcher
from hash_patcher.interfunc_code_cave_miner import InterFuncCodeCaveMiner
from hash_patcher.code_cave_graph_patch_creator import CodeCaveGraphPatchCreator
from hash_patcher.patch_writer import PatchWriter
from hash_patcher.hash_patch_asm_generator import HashPatchAsmGenerator


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--elf_file', help='the elf file to patch', required=True)
    parser.add_argument('--patch_target', help='the name of the hash function to replace', required=True)
    parser.add_argument('--asm_file', help='the file containing the assembly patch code', required=True)
    args = parser.parse_args()
    elf_file_name = args.elf_file
    patch_asm_file = args.asm_file
    patch_target_func_name = args.patch_target
    #print(patch_target_addr)


    #print("Elf file: {}".format(elf_file_name))
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    if proj.arch.bits != 64:
        print("We only do 64-bit at the moment, not {}-bit".format(proj.arch.bits))
        return
    cfg_fast = proj.analyses.CFGFast()
    patch_target_func = cfg_fast.functions.function(name=patch_target_func_name)
    if patch_target_func is None:
        raise Exception("Could not find function: {}".format(patch_target_func_name))
    
    hash_patch_asm_generator = HashPatchAsmGenerator(proj, patch_asm_file, len_in_reg=None)
    #hash_patch_asm_code = extract_asm_code(patch_asm_file)
    hash_patch_asm_code = hash_patch_asm_generator.get_asm_code()
    patcher = StaticPatcher(elf_file_name)
    print("Patchability:")
    print(patcher._ifccm._extract_metrics())
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patched_elf_name = elf_file_name + "_patched"
    patcher.apply_patches(patched_elf_name)


def extract_asm_code(file_name):
    asm_code = []
    with open(file_name, 'r') as fd:
        for line in fd:
            line = line.strip()
            # Lines starting with ; or # are treated as comments
            if re.match(r'\s*[;#]', line):
                continue
            asm_code.append(line)
    return asm_code
 

if __name__ == "__main__":
    main()


