import os
import sys
import time
import datetime
import argparse
import angr
import logging
import binascii
import re

# Because apparently python only adds the parent directory of the running script to the PATH.
# We want the parent of the parent to be added, because that's where input_dependence ans hash_table_discovery is
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from hash_patcher.static_patcher import StaticPatcher
from hash_patcher.interfunc_code_cave_miner import InterFuncCodeCaveMiner
from hash_patcher.code_cave_graph_patch_creator import CodeCaveGraphPatchCreator
from hash_patcher.patch_writer import PatchWriter
from hash_patcher.hash_patch_asm_generator import HashPatchAsmGenerator


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--elf_file', help='the elf file to patch', required=True)
    parser.add_argument('--asm_file', help='the file containing the assembly patch code', required=True)
    parser.add_argument('--patch_target', help='the name of the hash function to replace', required=False)
    parser.add_argument('--buf_in_reg', help='the register the buffer is passed in', required=False)
    parser.add_argument('--len_in_reg', help='the register the buffer length is passed in', required=False)
    parser.add_argument('--out_mod', help='the MOD that should be applied to the output', type=int, default=None, required=False)
    parser.add_argument('--patch_call_sites', help='should we patch the call sites', type=bool, default=False, required=False)
    parser.add_argument('--patch_orig_func', help='should we overwrite the original function with the patch', type=bool, default=True, required=False)
    parser.add_argument('--scenario', choices=['bip', 'sn'], help='automatically set settings for a target binary', required=False)
    args = parser.parse_args()
    elf_file_name = args.elf_file
    patch_asm_file = args.asm_file

    if args.scenario == 'bip':
        patch_target_func_name = 'hash_func'
        buf_in_reg = 'rdi'
        len_in_reg = None
        out_mod = 256
        patch_call_sites = False
        patch_orig_func = True
    elif args.scenario == 'sn':
        patch_target_func_name = 'dhhash'
        buf_in_reg = 'rdi'
        len_in_reg = None
        out_mod = 10240
        patch_call_sites = False
        patch_orig_func = True
    else:

        patch_target_func_name = args.patch_target

        buf_in_reg = args.buf_in_reg
        len_in_reg = args.len_in_reg
        out_mod = args.out_mod
        patch_call_sites = args.patch_call_sites
        patch_orig_func = args.patch_orig_func
        if buf_in_reg == 'None':
            buf_in_reg = None
        if len_in_reg == 'None':
            len_in_reg = None
        if out_mod == 'None':
            out_mod = None
        #print(patch_target_addr)


    #print("Elf file: {}".format(elf_file_name))
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    if proj.arch.bits != 64:
        print("We only do 64-bit at the moment, not {}-bit".format(proj.arch.bits))
        return
    cfg_fast = proj.analyses.CFGFast()
    patch_target_func = cfg_fast.functions.function(name=patch_target_func_name)
    if patch_target_func is None:
        raise Exception("Could not find function: {}".format(patch_target_func_name))
    
    hash_patch_asm_generator = HashPatchAsmGenerator(proj, patch_asm_file, len_in_reg=len_in_reg, out_mod=out_mod)
    #hash_patch_asm_code = extract_asm_code(patch_asm_file)
    hash_patch_asm_code = hash_patch_asm_generator.get_asm_code()
    patcher = StaticPatcher(elf_file_name)
    print("Patchability:")
    print(patcher._ifccm._extract_metrics())
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code, patch_call_sites=patch_call_sites, patch_orig_func=patch_orig_func)
    patched_elf_name = elf_file_name + "_patched"
    patcher.apply_patches(patched_elf_name)


def extract_asm_code(file_name):
    asm_code = []
    with open(file_name, 'r') as fd:
        for line in fd:
            line = line.strip()
            # Lines starting with ; or # are treated as comments
            if re.match(r'\s*[;#]', line):
                continue
            asm_code.append(line)
    return asm_code
 

if __name__ == "__main__":
    main()


