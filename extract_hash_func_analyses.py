import angr
import claripy
import networkx as nx
import logging
import ipdb
import pickle
import base64
import pyvex

l = logging.getLogger(name=__name__)
l.setLevel('DEBUG')

# We just want to extract the capstone and VEX code of the hash function
def analyze(elf_file, get_hash_funcs):
    result_dict = {}
    result_dict['analysis_metrics'] = {}
    result_dict['analysis_metrics']['hit'] = False
    result_dict['hash_func_code'] = []

    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        cfg_fast = proj.analyses.CFGFast()
        for hash_func in get_hash_funcs(proj, cfg_fast, result_dict):
            result_dict['hash_func_code'].append({
                'hash_func': label_func(hash_func),
                'hash_func_code':get_func_code_str(proj, cfg_fast, hash_func)
            })
    
        result_dict['analysis_metrics']['hit'] = True
    except Exception as e:
        #raise e
        l.debug("Exception: {}".format(str(e)))
        add_error(result_dict, str(e))
    return result_dict






# FROM: https://github.com/usc-isi-bass/angr_scripts/blob/master/scripts/print_vex.py
def get_func_code_str(proj, cfg, func):
    func_code_str = ""
    func_call_sites = func.get_call_sites()
    func_code_str += "FUNCTION: {}\n".format(func.name)
    block_label = "[{}]".format(func.name)
    blocks = func.blocks
    blocks_sorted = sorted(blocks, key=lambda block: block.addr, reverse=False)
    for block in blocks_sorted:
        block_addr = block.addr
        block_node = cfg.model.get_any_node(addr=block_addr)
        block_exit_str = ""
        if (block_addr in func_call_sites):
            call_target = func.get_call_target(block_addr)
            target_func = cfg.functions.function(addr=call_target)
            if target_func is None:
                target_func_name = "(missing)@0x{:x}".format(call_target)
            else:
                target_func_name = target_func.name
            block_exit_str = "[exit to: {}]".format(target_func_name)
            
        func_code_str += "\t{}\n".format(block_label)
        func_code_str += "\t{} BLOCK: 0x{:x} {}\n".format(block_label, block_addr, block_exit_str)
        irsb = block.vex
        block_str = str(block.capstone)
        block_str = "\t{} ".format(block_label) + block_str.replace("\n", "\n\t{} ".format(block_label))
        func_code_str += block_str + "\n"

        func_code_str += "\t{} IRSB:\n".format(block_label)
        for i, stmt in enumerate(irsb.statements):
            stmt_label = "0x{:x}[{:03}]".format(block_addr, i)
            stmt_str = stmt.__str__()
            offset_str = ""
            if isinstance(stmt, pyvex.stmt.Put):
                stmt_str = stmt.__str__(reg_name=proj.arch.translate_register_name(stmt.offset))
                offset_str = "(offset={})".format(str(stmt.offset))
            elif isinstance(stmt, pyvex.stmt.WrTmp) and isinstance(stmt.data, pyvex.expr.Get):
                stmt_str = stmt.__str__(reg_name=proj.arch.translate_register_name(stmt.data.offset))
                offset_str = "(offset={})".format(str(stmt.data.offset))
            elif isinstance(stmt, pyvex.stmt.Exit):
                stmt_str = stmt.__str__(reg_name=proj.arch.translate_register_name(stmt.offsIP))
                offset_str = "(offset={})".format(str(stmt.offsIP))
            else:
                stmt_str = stmt.__str__()
            stmt_str = "{} {}".format(stmt_str, offset_str)
            stmt_color = stmt_str
            
            func_code_str += "\t{} {} : {}\n".format(block_label, stmt_label, stmt_color)
    return func_code_str

def add_error(result_dict, err_msg):
    if 'err' in result_dict:
        result_dict['err'].append(err_msg)
    else:
        result_dict['err'] = [err_msg]

# Creates a label for a function name@address
def label_func(func):
    return "{}@{}".format(func.name, fmt_addr(func.addr))

def fmt_addr(addr):
    return "0x{:x}".format(addr)
