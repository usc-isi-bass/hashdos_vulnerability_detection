
# Returns the call sites calling to the function at target_func_addr
def get_call_sites_to(cfg, target_func_addr):
    call_sites = []
    if not target_func_addr in cfg.functions:
        raise Exception("Could not find a function with addr 0x{:x} in CFG".format(target_func_addr))
    target_func = cfg.functions[target_func_addr]
    target_func_node = cfg.model.get_any_node(addr=target_func_addr)

    for call_site_node in target_func_node.predecessors:
        caller_func = cfg.functions.function(call_site_node.function_address)
        call_site_addr = call_site_node.addr
        # Sometimes there are weird jumps
        if call_site_addr in caller_func.get_call_sites():
            assert caller_func.get_call_target(call_site_addr) == target_func_addr
            call_sites.append(call_site_addr)
    return call_sites

# Finds the call sites in caller_func to the function callee_func
def get_func_call_sites_for(caller_func, callee_func):
    call_sites = []
    for call_site in caller_func.get_call_sites():
        call_target = caller_func.get_call_target(call_site)
        if call_target == callee_func.addr:
            call_sites.append(call_site)
    return call_sites

# Determines if a symbolic variable depends on the variable with var_name
def symbolic_var_depends_on_varname(symvar, var_name):
    if isinstance(symvar, int):
        return False
    for symvar_dep_variable_name in symvar.variables:
        if var_name in symvar_dep_variable_name:
            return True
    return False

# Sets the register that is used for return values to val
def set_state_ret_reg(proj, state, val):
    bits = proj.arch.bits
    if bits == 32:
        state.regs.eax = val
    elif bits == 64:
        state.regs.rax = val
    else:
        raise Exception("I don't know what the return register is for {} bits".format(bits))

# Gets the call instruction from the call site at address call_site_addr
def get_call_insn(cfg, call_site_addr):
    call_site_node = cfg.model.get_any_node(addr=call_site_addr)
    call_site_block = call_site_node.block
    call_insn_addr = call_site_block.instruction_addrs[-1]
    call_insn = None
    for insn in call_site_block.capstone.insns:
        if insn.address == call_insn_addr:
            call_insn = insn
    if call_insn is None:
        raise Exception("Could not find the call instruction in block 0x{:x}".format(call_site))
    if not call_insn.mnemonic == 'call':
        raise Exception("Not a call instruction: {}".format(call_insn))
    return call_insn
