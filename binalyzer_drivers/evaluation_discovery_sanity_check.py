#! /usr/bin/env python3
import argparse
import csv
import jsonpickle
import logging
import os
import subprocess
import sys
import tempfile

# Because apparently python only adds the parent directory of the running
# script to the PATH.
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__),
                                                '..')))

from binalyzer.analyzers.parallel_analyzer import ParallelAnalyzer  # noqa: E402, E501
from analyses.hash_func_discovery.hash_func_discovery_analysis import HashFuncDiscoveryAnalysis  # noqa: E402, E501

logging.getLogger('angr').setLevel(logging.CRITICAL)
logging.getLogger('cle').setLevel(logging.CRITICAL)
logging.getLogger('claripy').setLevel(logging.CRITICAL)
logging.getLogger('claripy.balancer').setLevel(logging.CRITICAL)
logging.getLogger('pyvex').setLevel(logging.CRITICAL)
logging.getLogger('pyvex.lifting.libvex').setLevel(logging.CRITICAL)
logging.getLogger('archinfo.arch').setLevel(logging.CRITICAL)

elf_file_location = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                 '..',
                                 'test_binaries')

parser = argparse.ArgumentParser(
    description='Build and test a set of binaries.')
parser.add_argument('--csv-in', action='store', metavar='FILE',
                    required=True, help='CSV listing soruce and options')
parser.add_argument('--source', action='store', metavar='DIRECTORY',
                    required=True, help='Location of .c files to compile')
parser.add_argument('--cutoff', action='store', metavar='N', default=80,
                    help='Percent confidence cutoff')


def main():
    args = parser.parse_args()

    print('Setting up test directories...')
    tempdir = tempfile.mkdtemp(prefix='test')
    results_path = os.path.join(tempdir, 'results.txt')
    programs_path = os.path.join(tempdir, 'sources')
    list_file = os.path.join(tempdir, 'elf_list_file.txt')
    os.mkdir(programs_path)

    print('Building programs...')
    with open(args.csv_in, newline='') as csvfile:
        csv_reader = csv.DictReader(csvfile, delimiter=',')
        line_count = 0
        for entry in csv_reader:
            if line_count != 0:
                # Generate output file name as source_compiler_flag
                filename = os.path.join(programs_path, '{}_{}_{}'.format(
                    entry['source'][:-2],
                    entry['compiler'],
                    entry['flag']))
                # Run the compiler on the source file and generate
                subprocess.run([entry['compiler'],
                                os.path.join(args.source, entry['source']),
                                entry['flag'],
                                '-o', filename])

            line_count += 1

    similarity_score_cutoff = int(args.cutoff)
    analysis = HashFuncDiscoveryAnalysis(similarity_score_cutoff)

    par_analyzer = ParallelAnalyzer(analysis,
                                    root_dir=programs_path,
                                    elf_list_file=None,
                                    break_limit=None,
                                    remove_duplicates=True,
                                    results_path=results_path,
                                    timeout=None,
                                    nthreads=1)
    par_analyzer.run_analysis()

    with open(results_path, 'r') as fd:
        for line in fd:
            line = line.strip()
            results = jsonpickle.loads(line)
            analysis_target = results.analysis_target
            filename = analysis_target.file_name
            analysis_results = results.analysis_results
            discovered_hash_funcs = analysis_results.discovered_hash_funcs
            print(filename)
            if len(discovered_hash_funcs) == 0:
                print("  No hash funcs discovered!")
            else:
                for discovered_hash_func in discovered_hash_funcs:
                    func_name = discovered_hash_func.func_name
                    func_addr = discovered_hash_func.func_addr
                    hash_func_name = discovered_hash_func.hash_func_name
                    print("  {}@0x{:x} classified as {}"
                          .format(func_name,
                                  func_addr,
                                  hash_func_name))

    # shutil.rmtree(tempdir)


if __name__ == "__main__":
    main()
