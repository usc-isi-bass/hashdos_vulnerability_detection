import angr
import itertools
import networkx as nx
#import pwn
import keystone
import logging
#logging.getLogger('pwnlib.asm').setLevel(logging.CRITICAL)

import binascii
import re
# We use a regex to try and determine if we're dealing with a jump.
# Basically, we're trying to decide if the mnemonic starts with a 'j' or 'J', but we might be looking at the label.
# So, our regex has two branches:
# (?:.*:\s*([jJ][a-zA-Z]+) if the first non-whitespace after the label's ':' is a j
# (?:\s*[jJ][a-zA-Z]+[^:]*) if the first non-whitespace character is a j and now ':' follows
# TODO Is there a better way to know if an asm instruction is a jump?
JUMP_ASM_REGEX = '(?:.*:\s*(?:[jJ][a-zA-Z]+)|(?:\s*[jJ][a-zA-Z]+[^:]*))'
# For calls we do similarly, but instead of checking for 'j' or "J' we check for 'call' (you should include RE.IGNORECASE with the regex)
CALL_ASM_REGEX = '(?:.*:\s*(?:call[a-zA-Z]*)|(?:\s*call[a-zA-Z]*[^:]*))'

class CodeCaveGraphPatchCreator:

    # code_cave_graph is a networkx DiGraph where each vertex corresponds to a code cave.
    # A vertex has the property "size" that defines how many bytes are in the code cave.
    # There is an edge between two vertices u --> v if you can jump from u to v.
    # Each edge has a property 'jump_type' that is either 'long' or 'short' and 'jump_size' that is either 2 or 5.
    # These properties show how many bytes you have to use of the code cave to add a jump to the other code cave.
    # Arch should be proj.arch
    def __init__(self, code_cave_graph, arch):    
        #pwn.context.arch = arch
        self._ks = keystone.Ks(arch.ks_arch, arch.ks_mode)
        self._code_cave_graph = code_cave_graph

            

    def fit(self, patch_asm_insns, possible_start_caves=None): 
        if possible_start_caves is None:
            # All code caves are possible start caves
            possible_start_caves = []
            for code_cave_addr in self._code_cave_graph.nodes:
                code_cave_size = self._code_cave_graph.nodes[code_cave_addr]['size']
                possible_start_caves.append((code_cave_addr, code_cave_size))
        
        #for code_cave_seq in self._find_linear_code_cave_seqs(possible_start_caves, self._code_cave_graph):
        #for code_cave_seq in self._find_short_jumps_code_cave_seqs(possible_start_caves, self._code_cave_graph):
        for code_cave_seq in self._find_random_code_cave_seqs(possible_start_caves, self._code_cave_graph):
            #print("Trying code cave seq: {}".format(code_cave_seq))
            fitted_patch = self.fit_patch_to_cave_seq(patch_asm_insns, code_cave_seq) 
            if fitted_patch is not None:
                #logging.debug("Fitted patch into binary using {} code caves.".format(len(code_cave_seq)))
                code_cave_addr = code_cave_seq[0][0]
                addr_to_patch_bin_insn_dict = fitted_patch
                return code_cave_addr, addr_to_patch_bin_insn_dict
        return None

    # Find the code caves that can be reached via short/long jump from a given address
    def find_possible_start_caves(self, jmp_src_addr, short_jmp_req):
        possible_start_caves = []
        for code_cave_addr in self._code_cave_graph.nodes:
            code_cave_size = self._code_cave_graph.nodes[code_cave_addr]['size']
            jmp_offset = code_cave_addr - jmp_src_addr
            if short_jmp_req and -0x7e <= jmp_offset <= 0x81:
                possible_start_caves.append((code_cave_addr, code_cave_size))
            elif not short_jmp_req and -0xfffffffb <= jmp_offset <= 0x100000004:
                possible_start_caves.append((code_cave_addr, code_cave_size))
        return possible_start_caves


        
                        
    def fit_patch_to_cave_seq(self, patch_asm_insns, code_cave_seq):
        addr_to_patch_bin_insn_dict = {}
        
        label_to_addr_map = {}
        deferred_jumps_and_calls = {}
        patch_asm_insn_i = 0
        for code_cave_i, code_cave in enumerate(code_cave_seq):
            code_cave_addr, code_cave_size, jump_type = code_cave
            code_cave_write_offset = 0
            if jump_type == 'short' or jump_type == 'long':
                assert code_cave_i < len(code_cave_seq) - 1, "If there is a jump to a next code cave, there has to be a next code cave, right?"
                dst_code_cave = code_cave_seq[code_cave_i + 1]
                dst_addr, dst_size, dst_type = dst_code_cave
                assert self._code_cave_graph.has_edge(code_cave_addr, dst_addr), "No edge from {} to {}".format(code_cave_addr, dst_addr)
                #print("0x{:x}({}) --> 0x{:x}({}) : {}".format(code_cave_addr, code_cave_size, dst_addr, dst_size, jump_type))
                jmp_bin_insn = self.create_code_cave_jump(code_cave[:2], dst_addr, jump_type)
                jmp_bin_insn_len = len(jmp_bin_insn)
            elif jump_type is None:
                assert code_cave_i == len(code_cave_seq) - 1, "We have a jump_type=None for a code cave that is not the last in the sequence."
                jmp_bin_insn = None
                jmp_bin_insn_len = 0
            else:
                raise Exception("Unknown jump type: {}".format(jump_type))

            assert (jump_type == 'short' and jmp_bin_insn_len == 2) or (jump_type == 'long' and jmp_bin_insn_len == 5) or (jump_type is None)
            patch_asm_insn = patch_asm_insns[patch_asm_insn_i]
            patch_bin_insn = self._assemble(patch_asm_insn)
            patch_bin_insn_len = len(patch_bin_insn)
           
            # Fill the code cave with as many patch instructions as possible
            while code_cave_write_offset + patch_bin_insn_len + jmp_bin_insn_len <= code_cave_size:
                #print("Fitting {} in patch".format(patch_asm_insn))
                patch_bin_insn_addr = code_cave_addr + code_cave_write_offset 
                self._handle_labels(label_to_addr_map, patch_bin_insn_addr, patch_asm_insn)
                self._defer_jumps_and_calls(deferred_jumps_and_calls, patch_bin_insn_addr, patch_asm_insn)
                addr_to_patch_bin_insn_dict[patch_bin_insn_addr] = patch_bin_insn
                code_cave_write_offset += patch_bin_insn_len
                patch_asm_insn_i += 1
                if patch_asm_insn_i >= len(patch_asm_insns):
                    #print("Breaking out of inner loop: {} {}".format(patch_asm_insn_i, len(patch_asm_insns)))
                    break
                patch_asm_insn = patch_asm_insns[patch_asm_insn_i]
                patch_bin_insn = self._assemble(patch_asm_insn)
                patch_bin_insn_len = len(patch_bin_insn)
            # Since += 1 to the asm insn at this point, we have only written all patch instructions if patch_asm_insn_i == len(patch_asm_insns)
            assert (patch_asm_insn_i <= len(patch_asm_insns))
            # We filled up the last code cave, but we still haven't written all patch instructions Therefore, we cannot fit this patch to this code cave sequence.
            if code_cave_i == len(code_cave_seq) - 1 and patch_asm_insn_i < len(patch_asm_insns):
                return None

            # Add a jump at the end of the code cave
            num_padding_nops = (code_cave_size - jmp_bin_insn_len) - (code_cave_write_offset)
            if num_padding_nops > 0:
                addr_to_patch_bin_insn_dict[code_cave_addr + code_cave_write_offset] = self._create_nops(num_padding_nops) # Fill the rest of the code cave with NOPs
            if jmp_bin_insn is not None:
                addr_to_patch_bin_insn_dict[code_cave_addr + code_cave_size - jmp_bin_insn_len] = jmp_bin_insn
            # We have written the last patch instruction, we have added a jump back to the trampoline, we just need to handle the deferred jump instructions then we are done.
            if patch_asm_insn_i >= len(patch_asm_insns):
                self._handle_deferred_jumps_and_calls(label_to_addr_map, deferred_jumps_and_calls, addr_to_patch_bin_insn_dict)
                return addr_to_patch_bin_insn_dict
        return None

    # If an assembly instruction contains a label, map the name of the label to the address of the current instruction.
    # Valid label names may start with [a-zA-Z_] and thereafter any number of [a-zA-Z0-9_].
    # After your label name you must put ':' to indicate you are specifying a label, but this is not part of the label name.
    # Your label must be the first non-whitespace characters in the instruction
    def _handle_labels(self, label_to_addr_map, patch_bin_insn_addr, patch_asm_insn):
        label_match = re.search(r'^\s*(?P<label_name>[a-zA-Z_][a-zA-Z0-9_]*):', patch_asm_insn)
        if label_match is not None:
            label_name = label_match.group('label_name')
            if label_name in label_to_addr_map:
                label_addr = label_to_addr_map[label_name]
                raise Exception("Label: {} already defined at addr: 0x{:x}".format(label_name, label_addr))
            label_to_addr_map[label_name] = patch_bin_insn_addr

    def _defer_jumps_and_calls(self, deferred_jumps_and_calls, patch_bin_insn_addr, patch_asm_insn):
            
            if re.match(JUMP_ASM_REGEX, patch_asm_insn):
                deferred_jumps_and_calls[patch_bin_insn_addr] = patch_asm_insn
            # For a call, we do similarly, but instead of checking if the mnemonic starts with 'j' or 'J', we check if it starts with 'call'
            if re.match(CALL_ASM_REGEX, patch_asm_insn, re.IGNORECASE):
                deferred_jumps_and_calls[patch_bin_insn_addr] = patch_asm_insn


    # Goes through all the deferred jump instructions, that now have an address where they should be written to and create binary code for them.
    # We defer them so that by now, hopefully, the labels they reference have already been defined. (If they are not, then the user made a mistake)
    def _handle_deferred_jumps_and_calls(self, label_to_addr_map, deferred_jumps_and_calls, addr_to_patch_bin_insn_dict):
        for patch_bin_insn_addr in deferred_jumps_and_calls:
            patch_asm_insn = deferred_jumps_and_calls[patch_bin_insn_addr]
            patch_bin_insn = None
            # Try to determine what type of operand we're dealing with
            numeric_operand_match = re.search(r'(?P<mnem>(?:[jJ][a-zA-Z]+)|call)\s+(?P<num_operand>(?P<hex>0x[0-9a-fA-F]+)|(?P<dec>[1-9][0-9]*)|(?P<oct>0[0-7]*)|(?P<bin>0b[01]+))', patch_asm_insn, re.IGNORECASE)
            label_operand_match = re.search(r'(?P<mnem>(?:[jJ][a-zA-Z]+)|call)\s+(?P<label_name>[a-zA-Z_][a-zA-Z0-9_]*)', patch_asm_insn, re.IGNORECASE)
            if numeric_operand_match is not None:
                mnemonic = numeric_operand_match.group('mnem')
                target_addr = None
                hex_group = numeric_operand_match.group('hex')
                if hex_group is not None:
                    target_addr = int(hex_group, 16)
                dec_group = numeric_operand_match.group('dec')
                if dec_group is not None:
                    target_addr = int(dec_group, 10)
                oct_group = numeric_operand_match.group('oct')
                if oct_group is not None:
                    target_addr = int(oct_group, 8)
                bin_group = numeric_operand_match.group('bin')
                if bin_group is not None:
                    target_addr = int(bin_group, 2)
                assert target_addr is not None, "Something is wrong with the regex to parse the numeric jump/call address."
                jump_dist = target_addr - patch_bin_insn_addr
                patch_bin_insn = bytes(self._ks.asm("{} {}".format(mnemonic, jump_dist))[0])
            elif label_operand_match is not None:
                mnemonic = label_operand_match.group('mnem')
                label_name = label_operand_match.group('label_name')
                if label_name in label_to_addr_map:
                    target_addr = label_to_addr_map[label_name]
                    jump_dist = target_addr - patch_bin_insn_addr
                    patch_bin_insn = bytes(self._ks.asm("{} {}".format(mnemonic, jump_dist))[0])
                else:
                    # The label must actually have been a register, so we jump assemble it with asm
                    # TODO we probably want to add some additional error information if the user actually just forgot to define the label
                    #patch_bin_insn = pwn.asm(patch_bin_insn_addr)
                    patch_bin_insn = bytes(self._ks.asm(patch_bin_insn_addr)[0])
            else:
                raise Exception("Could not parse the operand of jump instruction: {}".format(patch_asm_insn))
            
            assert patch_bin_insn is not None, "At this point we should have created the binary code for the jump instruction: {}".format(patch_asm_insn)
            # It makes it easier if we just assume they're all the size of conditinal long jumps. So, if they're not, we add nops until they are
            if len(patch_bin_insn) < 6:
                patch_bin_insn = patch_bin_insn + self._create_nops(6 - len(patch_bin_insn))
            addr_to_patch_bin_insn_dict[patch_bin_insn_addr] = patch_bin_insn
                                

                


    def _find_linear_code_cave_seqs(self, start_code_caves, code_cave_graph):
        sorted_code_cave_addrs = list(sorted(code_cave_graph.nodes))
        for start_code_cave in start_code_caves:
            start_code_cave_addr, start_code_cave_size = start_code_cave
            code_cave_i = sorted_code_cave_addrs.index(start_code_cave_addr)
            if code_cave_i > len(sorted_code_cave_addrs) / 2:
                sorted_code_cave_addrs = list(reversed(sorted_code_cave_addrs))
                code_cave_i = sorted_code_cave_addrs.index(start_code_cave_addr)
                assert code_cave_i <= len(sorted_code_cave_addrs) / 2
            code_cave_seq = [[start_code_cave_addr, start_code_cave_size, None]]
            while code_cave_i < len(sorted_code_cave_addrs) - 1:
                code_cave_src_addr = sorted_code_cave_addrs[code_cave_i]
                code_cave_j = code_cave_i + 1
                code_cave_dst_addr = sorted_code_cave_addrs[code_cave_j]
                while not code_cave_graph.has_edge(code_cave_src_addr, code_cave_dst_addr):
                    code_cave_j += 1
                    if  code_cave_j >= len(sorted_code_cave_addrs):
                        break
                    code_cave_dst_addr = sorted_code_cave_addrs[code_cave_j]
                if code_cave_graph.has_edge(code_cave_src_addr, code_cave_dst_addr):
                    code_cave_dst_size = code_cave_graph.nodes[code_cave_dst_addr]['size']
                    jump_type = code_cave_graph.edges[code_cave_src_addr, code_cave_dst_addr]['jump_type']
                    code_cave_seq[-1][2] = jump_type # Updating the jump_type of the previous code cave
                    code_cave_seq.append([code_cave_dst_addr, code_cave_dst_size, None])
                    
                    code_cave_i = code_cave_j
                else:
                    break # The current src code cave does not have any edges with next code caves
            yield code_cave_seq
    
            
            
    def _find_short_jumps_code_cave_seqs(self, start_code_caves, code_cave_graph):
        code_cave_graph_no_long_jumps = code_cave_graph.copy()
        for edge in code_cave_graph.edges:
            jump_type = code_cave_graph.edges[edge]['jump_type']
            if jump_type == 'long':
                code_cave_graph_no_long_jumps.remove_edge(edge[0], edge[1])
        for start_code_cave in start_code_caves:
            start_code_cave_addr, _ = start_code_cave
            for target_code_cave_addr in code_cave_graph.nodes:
                if start_code_cave_addr == target_code_cave_addr:
                    continue
                for simple_path in nx.all_simple_paths(code_cave_graph_no_long_jumps, start_code_cave_addr, target_code_cave_addr):
                    if all([code_cave_graph_no_long_jumps.edges[simple_path[i], simple_path[i + 1]]['jump_type'] == 'short' for i in range(len(simple_path) - 1)]):
                        code_cave_seq = []
                        for i, code_cave_addr in enumerate(simple_path):
                            code_cave_size = code_cave_graph_no_long_jumps.nodes[code_cave_addr]['size']
                            jump_type = None
                            if i < len(simple_path) - 1:
                                jump_type = code_cave_graph_no_long_jumps.edges[code_cave_addr, simple_path[i + 1]]['jump_type']
                            code_cave_seq.append((code_cave_addr, code_cave_size, jump_type))
                        yield code_cave_seq

    def _find_random_code_cave_seqs(self, start_code_caves, code_cave_graph):
        break_limit = 10000
        break_counter = 0
        for start_code_cave in start_code_caves:
            start_code_cave_addr = start_code_cave[0]
            for v in self._code_cave_graph.nodes:
                if start_code_cave_addr == v:
                    start_code_cave_size = self._code_cave_graph.nodes[v]['size']
                    code_cave_seq = [(start_code_cave_addr, start_code_cave_size, None)]
                    yield code_cave_seq
                #print('paths from: 0x{:x} -> 0x{:x}'.format(start_code_cave_addr, v))
                for simple_path in nx.all_simple_paths(self._code_cave_graph, start_code_cave_addr, v):
                    #print("  simple path: {}".format(simple_path))
                    code_cave_seq = []
                    for i, code_cave_addr in enumerate(simple_path):
                        code_cave_size = self._code_cave_graph.nodes[code_cave_addr]['size']
                        jump_type = None
                        if i < len(simple_path) - 1:
                            jump_type = self._code_cave_graph.edges[code_cave_addr, simple_path[i + 1]]['jump_type']
                        code_cave_seq.append((code_cave_addr, code_cave_size, jump_type))
                    yield code_cave_seq
                    break_counter += 1
                    if break_counter >= break_limit:
                        break

    def _assemble(self, asm_insn):
        if re.match(JUMP_ASM_REGEX, asm_insn) or re.match(CALL_ASM_REGEX, asm_insn):
            #print("Creating placeholder for jump: {}".format(asm_insn))
            return '\xcc' * 6 # Since the binary code for jumps and calls depend on where it's located and where it's going. We do these last. For now, we create a placeholder consisting of 6 interrupt instructions (so that it breaks if it gets executed) (recall that conditional jumps are larger (6 bytes) than unconditional jumps (5 bytes))
        #return pwn.asm(asm_insn)
        try:
            machine_code = bytes(self._ks.asm(asm_insn)[0])
            
            return machine_code
        except Exception as e:
            print("Could not assemble: {}".format(asm_insn))
            raise e

        
            
                    


    def create_code_cave_jump(self, code_cave_src, dst_addr, jump_type):
        if jump_type == 'short':
            jmp_bin_insn_len = 2
        elif jump_type == 'long':
            jmp_bin_insn_len = 5
        else:
            raise Exception("Cannot use jump type {} between code caves (must be 'short' or 'long').".format(jump_type))
            
        code_cave_src_addr, code_cave_src_size = code_cave_src
        code_cave_src_short_jmp_addr = code_cave_src_addr + code_cave_src_size - jmp_bin_insn_len
        jmp_dist = dst_addr - code_cave_src_short_jmp_addr
        jmp_bin_insn = bytes(self._ks.asm("jmp {}".format(jmp_dist))[0])
        #assert len(jmp_bin_insn) == jmp_bin_insn_len, "For a jump of dist: {}, we have a jump of length: {} but we expected length: {}".format(jmp_dist, len(jmp_bin_insn), jmp_bin_insn_len)
        # This happens when we cannot do a short jump from the regular address we do short jumps (code_cave_addr + size - 2) but we can do a short jump from the addr we would have done a long jump (code_cave_addr + size - 5).
        # (Note that the destination is then before the source (address wise)
        # We fill the rest of the bytes with NOPs
        if len(jmp_bin_insn) < jmp_bin_insn_len:
            jmp_bin_insn += self._create_nops(jmp_bin_insn_len - len(jmp_bin_insn))
            assert len(jmp_bin_insn) == jmp_bin_insn_len
        return jmp_bin_insn

    def calc_code_cave_jump_type(self, code_cave_src, dst_addr):
        # Trying a short jump
        code_cave_src_addr, code_cave_src_size = code_cave_src
        code_cave_src_short_jmp_addr = code_cave_src_addr + code_cave_src_size - 2
        jmp_dist = dst_addr - code_cave_src_short_jmp_addr
        if -0x7e <= jmp_dist <= 0x81:
            return 'short'
        return 'long'

    def _create_nops(self, n):
        if n < 0:
            raise Exception("I can only create one or more nops...")
        if n == 0:
            return ''

        nop_str = 'nop' + '; nop' * (n - 1)
        return bytes(self._ks.asm(nop_str)[0])

        
  



