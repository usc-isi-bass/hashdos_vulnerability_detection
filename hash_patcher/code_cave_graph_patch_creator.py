import angr
import itertools
import networkx as nx
import pwn
import binascii
import re

import hash_patcher.binary_code_utils as bcu

class CodeCaveGraphPatchCreator:

    # code_cave_graph is a networkx DiGraph where each vertex corresponds to a code cave.
    # A vertex has the property "size" that defines how many bytes are in the code cave.
    # There is an edge between two vertices u --> v if you can jump from u to v.
    # Each edge has a property 'jump_type' that is either 'long' or 'short' and 'jump_size' that is either 2 or 5.
    # These properties show how many bytes you have to use of the code cave to add a jump to the other code cave.
    def __init__(self, code_cave_graph):    
        self._code_cave_graph = code_cave_graph

            

    def fit(self, trampoline_branch_insn, patch_asm_insns, trampoline_ret_addr):
        possible_start_caves = []
        if len(trampoline_branch_insn.bytes) < 2:
            raise Exception("The instruction provided to overwrite with a jump to the trampoline: {} (bytes: {}) is not large enough to be overwritten with a jmp. (Need at least 2 bytes)".format(trampoline_branch_insn, binascii.hexlify(trampoline_branch_insn.bytes)))
        if len(trampoline_branch_insn.bytes) < 5:
            short_jmp_req = True
        else:
            short_jmp_req = False
        possible_start_caves = self.find_possible_start_caves(trampoline_branch_insn.address, short_jmp_req)
        
        for code_cave_seq in self._find_short_jumps_code_cave_seqs(possible_start_caves, self._code_cave_graph):
            fitted_patch = self.fit_patch_to_cave_seq(patch_asm_insns, trampoline_ret_addr, code_cave_seq) 
            if fitted_patch is not None:
                code_cave_addr, addr_to_patch_bin_insn_dict = fitted_patch
                return code_cave_addr, addr_to_patch_bin_insn_dict
        return None

    # Find the code caves that can be reached via short/long jump from a given address
    def find_possible_start_caves(self, jmp_src_addr, short_jmp_req):
        possible_start_caves = []
        for code_cave_addr in self._code_cave_graph.nodes:
            code_cave_size = self._code_cave_graph.nodes[code_cave_addr]['size']
            jmp_offset = code_cave_addr - jmp_src_addr
            if short_jmp_req and -0x7e <= jmp_offset <= 0x81:
                possible_start_caves.append((code_cave_addr, code_cave_size))
            elif not short_jmp_req and -0xfffffffb <= jmp_offset <= 0x100000004:
                possible_start_caves.append((code_cave_addr, code_cave_size))
        return possible_start_caves


        
                        
    def fit_patch_to_cave_seq(self, patch_asm_insns, trampoline_ret_addr, code_cave_seq):
        addr_to_patch_bin_insn_dict = {}
        
        label_to_addr_map = {}
        deferred_jumps = {}
        patch_asm_insn_i = 0
        for code_cave_i, code_cave in enumerate(code_cave_seq):
            code_cave_addr, code_cave_size, jump_type = code_cave
            code_cave_write_offset = 0
            if jump_type == 'short' or jump_type == 'long':
                assert code_cave_i < len(code_cave_seq) - 1, "If there is a jump to a next code cave, there has to be a next code cave, right?"
                dst_addr = code_cave_seq[code_cave_i + 1][0]
                jmp_bin_insn = create_code_cave_jump(code_cave[:2], dst_addr, jump_type)
            elif jump_type is None:
                assert code_cave_i == len(code_cave_seq) - 1, "We have a jump_type=None for a code cave that is not the last in the sequence."
                dst_addr = trampoline_ret_addr
                jmp_type = calc_code_cave_jump_type(code_cave[:2], dst_addr)
                jmp_bin_insn = create_code_cave_jump(code_cave[:2], dst_addr, jmp_type)
            else:
                raise Exception("Unknown jump type: {}".format(jump_type))
            jmp_bin_insn_len = len(jmp_bin_insn)

            assert (jump_type == 'short' and jmp_bin_insn_len == 2) or (jump_type == 'long' and jmp_bin_insn_len == 5) or (jump_type is None)
            patch_asm_insn = patch_asm_insns[patch_asm_insn_i]
            patch_bin_insn = self._assemble(patch_asm_insn)
            patch_bin_insn_len = len(patch_bin_insn)
            
            # Fill the code cave with as many patch instructions as possible
            while code_cave_write_offset + patch_bin_insn_len + jmp_bin_insn_len <= code_cave_size:
                print("Fitting {} in patch".format(patch_asm_insn))
                patch_bin_insn_addr = code_cave_addr + code_cave_write_offset 
                self._handle_labels(label_to_addr_map, patch_bin_insn_addr, patch_asm_insn)
                self._defer_jumps(deferred_jumps, patch_bin_insn_addr, patch_asm_insn)
                addr_to_patch_bin_insn_dict[patch_bin_insn_addr] = patch_bin_insn
                code_cave_write_offset += patch_bin_insn_len
                patch_asm_insn_i += 1
                if patch_asm_insn_i >= len(patch_asm_insns):
                    print("Breaking out of inner loop: {} {}".format(patch_asm_insn_i, len(patch_asm_insns)))
                    break
                patch_asm_insn = patch_asm_insns[patch_asm_insn_i]
                patch_bin_insn = self._assemble(patch_asm_insn)
                patch_bin_insn_len = len(patch_bin_insn)
            # Since += 1 to the asm insn at this point, we have only written all patch instructions if patch_asm_insn_i == len(patch_asm_insns)
            assert (patch_asm_insn_i <= len(patch_asm_insns))
            # We filled up the last code cave, but we still haven't written all patch instructions Therefore, we cannot fit this patch to this code cave sequence.
            if code_cave_i == len(code_cave_seq) - 1 and patch_asm_insn_i < len(patch_asm_insns):
                return None

            # We have written the last patch instruction, update the jump instruction to go back to the trampoline, instead of the next code cave in the sequence
            if patch_asm_insn_i >= len(patch_asm_insns):
                dst_addr = trampoline_ret_addr
                print("Finished fitting patch to code caves. Creating jump back to trampoline:")
                print("Code cave addr: 0x{:x} dst: 0x{:x}".format(code_cave[0], dst_addr))
                jmp_type = calc_code_cave_jump_type(code_cave[:2], dst_addr)
                jmp_bin_insn = create_code_cave_jump(code_cave[:2], dst_addr, jmp_type)
                jmp_bin_insn_len = len(jmp_bin_insn)
                print("jmp insn: {}".format(binascii.hexlify(jmp_bin_insn)))
            
            # Add a jump at the end of the code cave
            addr_to_patch_bin_insn_dict[code_cave_addr + code_cave_write_offset] = b'\x90' * ((code_cave_size - jmp_bin_insn_len) - (code_cave_write_offset)) # Fill the rest of the code cave with NOPs
            addr_to_patch_bin_insn_dict[code_cave_addr + code_cave_size - jmp_bin_insn_len] = jmp_bin_insn
            # We have written the last patch instruction, we have added a jump back to the trampoline, we just need to handle the deferred jump instructions then we are done.
            if patch_asm_insn_i >= len(patch_asm_insns):
                self._handle_deffered_jumps(label_to_addr_map, deferred_jumps, addr_to_patch_bin_insn_dict)
                return code_cave_seq[0][0], addr_to_patch_bin_insn_dict
        return None

    # If an assembly instruction contains a label, map the name of the label to the address of the current instruction.
    # Valid label names may start with [a-zA-Z_] and thereafter any number of [a-zA-Z0-9_].
    # After your label name you must put ':' to indicate you are specifying a label, but this is not part of the label name.
    # Your label must be the first non-whitespace characters in the instruction
    def _handle_labels(self, label_to_addr_map, patch_bin_insn_addr, patch_asm_insn):
        label_match = re.search(r'^\s*(?P<label_name>[a-zA-Z_][a-zA-Z0-9_]*):', patch_asm_insn)
        if label_match is not None:
            label_name = label_match.group('label_name')
            if label_name in label_to_addr_map:
                label_addr = label_to_addr_map[label_name]
                raise Exception("Label: {} already defined at addr: 0x{:x}".format(label_name, label_addr))
            label_to_addr_map[label_name] = patch_bin_insn_addr

    def _defer_jumps(self, deferred_jumps, patch_bin_insn_addr, patch_asm_insn):
            # We use a regex to try and determine if we're dealing with a jump.
            # Basically, we're trying to decide if the mnemonic starts with a 'j' or 'J', but we might be looking at the label.
            # So, our regex has two branches:
            # (?:.*:\s*([jJ][a-zA-Z]+) if the first non-whitespace after the label's ':' is a j
            # (?:\s*[jJ][a-zA-Z]+[^:]*) if the first non-whitespace character is a j and now ':' follows
            # TODO Is there a better way to know if an asm instruction is a jump?
            if re.match('(?:.*:\s*(?:[jJ][a-zA-Z]+)|(?:\s*[jJ][a-zA-Z]+[^:]*))', patch_asm_insn):
                deferred_jumps[patch_bin_insn_addr] = patch_asm_insn


    # Goes through all the deferred jump instructions, that now have an address where they should be written to and create binary code for them.
    # We defer them so that by now, hopefully, the labels they reference have already been defined. (If they are not, then the user made a mistake)
    def _handle_deffered_jumps(self, label_to_addr_map, deferred_jumps, addr_to_patch_bin_insn_dict):
        for patch_bin_insn_addr in deferred_jumps:
            patch_asm_insn = deferred_jumps[patch_bin_insn_addr]
            patch_bin_insn = None
            # Try to determine what type of operand we're dealing with
            numeric_operand_match = re.search(r'(?P<jump_mnem>[jJ][a-zA-Z]+)\s+(?P<num_operand>(?P<hex>0x[0-9a-fA-F]+)|(?P<dec>[1-9][0-9]*)|(?P<oct>0[0-7]*)|(?P<bin>0b[01]+))', patch_asm_insn)
            if numeric_operand_match is not None:
                jump_mnemonic = numeric_operand_match.group('jump_mnem')
                jump_addr = None
                hex_group = numeric_operand_match.group('hex')
                if hex_group is not None:
                    jump_addr = int(hex_group, 16)
                dec_group = numeric_operand_match.group('dec')
                if dec_group is not None:
                    jump_addr = int(dec_group, 10)
                oct_group = numeric_operand_match.group('oct')
                if oct_group is not None:
                    jump_addr = int(oct_group, 8)
                bin_group = numeric_operand_match.group('bin')
                if bin_group is not None:
                    jump_addr = int(bin_group, 2)
                assert jump_addr is not None, "Something is wrong with the regex to parse the numeric jump address."
                jump_dist = jump_addr - patch_bin_insn_addr
                patch_bin_insn = bcu.create_jump(jump_mnenomic, jump_dist)

            label_operand_match = re.search(r'(?P<jump_mnem>[jJ][a-zA-Z]+)\s+(?P<label_name>[a-zA-Z_][a-zA-Z0-9_]*)', patch_asm_insn)
            if label_operand_match is not None:
                jump_mnemonic = label_operand_match.group('jump_mnem')
                label_name = label_operand_match.group('label_name')
                if label_name in label_to_addr_map:
                    jump_addr = label_to_addr_map[label_name]
                    jump_dist = jump_addr - patch_bin_insn_addr
                    patch_bin_insn = bcu.create_jump(jump_mnemonic, jump_dist)
                else:
                    # The label must actually have been a register, so we jump assemble it with asm
                    # TODO we probably want to add some additional error information if the user actually just forgot to define the label
                    patch_bin_insn = pwn.asm(patch_bin_insn_addr)
            else:
                raise Exception("Could not parse the operand of jump instruction: {}".format(patch_asm_insn))
            
            assert patch_bin_insn is not None, "At this point we should have created the binary code for the jump instruction: {}".format(patch_asm_insn)
            # It makes it easier if we just assume they're all the size of long jumps. So, if they're not, we add nops until they are
            if len(patch_bin_insn) < 5:
                patch_bin_insn = patch_bin_insn + b'\x90' * (5 - len(patch_bin_insn))
            addr_to_patch_bin_insn_dict[patch_bin_insn_addr] = patch_bin_insn
                                

                


            
            
    def _find_short_jumps_code_cave_seqs(self, start_code_caves, code_cave_graph):
        code_cave_graph_no_long_jumps = code_cave_graph.copy()
        for edge in code_cave_graph.edges:
            jump_type = code_cave_graph.edges[edge]['jump_type']
            if jump_type == 'long':
                code_cave_graph_no_long_jumps.remove_edge(edge[0], edge[1])
        for start_code_cave in start_code_caves:
            start_code_cave_addr, _ = start_code_cave
            for target_code_cave_addr in code_cave_graph.nodes:
                if start_code_cave_addr == target_code_cave_addr:
                    continue
                for simple_path in nx.all_simple_paths(code_cave_graph_no_long_jumps, start_code_cave_addr, target_code_cave_addr):
                    if all([code_cave_graph_no_long_jumps.edges[simple_path[i], simple_path[i + 1]]['jump_type'] == 'short' for i in range(len(simple_path) - 1)]):
                        code_cave_seq = []
                        for i, code_cave_addr in enumerate(simple_path):
                            code_cave_size = code_cave_graph_no_long_jumps.nodes[code_cave_addr]['size']
                            jump_type = None
                            if i < len(simple_path) - 1:
                                jump_type = code_cave_graph_no_long_jumps.edges[code_cave_addr, simple_path[i + 1]]['jump_type']
                            code_cave_seq.append((code_cave_addr, code_cave_size, jump_type))
                        yield code_cave_seq

    def _assemble(self, asm_insn):
        if re.match('(?:.*:\s*(?:[jJ][a-zA-Z]+)|(?:\s*[jJ][a-zA-Z]+[^:]*))', asm_insn):
            print("Creating placeholder for jump: {}".format(asm_insn))
            return '\xcc' * 5 # Since the binary code for jumps depend on where it's located and where it's going. We do these last. For now, we create a placeholder consisting of 5 interrupt instructions (so that it breaks if it gets executed)
        return pwn.asm(asm_insn)
        
            
                    


def create_code_cave_jump(code_cave_src, dst_addr, jump_type):
    if jump_type == 'short':
        jmp_bin_insn_len = 2
    elif jump_type == 'long':
        jmp_bin_insn_len = 5
    else:
        raise Exception("Cannot use jump type {} between code caves (must be 'short' or 'long').".format(jump_type))
        
    code_cave_src_addr, code_cave_src_size = code_cave_src
    code_cave_src_short_jmp_addr = code_cave_src_addr + code_cave_src_size - jmp_bin_insn_len
    jmp_dist = dst_addr - code_cave_src_short_jmp_addr
    jmp_bin_insn = bcu.create_jump('jmp', jmp_dist)
    assert len(jmp_bin_insn) == jmp_bin_insn_len
    return jmp_bin_insn

def calc_code_cave_jump_type(code_cave_src, dst_addr):
    # Trying a short jump
    code_cave_src_addr, code_cave_src_size = code_cave_src
    code_cave_src_short_jmp_addr = code_cave_src_addr + code_cave_src_size - 2
    jmp_dist = dst_addr - code_cave_src_short_jmp_addr
    if -0x7e <= jmp_dist <= 0x81:
        return 'short'
    return 'long'
    
  



