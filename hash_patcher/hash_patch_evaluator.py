import angr
import claripy
import math

from hash_patcher.hash_func_evaluator import HashFuncEvaluatorSig1,HashFuncEvaluatorSig2

class HashPatchEvaluator:

    # TODO Make signature sensitive
    def __init__(self, vuln_elf_file_name, hash_func_addr, sig, vuln_proj=None):
        self._vuln_elf_file_name = vuln_elf_file_name
        self._hash_func_addr = hash_func_addr
        self._conc_buf_to_mem_reads = {}

        if vuln_proj is None:
            self._vuln_proj = angr.Project(self._vuln_elf_file_name, auto_load_libs=False)
        else:
            self._vuln_proj = vuln_proj

        self._sig = sig
        if sig == 'sig1':
            self._vuln_hash_func_evaluator = HashFuncEvaluatorSig1(vuln_elf_file_name, hash_func_addr, proj=self._vuln_proj)
        elif sig == 'sig2':
            self._vuln_hash_func_evaluator = HashFuncEvaluatorSig2(vuln_elf_file_name, hash_func_addr, proj=self._vuln_proj)
        else:
            raise Exception("Unknown signature: {}".format(sig))

        self._patch_elf_file_name = None
        self._patch_proj = None

    def set_patch(self, patch_elf_file_name):
        self._patch_elf_file_name = patch_elf_file_name
        self._patch_proj = angr.Project(self._patch_elf_file_name, auto_load_libs=False)

        if self._sig == 'sig1':
            self._patch_hash_func_evaluator = HashFuncEvaluatorSig1(patch_elf_file_name, self._hash_func_addr, proj=self._patch_proj)
        elif self._sig == 'sig2':
            self._patch_hash_func_evaluator = HashFuncEvaluatorSig2(patch_elf_file_name, self._hash_func_addr, proj=self._patch_proj)
        else:
            raise Exception("Unknown signature: {}".format(sig))

    # TODO update naming schema so that everything that returns irregularities have one type of name and that which returns true/false have a different type

    # Check that for every concrete buffer, the hash value produced by the patched hash value could also have been produced by the original
    def check_hash_vals_range(self, conc_bufs):
        self.assert_patch()
        patch_irregularities = []
        for conc_buf in conc_bufs:
            patched_hash_val = self._patch_hash_func_evaluator.eval(conc_buf, len(conc_buf))
            vuln_preimage = self._vuln_hash_func_evaluator.find_preimage(patched_hash_val)
            if vuln_preimage is None:
                irregularity = HashPatchIrregularHashValRange(patched_hash_val, 'could not find preimage for original hash. conc buf: {}'.format(conc_buf))
                patch_irregularities.append(irregularity)
        return patch_irregularities

    def check_case_sensitivity(self, conc_bufs, check_original=True):
        if check_original:
            hash_func_evaluator = self._vuln_hash_func_evaluator
        else:
            self.assert_patch()
            hash_func_evaluator = self._patch_hash_func_evaluator

        for conc_buf in conc_bufs:
            hash_val = hash_func_evaluator.eval(conc_buf, len(conc_buf))

            conc_buf_upper = conc_buf.upper()
            conc_buf_lower = conc_buf.lower()
            assert conc_buf != conc_buf_upper or conc_buf != conc_buf_lower, "Trying to check case sensitivity with a buffer that is the same in upper and lower case: buf: {} upper: {} lower: {}".format(conc_buf, conc_buf_upper, conc_buf_lower)

            hash_val_upper = hash_func_evaluator.eval(conc_buf_upper, len(conc_buf_upper))
            hash_val_lower = hash_func_evaluator.eval(conc_buf_lower, len(conc_buf_lower))

            if hash_val_upper != hash_val or hash_val_lower != hash_val:
                return True
        return False

    def check_hash_vals(self, hash_alg_name, conc_buf_hash_val_map, check_original=True):
        if check_original:
            hash_func_evaluator = self._vuln_hash_func_evaluator
        else:
            self.assert_patch()
            hash_func_evaluator = self._patch_hash_func_evaluator
        irregularities = []
        for conc_buf, expected_hash_vals in conc_buf_hash_val_map.items():
            hash_val = hash_func_evaluator.eval(conc_buf, len(conc_buf))

            if hash_val not in expected_hash_vals:
                irregularity = HashPatchIrregularHashVal(hash_alg_name, conc_buf, hash_val, expected_hash_vals)
                irregularities.append(irregularity)
        return irregularities

    def check_symb_ret(self, conc_bufs, check_original=True):
        if check_original:
            hash_func_evaluator = self._vuln_hash_func_evaluator
        else:
            self.assert_patch()
            hash_func_evaluator = self._patch_hash_func_evaluator
        irregularities = []
        for conc_buf in conc_bufs:
            irrs = hash_func_evaluator.evaluate_conc(conc_buf, len(conc_buf))
            if len(irrs) > 0:
                irregularities.extend(irrs)
        return irregularities



    def check_signature(self, check_original=True):
        if check_original:
            return self._vuln_hash_func_evaluator.evaluate_sig()
        else:
            self.assert_patch()
            return self._patch_hash_func_evaluator.evaluate_sig()

    # TODO write something that to use the external mem check of hash func evaluator
    def check_ext_mem_refs(self, conc_bufs, check_original):
        if check_original:
            hash_func_evaluator = self._vuln_hash_func_evaluator
        else:
            self.assert_patch()
            hash_func_evaluator = self._patch_hash_func_evaluator
        irregularities = []
        for conc_buf in conc_bufs:
            read_addr_whitelist = None
            if not check_original:
                if conc_buf in self._conc_buf_to_mem_reads:
                    read_addr_whitelist = self._conc_buf_to_mem_reads[conc_buf]
                else:
                    raise Exception("Trying to evaluate ext mem refs for a patch with a concrete buffer that was not used for the original. (How am I supposed to know what memory references are valid?)")

            ret_state_action_pairs, hash_func_irregularities = hash_func_evaluator.evaluate_ext_mem_refs(conc_buf, len(conc_buf), read_addr_whitelist=read_addr_whitelist)
            # If we are evaluating the original function, create a set of memory addresses read from
            # We use these as the whitelist for when checking the patched function with the same conc_buf
            if check_original:
                # TODO This can probably be moved to a function
                read_addrs = set()
                for ret_state, action in ret_state_action_pairs:
                    if action.action == angr.state_plugins.SimActionData.READ:
                        ref_addr = ret_state.solver.eval(action.addr.to_claripy())
                        read_addrs.add(ref_addr)

                self._conc_buf_to_mem_reads[conc_buf] = read_addrs
            irregularities.extend(hash_func_irregularities)

        return irregularities






    def assert_patch(self):
        if not self.check_patch():
            raise Exception("You first have to set a patched binary.")


    def check_patch(self):
        return self._patch_elf_file_name and self._patch_proj and self._patch_hash_func_evaluator

class HashPatchIrregularity:

    def __init__(self, patch_irregularity_type):
        self.patch_irregularity_type = patch_irregularity_type

class HashPatchIrregularHashValRange(HashPatchIrregularity):

    def __init__(self, hash_val, msg):
        super().__init__('irregular_hash_val_range')
        self.hash_val = hash_val
        self.msg = msg

    def __str__(self):
        return "<HashPatchIrregularHashValRange {} ({})>".format(self.hash_val, self.msg)

class HashPatchIrregularHashVal(HashPatchIrregularity):

    def __init__(self, hash_alg_name, conc_buf, hash_val, expected_hash_vals):
        super().__init__('irregular_hash_val')
        self.hash_alg_name = hash_alg_name
        self.conc_buf = conc_buf
        self.hash_val = hash_val
        self.expected_hash_vals = expected_hash_vals
        self.msg = '{} of {} should have been one of {} not {}'.format(hash_alg_name, conc_buf, expected_hash_vals, hash_val)

    def __str__(self):
        return "<HashPatchIrregularHashValRange {} ({})>".format(self.hash_val, self.msg)

