import angr
import itertools
import networkx as nx
import binascii
import re

from hash_patcher.code_cave_graph import CodeCaveGraph

INTER_FUNC_PAD_MAX_SIZE = 15

# A class for searching through a binary ELF file for function alignment padding.
class InterFuncCodeCaveMiner:

    # We rather pass an elf file name, because you can't create a CFGEmulated without affecting the previously created CFGFast
    def __init__(self, elf_file_name):
        proj = angr.Project(elf_file_name, auto_load_libs=False)
        cfg = proj.analyses.CFGFast(normalize=True)
        self._proj = proj
        self._cfg = cfg
        code_caves = self._search_interfunction_code_caves(self._proj, self._cfg)
        self._code_caves = code_caves
        self._code_cave_graph = self._construct_code_cave_graph(self._code_caves)

    def get_code_cave_graph(self):
        return self._code_cave_graph

    # This function searches for the padding that sometimes occurs in between functions.
    def _search_interfunction_code_caves(self, proj, cfg):
        code_caves = []
        # In angr, the func alignment padding are contained in their own small functions
        for func_addr in cfg.functions:
            func = cfg.functions[func_addr]
            '''
            # Only small functions can be padding
            if func.size > INTER_FUNC_PAD_MAX_SIZE:
                continue

            # A jump instruction is 2 bytes (at the very least we need to use it to decrease the distance between two other code caves)
            if func.size < 2:
                continue
            if func.is_simprocedure or func.is_plt:
                continue

            cfg_node = cfg.model.get_any_node(addr=func_addr)
            # If this function has predecessors, then it's probably not padding
            if len(cfg.model.get_predecessors(cfg_node)) > 0:
                continue
            only_nops = True
            func_blocks = list(func.blocks)
            # If the function has more than one block, we'll play it safe and ignore it
            if len(func_blocks) > 1:
                continue
            block = func_blocks[0]
            capstone = block.capstone
            # From what I've seen the padding "functions" are usually full of strange nop instructions (nop, but not 0x90)
            for insn in capstone.insns:
                #if insn.mnemonic != 'nop':
                if not self._is_nop(insn):
                    only_nops = False
                    break
            if not only_nops:
                continue
            '''
            # A jump instruction is 2 bytes (at the very least we need to use it to decrease the distance between two other code caves)
            if func.size < 2:
                continue
            if func.alignment:
                code_caves.append((func.addr, func.size))

        code_caves = sorted(code_caves, key=lambda c : c[0])
        return code_caves


    # After we have found the code caves between functions, we build a graph of these code caves.
    # There is an edge u -> v between two code caves u and v if you can jump from u to v.
    # The weight of the edge u -> v is the number of bytes the jump instruction will require (2 for a short jump, 5 for a long jump)
    def _construct_code_cave_graph(self, code_caves):
        code_cave_graph = CodeCaveGraph()
        for code_cave in code_caves:
            code_cave_addr, code_cave_size = code_cave
            code_cave_graph.add_code_cave(code_cave_addr, code_cave_size)
        '''
        code_cave_graph = nx.DiGraph()
        for code_cave in code_caves:
            code_cave_addr, code_cave_size = code_cave
            code_cave_graph.add_node(code_cave_addr, size=code_cave_size)

        for i, j in itertools.product(range(len(code_caves)), repeat=2):
            if i != j:
                code_cave_src = code_caves[i]
                code_cave_dst = code_caves[j]
                code_cave_src_addr, code_cave_src_size = code_cave_src
                code_cave_dst_addr, code_cave_dst_size = code_cave_dst

                short_jumpable = can_short_jump(code_cave_src, code_cave_dst_addr)
                long_jumpable = can_long_jump(code_cave_src, code_cave_dst_addr)
                if short_jumpable:
                    code_cave_graph.add_edge(code_cave_src_addr, code_cave_dst_addr, jump_type='short', jump_len=2)
                elif long_jumpable:
                    code_cave_graph.add_edge(code_cave_src_addr, code_cave_dst_addr, jump_type='long', jump_len=5)
        '''
        return code_cave_graph

    def _extract_metrics(self):
        metrics = {}
        metrics['num_code_caves'] = len(self._code_cave_graph.nodes())
        # Count the number of times a code cave of a specific size occurs
        interfunc_pad_size_freqs = {i:0 for i in range(2, INTER_FUNC_PAD_MAX_SIZE + 1)}
        for node in self._code_cave_graph.nodes:
            pad_size = self._code_cave_graph.nodes[node]['size']
            interfunc_pad_size_freqs[pad_size] += 1
        metrics['pad_size_freqs'] = interfunc_pad_size_freqs
        # Get a feel for how many bytes you can get by linking multiple code caves
        max_path_size = 0
        break_limit = 10000
        break_counter = 0
        for u, v in itertools.product(self._code_cave_graph.nodes, repeat=2):
            if u == v:
                continue
            for path in nx.all_simple_paths(self._code_cave_graph, u, v):
                addr_set = set()
                for addr in path:
                    if addr in addr_set:
                        raise Exception("addr {} already in path!".format(addr))
                    else:
                        addr_set.add(addr)
                path_size = 0
                for i, x in enumerate(path):
                    x_size = self._code_cave_graph.nodes[x]['size']
                    path_size += x_size
                    if i < len(path) - 1:
                        path_size -= self._code_cave_graph.edges[x, path[i + 1]]['jump_len']
                if path_size > max_path_size:
                    max_path_size = path_size
                break_counter += 1
                if break_counter >= break_limit:
                    break

            if break_counter >= break_limit:
                break
        metrics['max_path_size'] = max_path_size
        return metrics

    def _is_nop(self, insn):
        if self._proj.arch.bits == 32:
            return self._is_nop32(insn)
        elif self._proj.arch.bits == 64:
            return self._is_nop64(insn)
        else:
            raise Exception("Expected project.arch.bits to be either 32 or 64")

    def _is_nop32(self, insn):
        mnem = insn.mnemonic
        if mnem == 'nop':
            return True
        # These two cases where discovered experimentally
        elif mnem == 'xchg':
            # Disassembles to: xchg ax,ax (used by GCC with -m32)
            return insn.bytes == b'\x66\x90'
        elif mnem == 'lea':
            # Disassembles to: lea    esi,[esi+eiz*1+0x0] (used by GCC with -m32)
            return insn.bytes == b'\x8d\xb4\x26\x00\x00\x00\x00'
        else:
            return False


    def _is_nop64(self, insn):
        return insn.mnemonic == 'nop'



def can_short_jump(code_cave_src, dst_addr):
    # Can we jump from the previous code cave to this code cave with a short jump?
    # Reqs:
    # 1. The previous code cave must be at least two bytes (a short jump is two bytes)
    # 2. The distance from the jump location in the previous code cave, to this code cave must be be between -126 and 129 (inclusive on both ends) (which is the farthest you can short jump)
    #    For a short jump, the jump location of the previous code will be the last two bytes.
    code_cave_src_addr, code_cave_src_size = code_cave_src
    code_cave_src_short_jmp_addr = code_cave_src_addr + code_cave_src_size - 2
    short_jmp_dist = dst_addr - code_cave_src_short_jmp_addr
    short_jumpable = (code_cave_src_size >= 2) and (-0x7e <= short_jmp_dist <= 0x81)
    return short_jumpable

def can_long_jump(code_cave_src, dst_addr):
    # Can we jump from the previous code cave to this code cave with a long jump?
    # Reqs:
    # 1. The previous code cave must be at least five bytes(a long jump is five bytes)
    # 2. The distance from the jump location in the previous code cave, to this code cave must be between -0xfffffffb and 0x100000004 (inclusive on both ends) which is the farthest you can long jump
    #    For a long jump, the jump location of the previous code cave will be the last five bytes
    code_cave_src_addr, code_cave_src_size = code_cave_src
    code_cave_src_long_jmp_addr = code_cave_src_addr + code_cave_src_size - 5
    long_jmp_dist = dst_addr - code_cave_src_long_jmp_addr
    long_jumpable = (code_cave_src_size >= 5) and (-0xfffffffb <= long_jmp_dist <= 0x100000004)
    return long_jumpable
