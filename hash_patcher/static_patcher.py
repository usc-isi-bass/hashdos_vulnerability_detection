import angr

from hash_patcher.interfunc_code_cave_miner import InterFuncCodeCaveMiner
from hash_patcher.code_cave_graph_patch_creator import CodeCaveGraphPatchCreator
from hash_patcher.patch_writer import PatchWriter
import util.binary_code_utils as bcu

import util.angr_util as angr_util


class StaticPatcher:

    def __init__(self, elf_file_name):
        self._proj = angr.Project(elf_file_name, auto_load_libs=False)
        self._cfg = self._proj.analyses.CFGFast()
        self._ifccm = InterFuncCodeCaveMiner(elf_file_name)
        self._code_cave_graph = self._ifccm.get_code_cave_graph()
        self._patch_writer = PatchWriter(self._proj)

    
    def hook_func(self, func_addr, patch_asm_insns):
        ccgpc = CodeCaveGraphPatchCreator(self._code_cave_graph, arch=self._proj.arch)
        fitted_patch = ccgpc.fit(patch_asm_insns, possible_start_caves=None)
        if fitted_patch is None:
            raise Exception("Could not add the patch code to the binary.")
        start_code_cave_addr, addr_to_patch_bin_insns_map = fitted_patch
        # Adding the fitted patch to the patch writer
        for insn_addr in addr_to_patch_bin_insns_map:
            patch_bin_insns = addr_to_patch_bin_insns_map[insn_addr]
            self._patch_writer.add_patch(insn_addr, patch_bin_insns)
        self.burn_code_caves(addr_to_patch_bin_insns_map.keys())
        # Patching the calls to the function
        call_sites_to = angr_util.get_call_sites_to(self._cfg, func_addr) 
        for call_site_to in call_sites_to:
            call_insn = angr_util.get_call_insn(self._cfg, call_site_to)
            call_insn_addr = call_insn.address

            call_patch_addr = call_insn_addr
            call_patch_offset = start_code_cave_addr - call_insn_addr
            call_patch_bytes = bcu.create_call(call_patch_offset)
            assert len(call_patch_bytes) == len(call_insn.bytes), "I thought calls are all the same length?"
            self._patch_writer.add_patch(call_patch_addr, call_patch_bytes)

    # Removes used code caves from the code_cave_graph
    # insns is a list of instruction addresses
    # I don't think we need the instructions or their sizes, because instructions should not span multiple code caves, right?
    def burn_code_caves(self, insn_addrs):
        to_burn = set()
        for code_cave_addr in self._code_cave_graph.nodes:
            code_cave_size = self._code_cave_graph.nodes[code_cave_addr]['size']
            for insn_addr in insn_addrs:
                if code_cave_addr <= insn_addr and insn_addr < code_cave_addr + code_cave_size:
                    to_burn.add(code_cave_addr)
        for code_cave_addr in to_burn:
            self._code_cave_graph.remove_node(code_cave_addr)

    def apply_patches(self, patched_elf_file_name):
        self._patch_writer.write_patches(patched_elf_file_name) 

