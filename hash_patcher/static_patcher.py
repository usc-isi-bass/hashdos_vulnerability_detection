import angr
import keystone

from hash_patcher.interfunc_code_cave_miner import InterFuncCodeCaveMiner
from hash_patcher.code_cave_graph_patch_creator import CodeCaveGraphPatchCreator
from hash_patcher.patch_writer import PatchWriter

import util.angr_util as angr_util


class StaticPatcher:

    def __init__(self, elf_file_name):
        self._proj = angr.Project(elf_file_name, auto_load_libs=False)
        if self._proj.arch.name != 'AMD64':
            raise Exception("At the moment we only handle patching for projects with architecture \"AMD64\"")
        self._cfg = self._proj.analyses.CFGFast(normalize=True)
        self._ifccm = InterFuncCodeCaveMiner(elf_file_name)
        self._code_cave_graph = self._ifccm.get_code_cave_graph()
        self._patch_writer = PatchWriter(self._proj)
        self._ks = keystone.Ks(self._proj.arch.ks_arch, self._proj.arch.ks_mode)


    def hook_func(self, func_addr, patch_asm_insns, patch_call_sites=False, patch_orig_func=True):
        code_cave_graph = self._code_cave_graph
        func = self._cfg.functions.function(addr=func_addr)
        if func is None:
            raise Exception('Could not find function at address 0x{:x} to hook.'.format(func_addr))
        func_size = func.size
        if patch_orig_func:
            # Convert the function into code caves
            code_cave_graph = code_cave_graph.copy()
            safe_to_patch = True
            # Confirm that every address from the function entry point to entry_point + size belongs to the function that we want to patch
            # (A safety measure so that we do not accidently remove something important)
            for addr in range(func_addr, func.size):
                cfg_node = self._cfg.model.get_any_node(addr=addr, anyaddr=True)
                addr_func_addr = cfg_node.function_address
                if addr_func_addr is not func_addr:
                    safe_to_patch = False
                    print("address 0x{:x} is in range 0x{:x} 0x{:x}+{} but belongs to function with address 0x{:x}".format(addr, func_addr, func_addr, func_size, addr_func_addr))
                    break
            if safe_to_patch:
                #code_cave_graph.add_node(func_addr, size=func_size)
                code_cave_graph.add_code_cave(func_addr, func_size)
        possible_start_caves = None
        if patch_orig_func:
            # If we patch the the original function,
            # then we have to start in the code cave created at the entry point
            # of the original function
            possible_start_caves = [(func_addr, func_size)]



        ccgpc = CodeCaveGraphPatchCreator(code_cave_graph, arch=self._proj.arch)
        fitted_patch = ccgpc.fit(patch_asm_insns, possible_start_caves=possible_start_caves)
        if fitted_patch is None:
            raise Exception("Could not add the patch code to the binary.")
        start_code_cave_addr, addr_to_patch_bin_insns_map = fitted_patch
        # Adding the fitted patch to the patch writer
        for insn_addr in addr_to_patch_bin_insns_map:
            patch_bin_insns = addr_to_patch_bin_insns_map[insn_addr]
            self._patch_writer.add_patch(insn_addr, patch_bin_insns)
        self.burn_code_caves(addr_to_patch_bin_insns_map.keys())
        if patch_call_sites:
            # Patching the calls to the function
            call_sites_to = angr_util.get_call_sites_to(self._cfg, func_addr)
            for call_site_to in call_sites_to:
                call_insn = angr_util.get_call_insn(self._cfg, call_site_to)
                call_insn_addr = call_insn.address

                call_patch_addr = call_insn_addr
                call_patch_offset = start_code_cave_addr - call_insn_addr
                call_patch_bytes = bytes(self._ks.asm("call {}".format(call_patch_offset))[0])
                assert len(call_patch_bytes) == len(call_insn.bytes), "I thought calls are all the same length?"
                self._patch_writer.add_patch(call_patch_addr, call_patch_bytes)
        #if patch_orig_func:
        #    # Overwrite the original function with a jump to the patch code
        #    func_block = self._proj.factory.block(addr=func_addr)
        #    call_patch_addr = func_addr
        #    call_patch_offset = start_code_cave_addr - func_addr
        #    call_patch_bytes = bytes(self._ks.asm("jmp {}".format(call_patch_offset))[0])
        #    if len(call_patch_bytes) > func_block.size:
        #        raise Exception("Cannot overwrite original function with a call. Not enough bytes: first block of func at 0x{:0x} contains {} bytes".format(func_addr, func_block.size))
        #    self._patch_writer.add_patch(call_patch_addr, call_patch_bytes)

    # Removes used code caves from the code_cave_graph
    # insns is a list of instruction addresses
    # I don't think we need the instructions or their sizes, because instructions should not span multiple code caves, right?
    def burn_code_caves(self, insn_addrs):
        to_burn = set()
        for code_cave_addr in self._code_cave_graph.nodes:
            code_cave_size = self._code_cave_graph.nodes[code_cave_addr]['size']
            for insn_addr in insn_addrs:
                if code_cave_addr <= insn_addr and insn_addr < code_cave_addr + code_cave_size:
                    to_burn.add(code_cave_addr)
        for code_cave_addr in to_burn:
            self._code_cave_graph.remove_node(code_cave_addr)

    def apply_patches(self, patched_elf_file_name):
        self._patch_writer.write_patches(patched_elf_file_name)

