import angr

from hash_patcher.hash_func_runner import HashFuncRunner

class HashFuncEvaluator:

    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        self._elf_file_name = elf_file_name
        self._hash_func_addr = hash_func_addr

        if proj is None:
            self._proj = angr.Project(self._elf_file_name, auto_load_libs=False)
        else:
            self._proj = proj
        self._hash_func_runner = HashFuncRunner(elf_file_name, hash_func_addr, proj=self._proj)


    def get_buf_reads(self, conc_buf):
        conc_buf_len = len(conc_buf)
        call_state, ret_state, ret_reg = self._hash_func_runner.run_conc(conc_buf)
        buf_addr = call_state.solver.eval(call_state.regs.rdi)

        state_history = ret_state.history
        actions = []
        for action in state_history.actions:
            if action.action == angr.state_plugins.SimActionData.READ:
                addr = ret_state.solver.eval(action.addr)
                data = ret_state.solver.eval(action.data)
                if buf_addr <= addr < buf_addr + conc_buf_len:
                    actions.append(action)
        return buf_addr, actions

    # Get memory reads external to the stack frame
    def get_ext_mem_reads(self, conc_buf):
        call_state, ret_state, ret_reg = self._hash_func_runner.run_conc(conc_buf)
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        call_state.regs.rbp = call_state.regs.rsp
        base_pointer = call_state.solver.eval(call_state.regs.rbp)

        state_history = ret_state.history
        actions = []
        for action in state_history.actions:
            if isinstance(action, angr.state_plugins.SimActionData) and action.action == angr.state_plugins.SimActionData.READ and action.type == angr.state_plugins.SimActionData.MEM:
                addr = ret_state.solver.eval(action.addr)
                if addr > stack_pointer or addr < stack_pointer - 0xff:
                    actions.append(action)
        return call_state, ret_state, actions
