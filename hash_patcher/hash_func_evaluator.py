import angr
import claripy
import math

from hash_patcher.hash_func_runner import HashFuncRunner

class HashFuncEvaluator(HashFuncRunner):

    # TODO Make signature sensitive
    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        super().__init__(elf_file_name, hash_func_addr, proj)

    def find_preimage(self, hash_val):
        for symbstr_len in range(1, 26):
            solver = claripy.Solver()

            symbstr, rets = self.run_symb(symbstr_len)

            ret_states_constraints = False
            for ret_state, ret_val in rets:
                ret_state_constraints = claripy.And(ret_val == hash_val, *ret_state.solver.constraints)
                ret_states_constraints = claripy.Or(ret_state_constraints, ret_states_constraints)
                solver.add(ret_states_constraints)
            sat = solver.check_satisfiability()
            if sat == 'SAT':
                preimage_int = solver.eval(symbstr, 1)[0]
                preimage_int_byte_length = int(math.ceil(preimage_int.bit_length() / 8))
                preimage = preimage_int.to_bytes(preimage_int_byte_length, 'big')
                print(symbstr_len)
                print(preimage_int)
                return preimage
        return None


    def evaluate_ext_mem_refs(self, conc_buf, read_addr_whitelist=None):
        hash_func_irregularities = []

        conc_buf_len = len(conc_buf)
        # Find all external memory references (outside of stack frame)
        call_state, ret_state, actions = self.get_ext_mem_refs(conc_buf)
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        for action in actions:
            ref_addr = call_state.solver.eval(action.addr.to_claripy())
            ref_size = call_state.solver.eval(action.size.to_claripy())
            ref_size_bytes = ref_size // 8
            # Hash function should not write outside of its stack
            if action.action == angr.state_plugins.SimActionData.WRITE:
                irregularity = HashFuncExternalMemWrite(conc_buf, conc_buf_addr, stack_pointer, ref_addr, ref_size, action)
                hash_func_irregularities.append(irregularity)
                continue
            else:
                assert action.action == angr.state_plugins.SimActionData.READ, "Logic error, not a read or a write: {}".format(action.action)
                read_addr, read_size, read_size_bytes = ref_addr, ref_size, ref_size_bytes

                if read_addr_whitelist is None:
                    # Make sure the read occurs within the bounds of the buffer
                    if read_addr < conc_buf_addr:
                        # report irregularity
                        irregularity = HashFuncExternalMemRead(conc_buf, conc_buf_addr, stack_pointer, read_addr, read_size, read_addr_whitelist, action)
                        hash_func_irregularities.append(irregularity)
                        continue
                    # TODO Update this to be signature sensitive. A hash func that receives the length does not need to access the \0 byte
                    if read_addr + read_size_bytes > conc_buf_addr + conc_buf_len + 1:
                        # report irregularity
                        irregularity = HashFuncExternalMemRead(conc_buf, conc_buf_addr, stack_pointer, read_addr, read_size, read_addr_whitelist, action)
                        hash_func_irregularities.append(irregularity)
                        continue
                else:
                    if not read_addr in read_addr_whitelist:
                        # report irregularity
                        irregularity = HashFuncExternalMemRead(conc_buf, conc_buf_addr, stack_pointer, read_addr, read_size, read_addr_whitelist, action)
                        hash_func_irregularities.append(irregularity)
                        continue
        return hash_func_irregularities


    def get_buf_reads(self, conc_buf):
        conc_buf_len = len(conc_buf)
        call_state, ret_state, ret_reg = self.run_conc(conc_buf)
        buf_addr = call_state.solver.eval(call_state.regs.rdi)

        state_history = ret_state.history
        actions = []
        for action in state_history.actions:
            if action.action == angr.state_plugins.SimActionData.READ:
                addr = ret_state.solver.eval(action.addr)
                data = ret_state.solver.eval(action.data)
                if buf_addr <= addr < buf_addr + conc_buf_len:
                    actions.append(action)
        return buf_addr, actions

    # Get memory reads external to the stack frame
    def get_ext_mem_refs(self, conc_buf):
        call_state, ret_state, ret_reg = self.run_conc(conc_buf)
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        call_state.regs.rbp = call_state.regs.rsp
        base_pointer = call_state.solver.eval(call_state.regs.rbp)

        state_history = ret_state.history
        actions = []
        for action in state_history.actions:
            if isinstance(action, angr.state_plugins.SimActionData) and action.type == angr.state_plugins.SimActionData.MEM:
                addr = ret_state.solver.eval(action.addr)
                if addr > stack_pointer or addr < stack_pointer - 0xff:
                    actions.append(action)
        return call_state, ret_state, actions

class HashFuncIrregularity:

    def __init__(self, irregularity_type):
        self.irregularity_type = irregularity_type

class HashFuncExternalMemWrite(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, write_addr, write_size, action):
        super().__init__('external_memwrite')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.write_addr = write_addr
        self.write_size = write_size
        self.action = action

class HashFuncExternalMemRead(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, read_addr, read_size, read_whitelist, action):
        super().__init__('external_memread')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.read_addr = read_addr
        self.read_size = read_size
        self.read_whitelist = read_whitelist
        self.action = action

    def __str__(self):
        return "<HashFuncExternalMemRead buf: {}@0x{:x} stack_ptr: 0x{:x} read_addr: 0x{:x} read_size: {} read_whitelist: {} action: {}>".format(self.buf, self.buf_addr, self.stack_ptr, self.read_addr, self.read_size, self.read_whitelist, self.action)


