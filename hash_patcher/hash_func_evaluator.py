import abc
from abc import ABC

import angr
import claripy
import math

from hash_patcher.hash_func_runner import HashFuncRunner,HashFuncRunnerSig1,HashFuncRunnerSig2
from hash_patcher.hash_func_runner import CONC_BUFF_ADDR

import util.angr_util as angr_util

class HashFuncEvaluator(HashFuncRunner):

    @abc.abstractmethod
    def eval(self, conc_buf, conc_buf_len):
        '''
        Signature agnostic method for eval
        '''
        raise NotImplementedError()

    # TODO Make this user controllable
    def find_preimage(self, hash_val):
        for symbstr_len in range(1, 11):
            solver = claripy.Solver()

            symbstr_addr, symbstr, ret_states = self.run_symb(symbstr_len, null_terminate=True)

            ret_states_constraints = False
            for ret_state in ret_states:
                ret_val = angr_util.get_ret_reg(self._proj, ret_state)
                ret_state_constraints = claripy.And(ret_val == hash_val, *ret_state.solver.constraints)
                ret_states_constraints = claripy.Or(ret_state_constraints, ret_states_constraints)
            solver.add(ret_states_constraints)
            sat = solver.check_satisfiability()
            if sat == 'SAT':
                preimage_int = solver.eval(symbstr, 1)[0]
                preimage_int_byte_length = int(math.ceil(preimage_int.bit_length() / 8))
                preimage = preimage_int.to_bytes(preimage_int_byte_length, 'big')
                assert preimage[-1] == '\x00' or preimage[-1] == 0, "preimage: {}".format(preimage)
                preimage = preimage[:-1]
                return preimage
        return None

    @abc.abstractmethod
    def evaluate_sig(self):
        raise NotImplementedError()

    @abc.abstractmethod
    def evaluate_ext_mem_refs(self, conc_buf, conc_buf_len, read_addr_whitelist=None):
        raise NotImplementedError()

    @abc.abstractmethod
    def get_ext_mem_refs(self, conc_buf, conc_buf_len):
        raise NotImplementedError()





    def _evaluate_ext_mem_refs(self, call_state, ret_states, read_addr_whitelist):
        hash_func_irregularities = []

        ret_state_action_pairs = self._get_ext_mem_refs(call_state, ret_states)
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        conc_buf = call_state.mem[conc_buf_addr].string.concrete
        read_addrs = set()
        for ret_state, action in ret_state_action_pairs:
            ref_addr = ret_state.solver.eval(action.addr.to_claripy())
            ref_size = ret_state.solver.eval(action.size.to_claripy())
            ref_size_bytes = ref_size // 8
            # Hash function should not write outside of its stack
            if action.action == angr.state_plugins.SimActionData.WRITE:
                irregularity = HashFuncExternalMemWrite(conc_buf, conc_buf_addr, stack_pointer, ref_addr, ref_size, action)
                hash_func_irregularities.append(irregularity)
                continue
            else:
                assert action.action == angr.state_plugins.SimActionData.READ, "Logic error: not a read or a write: {}".format(action.action)
                read_addr, read_size, read_size_bytes = ref_addr, ref_size, ref_size_bytes
                if read_addr in read_addr_whitelist:
                    read_addrs.add(read_addr)
                else:
                    # report irregularity
                    irregularity = HashFuncExternalMemRead(conc_buf, conc_buf_addr, stack_pointer, read_addr, read_size, read_addr_whitelist, action)
                    hash_func_irregularities.append(irregularity)
                    continue
        # Check if all addrs in whitelist were read from
        if len(read_addrs) != len(read_addr_whitelist):
            assert len(read_addrs) < len(read_addr_whitelist), "Logic error: we are only add addrs to read_addrs if they are also in read_addr_whitelist, but now read_addrs is larger?"
            unread_addrs = read_addr_whitelist.difference(read_addrs)
            irregularity = HashFuncUnreadMem(conc_buf, conc_buf_addr, unread_addrs, read_addr_whitelist, action)
            hash_func_irregularities.append(irregularity)


        return ret_state_action_pairs, hash_func_irregularities

    def get_buf_reads(self, buf_addr_name, call_state, ret_states):
        read_addrs = set([])
        ret_state_action_pairs = self._get_ext_mem_refs(call_state, ret_states)
        for ret_state, action in ret_state_action_pairs:
            if action.action == angr.state_plugins.SimActionData.READ:
                symbolic_addr = action.addr
                symbolic_size = action.size
                if buf_addr_name in symbolic_addr.variables:
                    addr = ret_state.solver.eval(symbolic_addr.to_claripy())
                    size_bits = ret_state.solver.eval(symbolic_size.to_claripy())
                    size_bytes = size_bits // 8
                    read_addrs.update(range(addr, addr + size_bytes))
        return read_addrs

    # Get memory reads external to the stack frame
    def _get_ext_mem_refs(self, call_state, ret_states):
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        call_state.regs.rbp = call_state.regs.rsp
        base_pointer = call_state.solver.eval(call_state.regs.rbp)

        ret_state_action_pairs = []
        for ret_state in ret_states:
            state_history = ret_state.history
            for action in state_history.actions:
                if isinstance(action, angr.state_plugins.SimActionData) and action.type == angr.state_plugins.SimActionData.MEM:
                    addr = ret_state.solver.eval(action.addr)
                    if addr > stack_pointer or addr < stack_pointer - 0xff:
                        ret_state_action_pairs.append((ret_state, action))
        return ret_state_action_pairs

class HashFuncEvaluatorSig1(HashFuncEvaluator,HashFuncRunnerSig1):
    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        super().__init__(elf_file_name, hash_func_addr, proj)

    def eval(self, conc_buf, conc_buf_len):
        # TODO Is there a more correct way to do this?
        return HashFuncRunnerSig1.eval(self, conc_buf, conc_buf_len)

    def evaluate_ext_mem_refs(self, conc_buf, conc_buf_len, read_addr_whitelist=None):
        call_state, ret_state = self.run_conc(conc_buf, conc_buf_len)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        if read_addr_whitelist is None:
            read_addr_whitelist = range(conc_buf_addr, conc_buf_addr + conc_buf_len) # signature 1 should not dereference the \0 byte
        return self._evaluate_ext_mem_refs(call_state, [ret_state], read_addr_whitelist)

    def get_ext_mem_refs(self, conc_buf, conc_buf_len):
        call_state, ret_state = self.run_conc(conc_buf, conc_buf_len)
        return self._get_ext_mem_refs(call_state, [ret_state])

        # Try to determine if the hash function works on a buffer and its length as input
    # We create a long buffer and tell the hash function its a short buffer of length l (via the second argument)
    # If the hash function only dereferences l addresses of the buffer, we know its looking at the second argument for the length
    # Right?
    def evaluate_sig(self):
        given_len = 4 # We give this length as input to the hash function
        actual_len = given_len * 2 # We create a longer buffer
        symbstr_addr_name = 'str_addr'
        symbstr_name = 'str'
        symbstr_addr, symbstr = self.create_symbstr(symbstr_addr_name, symbstr_name, actual_len)
        call_state = self._proj.factory.call_state(self._hash_func_addr, symbstr_addr, given_len, add_options=[angr.options.TRACK_MEMORY_ACTIONS])

        self.store_symbstr(call_state, symbstr_addr, symbstr, null_terminate=True, none_null=True)

        ret_states = self.trace_hash_func(call_state, n=128) # We give a value for n, because if we've got the signature completely wrong, we need to stop symex somehow

        read_addrs = self.get_buf_reads(symbstr_addr_name, call_state, ret_states)

        # If the hash function is signature 1, then it will only read given_len bytes from the start buffer address
        expected_read_addrs = set(range(CONC_BUFF_ADDR, CONC_BUFF_ADDR + given_len))
        return read_addrs == expected_read_addrs

class HashFuncEvaluatorSig2(HashFuncEvaluator,HashFuncRunnerSig2):
    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        super().__init__(elf_file_name, hash_func_addr, proj)

    def eval(self, conc_buf, conc_buf_len):
        # TODO Is there a more correct way to do this?
        return HashFuncRunnerSig2.eval(self, conc_buf)

    def evaluate_ext_mem_refs(self, conc_buf, conc_buf_len, read_addr_whitelist=None):
        # We know what the buffer length is, but the hash function will have to determine it itself
        call_state, ret_state = self.run_conc(conc_buf)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        if read_addr_whitelist is None:
            read_addr_whitelist = range(conc_buf_addr, conc_buf_addr + conc_buf_len + 1) # signature 2 should dereference the \0 byte (to detect the end of the buffer)
        return self._evaluate_ext_mem_refs(call_state, [ret_state], read_addr_whitelist)

    def get_ext_mem_refs(self, conc_buf, conc_buf_len):
        call_state, ret_state = self.run_conc(conc_buf)
        return self._get_ext_mem_refs(call_state, [ret_state])


        # Try to determine if the hash function calculates the length from the buffer itself (by reading \0)
    # We create a long buffer and place \0 in the middel (at index l)
    # If the hash function only dereferences l + 1 addresses of the buffer, we know it stops after discovering the \0
    # Right?
    def evaluate_sig(self):
        given_len = 4 # the number of bytes before \0
        actual_len = given_len * 2 # We create a longer buffer
        symbstr_addr_name = 'str_addr'
        symbstr_name = 'str'
        symbstr_addr, symbstr = self.create_symbstr(symbstr_addr_name, symbstr_name, actual_len)
        call_state = self._proj.factory.call_state(self._hash_func_addr, symbstr_addr, actual_len, add_options=[angr.options.TRACK_MEMORY_ACTIONS]) # We give it a second parameter incase its sig1 (Note in this case we give it the actual length, because we're testing for sig2. If its truely sig2, the actual_len parameter will be ignored)

        # Only the byte at given_len must be 0
        symbstr_constraints = lambda v, i : v == 0 if i == given_len else v != 0
        self.store_symbstr(call_state, symbstr_addr, symbstr, null_terminate=False, none_null=False, symbstr_constraints=symbstr_constraints)
        ret_states = self.trace_hash_func(call_state, n=128) # We set a value for n, because if we've got the signature wrong, we need to stop symex somehow

        read_addrs = self.get_buf_reads(symbstr_addr_name, call_state, ret_states)

        # If the hash function is signature 1, then it will only read (given_len + 1) bytes from the start buffer address (+1 to see the \0)
        expected_read_addrs = set(range(CONC_BUFF_ADDR, CONC_BUFF_ADDR + given_len + 1))
        return read_addrs == expected_read_addrs


class HashFuncIrregularity:

    def __init__(self, irregularity_type):
        self.irregularity_type = irregularity_type

class HashFuncExternalMemWrite(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, write_addr, write_size, action):
        super().__init__('external_memwrite')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.write_addr = write_addr
        self.write_size = write_size
        self.action = action

class HashFuncExternalMemRead(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, read_addr, read_size, read_whitelist, action):
        super().__init__('external_memread')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.read_addr = read_addr
        self.read_size = read_size
        self.read_whitelist = read_whitelist
        self.action = action

    def __str__(self):
        return "<HashFuncExternalMemRead buf: {}@0x{:x} stack_ptr: 0x{:x} read_addr: 0x{:x} read_size: {} read_whitelist: {} action: {}>".format(self.buf, self.buf_addr, self.stack_ptr, self.read_addr, self.read_size, self.read_whitelist, self.action)

class HashFuncUnreadMem(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, unread_addrs, read_whitelist, action):
        self.buf = buf
        self.buf_addr = buf_addr
        self.unread_addrs = unread_addrs
        self.read_whitelist = read_whitelist
        self.action = action

    def __str__(self):
        return "<HashFuncUnreadMem buf: {}@0x{:x} unread_addrs: {} read_whitelist: {} action: {}>".format(self.buf, self.buf_addr, self.unread_addrs, self.read_whitelist, self.action)


