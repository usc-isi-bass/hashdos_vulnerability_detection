import abc
from abc import ABC

import angr
import claripy
import math

from hash_patcher.hash_func_runner import HashFuncRunner,HashFuncRunnerSig1,HashFuncRunnerSig2
from hash_patcher.hash_func_runner import CONC_BUFF_ADDR

import util.angr_util as angr_util

class HashFuncEvaluator(HashFuncRunner):

    @abc.abstractmethod
    def eval(self, conc_buf, conc_buf_len):
        '''
        Signature agnostic method for eval
        '''
        raise NotImplementedError()

    # TODO Make this user controllable
    def find_preimage(self, hash_val):
        for symbstr_len in range(1, 9):
            solver = claripy.Solver()

            symbstr_addr, symbstr, ret_states = self.run_symb(symbstr_len, non_null=False, null_terminate=True)

            ret_states_constraints = False
            for ret_state in ret_states:
                ret_val = angr_util.get_ret_reg(self._proj, ret_state)
                ret_state_constraints = claripy.And(ret_val == hash_val, *ret_state.solver.constraints)
                ret_states_constraints = claripy.Or(ret_state_constraints, ret_states_constraints)
            solver.add(ret_states_constraints)
            sat = solver.check_satisfiability()
            if sat == 'SAT':
                preimage_int = solver.eval(symbstr, 1)[0]
                preimage_int_byte_length = int(math.ceil(preimage_int.bit_length() / 8))
                preimage = preimage_int.to_bytes(preimage_int_byte_length, 'big')
                assert preimage[-1] == '\x00' or preimage[-1] == 0, "preimage: {}".format(preimage)
                preimage = preimage[:-1]
                return preimage
        return None

    @abc.abstractmethod
    def evaluate_conc(self, conc_buf, conc_buf_len):
        '''
        Confirm that concrete input will yield a concrete return value
        '''
        raise NotImplementedError()

    @abc.abstractmethod
    def evaluate_sig(self):
        '''
        Confirm that the signature is correct.
        '''
        raise NotImplementedError()

    @abc.abstractmethod
    def evaluate_ext_mem_refs(self, conc_buf, conc_buf_len, read_addr_whitelist=None):
        '''
        Confirm that the external memory references (nonstack) are only reads from the whitelist or the buffer (if the whitelist is None)
        '''
        raise NotImplementedError()

    @abc.abstractmethod
    def get_ext_mem_refs(self, conc_buf, conc_buf_len):
        '''
        Get the external memory references (nonstack)
        '''
        raise NotImplementedError()



    def _evaluate_conc(self, call_state, ret_state):
        ret_val = angr_util.get_ret_reg(self._proj, ret_state)
        if ret_val.symbolic:
            conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
            conc_buf = call_state.mem[conc_buf_addr].string.concrete
            return [HashFuncSymbolicRet(conc_buf, ret_val)]
        return []




    def _evaluate_ext_mem_refs(self, call_state, ret_states, read_addr_whitelist):
        hash_func_irregularities = []

        ret_state_action_pairs = self._get_ext_mem_refs(call_state, ret_states)
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        conc_buf = call_state.mem[conc_buf_addr].string.concrete
        read_addrs = set()
        for ret_state, action in ret_state_action_pairs:
            ref_addr = ret_state.solver.eval(action.addr.to_claripy())
            ref_size = ret_state.solver.eval(action.size.to_claripy())
            ref_size_bytes = ref_size // 8
            # Hash function should not write outside of its stack
            if action.action == angr.state_plugins.SimActionData.WRITE:
                irregularity = HashFuncExternalMemWrite(conc_buf, conc_buf_addr, stack_pointer, ref_addr, ref_size, action.ins_addr)
                hash_func_irregularities.append(irregularity)
                continue
            else:
                assert action.action == angr.state_plugins.SimActionData.READ, "Logic error: not a read or a write: {}".format(action.action)
                read_addr_base, read_size, read_size_bytes = ref_addr, ref_size, ref_size_bytes
                nonwhitelist_read = False
                for read_addr in range(read_addr_base, read_addr_base + read_size // 8):
                    if read_addr in read_addr_whitelist:
                        read_addrs.add(read_addr)
                    else:
                        nonwhitelist_read = True
                # report irregularity
                if nonwhitelist_read:
                    irregularity = HashFuncExternalMemRead(conc_buf, conc_buf_addr, stack_pointer, read_addr_base, read_size, read_addr_whitelist, action.ins_addr)
                    hash_func_irregularities.append(irregularity)
        # Check if all addrs in whitelist were read from
        if len(read_addrs) != len(read_addr_whitelist):
            assert len(read_addrs) < len(read_addr_whitelist), "Logic error: we are only add addrs to read_addrs if they are also in read_addr_whitelist, but now read_addrs is larger?"
            unread_addrs = read_addr_whitelist.difference(read_addrs)
            irregularity = HashFuncUnreadMem(conc_buf, conc_buf_addr, unread_addrs, read_addr_whitelist)
            hash_func_irregularities.append(irregularity)


        return ret_state_action_pairs, hash_func_irregularities

    def get_buf_reads(self, buf_addr_name, call_state, ret_states):
        read_addrs = set([])
        ret_state_action_pairs = self._get_ext_mem_refs(call_state, ret_states)
        for ret_state, action in ret_state_action_pairs:
            if action.action == angr.state_plugins.SimActionData.READ:
                symbolic_addr = action.addr
                symbolic_size = action.size
                if buf_addr_name in symbolic_addr.variables:
                    addr = ret_state.solver.eval(symbolic_addr.to_claripy())
                    size_bits = ret_state.solver.eval(symbolic_size.to_claripy())
                    size_bytes = size_bits // 8
                    #print('buf read: {} isn addr: {}'.format(addr, action.ins_addr))
                    read_addrs.update(range(addr, addr + size_bytes))
        return read_addrs

    # Get memory reads external to the stack frame
    def _get_ext_mem_refs(self, call_state, ret_states):
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        call_state.regs.rbp = call_state.regs.rsp
        base_pointer = call_state.solver.eval(call_state.regs.rbp)

        ret_state_action_pairs = []
        for ret_state in ret_states:
            state_history = ret_state.history
            for action in state_history.actions:
                if isinstance(action, angr.state_plugins.SimActionData) and action.type == angr.state_plugins.SimActionData.MEM:
                    addr = ret_state.solver.eval(action.addr)
                    if addr > stack_pointer or addr < stack_pointer - 0xff:
                        ret_state_action_pairs.append((ret_state, action))
        return ret_state_action_pairs

    def evaluate_hash_func_uses(self, cfg, block_symex_upperbound):
        hash_func_uses = []
        hash_func = cfg.functions.function(self._hash_func_addr)
        hash_func_contexts = self.get_func_contexts(cfg, hash_func)
        for hash_func, hash_func_caller, hash_func_call_site, hash_func_ret_site in hash_func_contexts:
            mem_read_hash_deps = []
            mem_write_hash_deps = []
            file_seek_hash_deps = []

            hash_func_use = HashFuncUse(hash_func_caller.name, hash_func_call_site, hash_func_ret_site, mem_read_hash_deps, mem_write_hash_deps, file_seek_hash_deps)
            # A break point for memory reads. Flag if the address being read from depends on the hash return value.
            def mem_read_break(state):
                try:
                    read_addr = state.inspect.mem_read_address
                    if angr_util.symbolic_var_depends_on_varname(read_addr, 'hash_ret_val'):
                        mem_read_hash_deps.append(state.addr)
                        #l.debug("Mem read: state Addr: 0x{:x} read addr: {}".format(state.addr, read_addr))
                except Exception as e:
                    #print("Err: {}".format(str(e)), file=sys.stderr)
                    results.add_err(str(e))
                    #raise e
            # A break point for memory writes. Flag if the address being written to depends on the hash return value.
            def mem_write_break(state):
                try:
                    write_addr = state.inspect.mem_write_address
                    if angr_util.symbolic_var_depends_on_varname(write_addr, 'hash_ret_val'):
                        mem_write_hash_deps.append(state.addr)
                        #l.debug("Mem write: state Addr: 0x{:x} read addr: {}".format(state.addr, write_addr))

                except Exception as e:
                    #print("Err: {}".format(str(e)), file=sys.stderr)
                    results.add_err(str(e))
                    #raise e

            class FseekHook(angr.SimProcedure):
                def run(self, stream, offset, origin):
                    try:
                        if angr_util.symbolic_var_depends_on_varname(offset, 'hash_ret_val'):
                            # state.addr is in the library the predecessor is in the PLT and the next predecessor is the call site we want
                            call_site = list(self.state.history.lineage)[-3]
                            #l.debug("Fseek: state Addr: 0x{:x} offset: {}".format(call_site.addr, offset))
                            file_seek_hash_deps.append(call_site.addr)

                    except Exception as e:
                        #print("Err: {}".format(str(e)), file=sys.stderr)
                        results.add_err(str(e))
                        #raise e
            class LseekHook(angr.SimProcedure):
                def run(self, fd, offset, whence):
                    try:
                        if angr_util.symbolic_var_depends_on_varname(offset, 'hash_ret_val'):
                            # state.addr is in the library the predecessor is in the PLT and the next predecessor is the call site we want
                            call_site = list(self.state.history.lineage)[-3]
                            #l.debug("Lseek: state Addr: 0x{:x} offset: {}".format(call_site.addr, offset))
                            file_seek_hash_deps.append(call_site.addr)

                    except Exception as e:
                        #print("Err: {}".format(str(e)), file=sys.stderr)
                        results.add_err(str(e))
                        #raise e

            return_state = self._proj.factory.blank_state(addr=hash_func_ret_site)
            return_state.inspect.b('mem_read', when=angr.BP_BEFORE, action=mem_read_break)
            return_state.inspect.b('mem_write', when=angr.BP_BEFORE, action=mem_write_break)
            self._proj.hook_symbol('fseek', FseekHook())
            self._proj.hook_symbol('lseek', LseekHook())
            hash_return_val = claripy.BVS('hash_ret_val', size=self._proj.arch.bits)
            angr_util.set_state_ret_reg(self._proj, return_state, hash_return_val)
            return_state.add_constraints(hash_return_val == 0) # Makes it a bit faster... we may assume the hash function returns 0 right?
            simgr = self._proj.factory.simulation_manager(return_state)
            for i in range(block_symex_upperbound):
                if len(simgr.active) <= 0:
                    break
                simgr.step()
            self._proj.unhook_symbol('fseek')
            self._proj.unhook_symbol('lseek')
            hash_func_uses.append(hash_func_use)
        return hash_func_uses

    # Returns a set of tuples, each containing (called_func, calling_func, called_func_call_site (in calling_func), called_func_ret_site (in calling_func))
    # calling_func is the function calling called_func
    # called_func_call_site is the call site of called_func in calling_func
    # called_func_ret_site is the site to which the call_site returns
    def get_func_contexts(self, cfg, called_func):
        contexts = set()
        callgraph = cfg.functions.callgraph
        called_func_addr = called_func.addr
        called_func_pred_addrs = callgraph.predecessors(called_func_addr)
        for called_func_pred_addr in called_func_pred_addrs:
            called_func_pred_node = cfg.model.get_any_node(called_func_pred_addr)
            called_func_pred_func_addr = called_func_pred_node.function_address
            calling_func = cfg.functions.function(called_func_pred_func_addr)
            if calling_func is None:
                #l.error("Could not find calling function of called function {} at address 0x{:x}".format(called_func.name, func_pred_addr))
                continue

            # Find the return sites of the called function
            called_func_call_sites = angr_util.get_func_call_sites_for(calling_func, called_func)
            for called_func_call_site in called_func_call_sites:
                called_func_ret_site = calling_func.get_call_return(called_func_call_site)
                contexts.add((called_func, calling_func, called_func_call_site, called_func_ret_site))
        return contexts




class HashFuncEvaluatorSig1(HashFuncEvaluator,HashFuncRunnerSig1):
    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        super().__init__(elf_file_name, hash_func_addr, proj)

    def eval(self, conc_buf, conc_buf_len):
        # TODO Is there a more correct way to do this?
        return HashFuncRunnerSig1.eval(self, conc_buf, conc_buf_len)

    def evaluate_conc(self, conc_buf, conc_buf_len):
        call_state, ret_state = self.run_conc(conc_buf, conc_buf_len)
        return self._evaluate_conc(call_state, ret_state)

    def evaluate_ext_mem_refs(self, conc_buf, conc_buf_len, read_addr_whitelist=None):
        call_state, ret_state = self.run_conc(conc_buf, conc_buf_len)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        if read_addr_whitelist is None:
            read_addr_whitelist = range(conc_buf_addr, conc_buf_addr + conc_buf_len) # signature 1 should not dereference the \0 byte
        return self._evaluate_ext_mem_refs(call_state, [ret_state], read_addr_whitelist)

    def get_ext_mem_refs(self, conc_buf, conc_buf_len):
        call_state, ret_state = self.run_conc(conc_buf, conc_buf_len)
        return self._get_ext_mem_refs(call_state, [ret_state])

        # Try to determine if the hash function works on a buffer and its length as input
    # We create a long buffer and tell the hash function its a short buffer of length l (via the second argument)
    # If the hash function only dereferences l addresses of the buffer, we know its looking at the second argument for the length
    # Right?
    def evaluate_sig(self):
        given_len = 4 # We give this length as input to the hash function
        actual_len = given_len * 2 # We create a longer buffer
        symbstr_addr_name = 'str_addr'
        symbstr_name = 'str'
        symbstr_addr, symbstr = self.create_symbstr(symbstr_addr_name, symbstr_name, actual_len)
        # The MEMORY_CUNK_INDIVIDUAL_READS is necessary so that we do not read more than required
        call_state = self._proj.factory.call_state(self._hash_func_addr, symbstr_addr, given_len, add_options=[angr.options.TRACK_MEMORY_ACTIONS, angr.options.MEMORY_CHUNK_INDIVIDUAL_READS])

        self.store_symbstr(call_state, symbstr_addr, symbstr, null_terminate=True, non_null=True)

        ret_states = self.trace_hash_func(call_state, n=20) # We give a value for n, because if we've got the signature completely wrong, we need to stop symex somehow

        read_addrs = self.get_buf_reads(symbstr_addr_name, call_state, ret_states)

        # If the hash function is signature 1, then it will only read given_len bytes from the start buffer address
        expected_read_addrs = set(range(CONC_BUFF_ADDR, CONC_BUFF_ADDR + given_len))
        #print("sig1: read: {} exp: {}".format(read_addrs, expected_read_addrs))
        return read_addrs == expected_read_addrs

class HashFuncEvaluatorSig2(HashFuncEvaluator,HashFuncRunnerSig2):
    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        super().__init__(elf_file_name, hash_func_addr, proj)

    def eval(self, conc_buf, conc_buf_len):
        # TODO Is there a more correct way to do this?
        return HashFuncRunnerSig2.eval(self, conc_buf)

    def evaluate_conc(self, conc_buf, conc_buf_len):
        call_state, ret_state = self.run_conc(conc_buf)
        return self._evaluate_conc(call_state, ret_state)

    def evaluate_ext_mem_refs(self, conc_buf, conc_buf_len, read_addr_whitelist=None):
        # We know what the buffer length is, but the hash function will have to determine it itself
        call_state, ret_state = self.run_conc(conc_buf)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        if read_addr_whitelist is None:
            read_addr_whitelist = range(conc_buf_addr, conc_buf_addr + conc_buf_len + 1) # signature 2 should dereference the \0 byte (to detect the end of the buffer)
        return self._evaluate_ext_mem_refs(call_state, [ret_state], read_addr_whitelist)

    def get_ext_mem_refs(self, conc_buf, conc_buf_len):
        call_state, ret_state = self.run_conc(conc_buf)
        return self._get_ext_mem_refs(call_state, [ret_state])


        # Try to determine if the hash function calculates the length from the buffer itself (by reading \0)
    # We create a long buffer and place \0 in the middel (at index l)
    # If the hash function only dereferences l + 1 addresses of the buffer, we know it stops after discovering the \0
    # Right?
    def evaluate_sig(self):
        given_len = 4 # the number of bytes before \0
        actual_len = given_len * 2 # We create a longer buffer
        symbstr_addr_name = 'str_addr'
        symbstr_name = 'str'
        symbstr_addr, symbstr = self.create_symbstr(symbstr_addr_name, symbstr_name, actual_len)
        # We give it a second parameter incase its sig1 (Note in this case we give it the actual length, because we're testing for sig2. If its truely sig2, the actual_len parameter will be ignored)
        # The MEMORY_CUNK_INDIVIDUAL_READS is necessary so that we do not read more than required
        call_state = self._proj.factory.call_state(self._hash_func_addr, symbstr_addr, actual_len, add_options=[angr.options.TRACK_MEMORY_ACTIONS, angr.options.MEMORY_CHUNK_INDIVIDUAL_READS])

        # Only the byte at given_len must be 0
        symbstr_constraints = lambda v, i : v == 0 if i == given_len else v != 0
        self.store_symbstr(call_state, symbstr_addr, symbstr, null_terminate=False, non_null=False, symbstr_constraints=symbstr_constraints)
        # This is necessary because the simprocs for stuff like strlen search for a \0
        call_state.memory.store(symbstr_addr + given_len, 0)
        ret_states = self.trace_hash_func(call_state, n=50) # We set a value for n, because if we've got the signature wrong, we need to stop symex somehow

        read_addrs = self.get_buf_reads(symbstr_addr_name, call_state, ret_states)

        # If the hash function is signature 1, then it will only read (given_len + 1) bytes from the start buffer address (+1 to see the \0)
        expected_read_addrs = set(range(CONC_BUFF_ADDR, CONC_BUFF_ADDR + given_len + 1))
        #print("sig2: read: {} exp: {}".format(read_addrs, expected_read_addrs))
        return read_addrs == expected_read_addrs


class HashFuncIrregularity:

    def __init__(self, irregularity_type):
        self.irregularity_type = irregularity_type

class HashFuncExternalMemWrite(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, write_addr, write_size, insn_addr):
        super().__init__('external_memwrite')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.write_addr = write_addr
        self.write_size = write_size
        self.insn_addr = insn_addr

class HashFuncExternalMemRead(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, read_addr, read_size, read_whitelist, insn_addr):
        super().__init__('external_memread')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.read_addr = read_addr
        self.read_size = read_size
        self.read_whitelist = read_whitelist
        self.insn_addr = insn_addr

    def __str__(self):
        return "<HashFuncExternalMemRead buf: {}@0x{:x} stack_ptr: 0x{:x} read_addr: 0x{:x} read_size: {} read_whitelist: {} insn_addr: 0x{:x}>".format(self.buf, self.buf_addr, self.stack_ptr, self.read_addr, self.read_size, self.read_whitelist, self.insn_addr)

class HashFuncUnreadMem(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, unread_addrs, read_whitelist):
        super().__init__('unreadmem')
        self.buf = buf
        self.buf_addr = buf_addr
        self.unread_addrs = unread_addrs
        self.read_whitelist = read_whitelist

    def __str__(self):
        return "<HashFuncUnreadMem buf: {}@0x{:x} unread_addrs: {} read_whitelist: {}>".format(self.buf, self.buf_addr, self.unread_addrs, self.read_whitelist)

class HashFuncSymbolicRet(HashFuncIrregularity):

    def __init__(self, conc_buf, hash_val):
        super().__init__('symbolicret')
        self.conc_buf = conc_buf
        self.hash_val = hash_val

    def __str__(self):
        return "<HashFuncSymbolicRet conc_buf: {} hash_val: {}>".format(self.conc_buf, self.hash_val)

class HashFuncUse():
    def __init__(self, caller, call_site, ret_site, reads, writes, seeks):
        self.caller = caller
        self.call_site = call_site
        self.ret_site = ret_site
        self.reads = reads
        self.writes = writes
        self.seeks = seeks

