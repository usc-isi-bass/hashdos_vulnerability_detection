import angr
import claripy
import math

from hash_patcher.hash_func_runner import HashFuncRunner
from hash_patcher.hash_func_runner import CONC_BUFF_ADDR

import util.angr_util as angr_util

class HashFuncEvaluator(HashFuncRunner):

    # TODO Make signature sensitive
    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        super().__init__(elf_file_name, hash_func_addr, proj)

    def find_preimage(self, hash_val):
        for symbstr_len in range(1, 26):
            solver = claripy.Solver()

            symbstr, rets = self.run_symb(symbstr_len)

            ret_states_constraints = False
            for ret_state, ret_val in rets:
                ret_state_constraints = claripy.And(ret_val == hash_val, *ret_state.solver.constraints)
                ret_states_constraints = claripy.Or(ret_state_constraints, ret_states_constraints)
                solver.add(ret_states_constraints)
            sat = solver.check_satisfiability()
            if sat == 'SAT':
                preimage_int = solver.eval(symbstr, 1)[0]
                preimage_int_byte_length = int(math.ceil(preimage_int.bit_length() / 8))
                preimage = preimage_int.to_bytes(preimage_int_byte_length, 'big')
                return preimage
        return None

    # Try to determine if the hash function works on a buffer and its length as input
    # We create a long buffer and tell the hash function its a short buffer of length l (via the second argument)
    # If the hash function only dereferences l addresses of the buffer, we know its looking at the second argument for the length
    # Right?
    def evaluate_sig1(self):
        given_len = 4 # We give this length as input to the hash function
        actual_len = given_len * 2 # We create a longer buffer
        symbstr_addr_name = 'str_addr'
        symbstr_addr = claripy.BVS(name=symbstr_addr_name, explicit_name=True, size=self._proj.arch.bits)
        call_state = self._proj.factory.call_state(self._hash_func_addr, symbstr_addr, given_len, add_options=[angr.options.TRACK_MEMORY_ACTIONS])
        call_state.add_constraints(symbstr_addr == CONC_BUFF_ADDR)
        symbstr = claripy.BVS("str", size=actual_len * 8)
        for i in range(actual_len):
            call_state.memory.store(symbstr_addr + i, symbstr.get_byte(i))

        call_state.memory.store(symbstr_addr + actual_len, 0) # Set the actual_len'th byte to 0 in case this is actually sig2 (so we can stop earlier)
        ret_states = self.run_hash_func(call_state, n=128) # We give a value for n, because if we've got the signature completely wrong, we need to stop symex somehow

        read_addrs = set()
        ret_state_action_pairs = self.get_ext_mem_refs(call_state, ret_states)
        for ret_state, action in ret_state_action_pairs:
            symbolic_addr = action.addr
            if symbstr_addr_name in symbolic_addr.variables:
                addr = ret_state.solver.eval(symbolic_addr)
                read_addrs.add(addr)

        # If the hash function is signature 1, then it will only read given_len bytes from the start buffer address
        expected_read_addrs = list(range(CONC_BUFF_ADDR, CONC_BUFF_ADDR + given_len))
        # The hash function only read as many bytes as we told it there was
        if len(read_addrs) != len(expected_read_addrs):
            return False
        for buf_i_addr, read_addr in zip(sorted(read_addrs), expected_read_addrs):
            if buf_i_addr != read_addr:
                return False
        return True

    # Try to determine if the hash function calculates the length from the buffer itself (by reading \0)
    # We create a long buffer and place \0 in the middel (at index l)
    # If the hash function only dereferences l + 1 addresses of the buffer, we know it stops after discovering the \0
    # Right?
    def evaluate_sig2(self):
        given_len = 4 # the number of bytes before \0
        actual_len = given_len * 2 # We create a longer buffer
        symbstr_addr_name = 'str_addr'
        symbstr_addr = claripy.BVS(name=symbstr_addr_name, explicit_name=True, size=self._proj.arch.bits)
        call_state = self._proj.factory.call_state(self._hash_func_addr, symbstr_addr, actual_len, add_options=[angr.options.TRACK_MEMORY_ACTIONS]) # We give it a second parameter incase its sig1 (Note in this case we give it the actual length, because we're testing for sig2. If its truely sig2, the actual_len parameter will be ignored)
        call_state.add_constraints(symbstr_addr == CONC_BUFF_ADDR)
        symbstr = claripy.BVS("str", size=actual_len * 8)
        for i in range(actual_len):
            call_state.memory.store(symbstr_addr + i, symbstr.get_byte(i))
        call_state.memory.store(symbstr_addr + given_len, 0) # Set the given_len'th byte to 0 to give the hash function a length for the buffer
        ret_states = self.run_hash_func(call_state, n=128) # We set a value for n, because if we've got the signature wrong, we need to stop symex somehow

        read_addrs = set()
        ret_state_action_pairs = self.get_ext_mem_refs(call_state, ret_states)
        for ret_state, action in ret_state_action_pairs:
            symbolic_addr = action.addr
            # Only add this as a buffer read if the address depends on the buffer address
            if symbstr_addr_name in symbolic_addr.variables:
                addr = ret_state.solver.eval(symbolic_addr)
                read_addrs.add(addr)

        # If the hash function is signature 1, then it will only read (given_len + 1) bytes from the start buffer address (+1 to see the \0)
        expected_read_addrs = list(range(CONC_BUFF_ADDR, CONC_BUFF_ADDR + given_len + 1))
        # The hash function only read as many bytes as we told it there was
        if len(read_addrs) != len(expected_read_addrs):
            return False
        for buf_i_addr, read_addr in zip(sorted(read_addrs), expected_read_addrs):
            if buf_i_addr != read_addr:
                return False
        return True


    def evaluate_ext_mem_refs_sig1(self, conc_buf, conc_buf_len, read_addr_whitelist=None):
        call_state, ret_state = self.run_conc_sig1(conc_buf, conc_buf_len)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        if read_addr_whitelist is None:
            read_addr_whitelist = range(conc_buf_addr, conc_buf_addr + conc_buf_len) # signature 1 should not dereference the \0 byte
        return self.evaluate_ext_mem_refs(call_state, [ret_state], read_addr_whitelist)

    def evaluate_ext_mem_refs_sig2(self, conc_buf, read_addr_whitelist=None):
        conc_buf_len = len(conc_buf) # We know what the buffer length is, but the hash function will have to determine it itself
        call_state, ret_state = self.run_conc_sig2(conc_buf)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        if read_addr_whitelist is None:
            read_addr_whitelist = range(conc_buf_addr, conc_buf_addr + conc_buf_len + 1) # signature 2 should dereference the \0 byte (to detect the end of the buffer)
        return self.evaluate_ext_mem_refs(call_state, [ret_state], read_addr_whitelist)


    def evaluate_ext_mem_refs(self, call_state, ret_states, read_addr_whitelist):
        hash_func_irregularities = []

        ret_state_action_pairs = self.get_ext_mem_refs(call_state, ret_states)
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        conc_buf = call_state.mem[conc_buf_addr].string.concrete
        for ret_state, action in ret_state_action_pairs:
            ref_addr = ret_state.solver.eval(action.addr.to_claripy())
            ref_size = ret_state.solver.eval(action.size.to_claripy())
            ref_size_bytes = ref_size // 8
            # Hash function should not write outside of its stack
            if action.action == angr.state_plugins.SimActionData.WRITE:
                irregularity = HashFuncExternalMemWrite(conc_buf, conc_buf_addr, stack_pointer, ref_addr, ref_size, action)
                hash_func_irregularities.append(irregularity)
                continue
            else:
                assert action.action == angr.state_plugins.SimActionData.READ, "Logic error, not a read or a write: {}".format(action.action)
                read_addr, read_size, read_size_bytes = ref_addr, ref_size, ref_size_bytes

                if not read_addr in read_addr_whitelist:
                    # report irregularity
                    irregularity = HashFuncExternalMemRead(conc_buf, conc_buf_addr, stack_pointer, read_addr, read_size, read_addr_whitelist, action)
                    hash_func_irregularities.append(irregularity)
                    continue
        # TODO check if all addrs in whitelist were read from
        return hash_func_irregularities

    # Get memory reads external to the stack frame
    def get_ext_mem_refs(self, call_state, ret_states):
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        call_state.regs.rbp = call_state.regs.rsp
        base_pointer = call_state.solver.eval(call_state.regs.rbp)

        ret_state_action_pairs = []
        for ret_state in ret_states:
            state_history = ret_state.history
            for action in state_history.actions:
                if isinstance(action, angr.state_plugins.SimActionData) and action.type == angr.state_plugins.SimActionData.MEM:
                    addr = ret_state.solver.eval(action.addr)
                    if addr > stack_pointer or addr < stack_pointer - 0xff:
                        ret_state_action_pairs.append((ret_state, action))
        return ret_state_action_pairs

class HashFuncIrregularity:

    def __init__(self, irregularity_type):
        self.irregularity_type = irregularity_type

class HashFuncExternalMemWrite(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, write_addr, write_size, action):
        super().__init__('external_memwrite')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.write_addr = write_addr
        self.write_size = write_size
        self.action = action

class HashFuncExternalMemRead(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, read_addr, read_size, read_whitelist, action):
        super().__init__('external_memread')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.read_addr = read_addr
        self.read_size = read_size
        self.read_whitelist = read_whitelist
        self.action = action

    def __str__(self):
        return "<HashFuncExternalMemRead buf: {}@0x{:x} stack_ptr: 0x{:x} read_addr: 0x{:x} read_size: {} read_whitelist: {} action: {}>".format(self.buf, self.buf_addr, self.stack_ptr, self.read_addr, self.read_size, self.read_whitelist, self.action)


