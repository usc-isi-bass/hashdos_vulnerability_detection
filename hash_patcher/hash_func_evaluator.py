import angr

from hash_patcher.hash_func_runner import HashFuncRunner

class HashFuncEvaluator:

    # TODO Make signature sensitive
    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        self._elf_file_name = elf_file_name
        self._hash_func_addr = hash_func_addr

        if proj is None:
            self._proj = angr.Project(self._elf_file_name, auto_load_libs=False)
        else:
            self._proj = proj
        self._hash_func_runner = HashFuncRunner(elf_file_name, hash_func_addr, proj=self._proj)

    def evaluate_ext_mem_refs(self, conc_buf, read_addr_whitelist=None):
        hash_func_irregularities = []

        conc_buf_len = len(conc_buf)
        # Find all external memory references (outside of stack frame)
        call_state, ret_state, actions = self.get_ext_mem_refs(conc_buf)
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        conc_buf_addr = call_state.solver.eval(call_state.regs.rdi)
        for action in actions:
            ref_addr = call_state.solver.eval(action.addr.to_claripy())
            ref_size = call_state.solver.eval(action.size.to_claripy())
            ref_size_bytes = ref_size // 8
            # Hash function should not write outside of its stack
            if action.action == angr.state_plugins.SimActionData.WRITE:
                irregularity = HashFuncExternalMemWrite(conc_buf, conc_buf_addr, stack_pointer, ref_addr, ref_size, action)
                hash_func_irregularities.append(irregularity)
                continue
            else:
                assert action.action == angr.state_plugins.SimActionData.READ, "Logic error, not a read or a write: {}".format(action.action)
                read_addr, read_size, read_size_bytes = ref_addr, ref_size, ref_size_bytes

                if read_addr_whitelist is None:
                    # Make sure the read occurs within the bounds of the buffer
                    if read_addr < conc_buf_addr:
                        # report irregularity
                        irregularity = HashFuncExternalMemRead(conc_buf, conc_buf_addr, stack_pointer, read_addr, read_size, read_addr_whitelist, action)
                        hash_func_irregularities.append(irregularity)
                        continue
                    # TODO Update this to be signature sensitive. A hash func that receives the length does not need to access the \0 byte
                    if read_addr + read_size_bytes > conc_buf_addr + conc_buf_len + 1:
                        # report irregularity
                        irregularity = HashFuncExternalMemRead(conc_buf, conc_buf_addr, stack_pointer, read_addr, read_size, read_addr_whitelist, action)
                        hash_func_irregularities.append(irregularity)
                        continue
                else:
                    if not read_addr in read_addr_whitelist:
                        # report irregularity
                        irregularity = HashFuncExternalMemRead(conc_buf, conc_buf_addr, stack_pointer, read_addr, read_size, read_addr_whitelist, action)
                        hash_func_irregularities.append(irregularity)
                        continue
        return hash_func_irregularities


    def get_buf_reads(self, conc_buf):
        conc_buf_len = len(conc_buf)
        call_state, ret_state, ret_reg = self._hash_func_runner.run_conc(conc_buf)
        buf_addr = call_state.solver.eval(call_state.regs.rdi)

        state_history = ret_state.history
        actions = []
        for action in state_history.actions:
            if action.action == angr.state_plugins.SimActionData.READ:
                addr = ret_state.solver.eval(action.addr)
                data = ret_state.solver.eval(action.data)
                if buf_addr <= addr < buf_addr + conc_buf_len:
                    actions.append(action)
        return buf_addr, actions

    # Get memory reads external to the stack frame
    def get_ext_mem_refs(self, conc_buf):
        call_state, ret_state, ret_reg = self._hash_func_runner.run_conc(conc_buf)
        stack_pointer = call_state.solver.eval(call_state.regs.rsp)
        call_state.regs.rbp = call_state.regs.rsp
        base_pointer = call_state.solver.eval(call_state.regs.rbp)

        state_history = ret_state.history
        actions = []
        for action in state_history.actions:
            if isinstance(action, angr.state_plugins.SimActionData) and action.type == angr.state_plugins.SimActionData.MEM:
                addr = ret_state.solver.eval(action.addr)
                if addr > stack_pointer or addr < stack_pointer - 0xff:
                    actions.append(action)
        return call_state, ret_state, actions

class HashFuncIrregularity:

    def __init__(self, irregularity_type):
        self.irregularity_type = irregularity_type

class HashFuncExternalMemWrite(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, write_addr, write_size, action):
        super().__init__('external_memwrite')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.write_addr = write_addr
        self.write_size = write_size
        self.action = action

class HashFuncExternalMemRead(HashFuncIrregularity):

    def __init__(self, buf, buf_addr, stack_ptr, read_addr, read_size, read_whitelist, action):
        super().__init__('external_memread')
        self.buf = buf
        self.buf_addr = buf_addr
        self.stack_ptr = stack_ptr
        self.read_addr = read_addr
        self.read_size = read_size
        self.read_whitelist = read_whitelist
        self.action = action

    def __str__(self):
        return "<HashFuncExternalMemRead buf: {}@0x{:x} stack_ptr: 0x{:x} read_addr: 0x{:x} read_size: {} read_whitelist: {} action: {}>".format(self.buf, self.buf_addr, self.stack_ptr, self.read_addr, self.read_size, self.read_whitelist, self.action)


