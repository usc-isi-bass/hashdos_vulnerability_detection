import argparse
import angr
import networkx as nx
import logging
import pwn
import re
import binascii

import util.binary_code_utils as bcu
import hash_patcher.patcher as patcher

l = logging.getLogger(name=__name__)

pwn.context.log_level = 'ERROR'

def hash_patch(elf_file_name, hash_func_name, patch_insns={}):
	proj = angr.Project(elf_file_name, auto_load_libs=False)

	cfg = proj.analyses.CFGFast(normalize=False)
	# A dummy function to overwrite for patching in ./binaries/practice_dummy
	dummy_func = cfg.functions.function(name='dummy_function')
	hash_func = cfg.functions.function(name=hash_func_name)
	graph = hash_func.graph
	#transition_graph = hash_func.transition_graph
	#print(graph == transition_graph)
	#nx.drawing.nx_pydot.write_dot(graph, 'graph.dot')
	#nx.drawing.nx_pydot.write_dot(transition_graph, 'transition_graph.dot')
	# First we find the loop in the hash functino
	sccs = list(extract_nontrivial_sccs(graph))
	if len(sccs) > 1:
		raise Exception("I don't know what to do if we find more than one loop in hash function.")
	scc = sccs[0]
	print("SCC: {}".format(scc.nodes()))

	#symex_hash_func(proj, hash_func)

	# We construct a CFG of only the hash function (this will not include any edges or nodes to other functions)
	# Next we find the outgoing block of the SCC (the one that exits the loop). This block should contain the jump we want to patch
	# XXX You can't use normalize=True with keep_state, because the function _normalize_core(...) in cfg_base.py does not preserve cfg_node.final_states
	hash_func_cfg = proj.analyses.CFGEmulated(starts=[hash_func.addr], normalize=False, call_depth=0,address_whitelist=[block.addr for block in hash_func.blocks], keep_state=True, state_add_options=angr.sim_options.refs)
	#nx.drawing.nx_pydot.write_dot(hash_func_cfg.graph, 'hash_func_cfg.dot')
	outgoing_scc_nodes = extract_outgoing_scc_nodes(proj, hash_func_cfg, scc)
	if len(outgoing_scc_nodes) > 1:
		raise Exception("For now, we only work with a single outgoing SCC node. Outgoing SCC nodes: {}".format(outgoing_scc_nodes))
	outgoing_scc_node = outgoing_scc_nodes[0]
	outgoing_scc_node_succs = list(scc.successors(outgoing_scc_node))
	if len(outgoing_scc_node_succs) != 1:
		raise Exception("For now, we only work with a single SCC-internal successor for the outgoing SCC node. Successors: {}".format(outgoing_scc_node_succs))
	outgoing_scc_node_succ = outgoing_scc_node_succs[0]
	
	print("Outgoing SCC: {}".format(outgoing_scc_node))
	outgoing_scc_block = proj.factory.block(outgoing_scc_node.addr)
	jump_insn_addr, jump_insn = extract_jump_insn(proj, outgoing_scc_block)
	print("The outgoing jump insn at 0x{:x}: {} {}".format(jump_insn_addr, jump_insn.mnemonic, jump_insn.op_str))
	# TODO How to fix the loop at the end of the patch? We'll have to figure out where the comparison instruction happens and copy that as well. What if the comparison instruction depends on a bunch of stuff?
	# TODO How about for a first attempt I just check if the preceding instruction is a cmp or a test and then copy that to the patch as well? If it does not depend on the clobbered register, I should just be able to copy it, right?
	# Be careful with copying test/cmp instructions further back. THink about this:
	# test/cmp
	# <instructions that clobber every regsister and every memory address, but leaves all flags alone>
	# <jump instruction>
	# You can't simply redo the test/cmp because at this point the result will be different.
	# Therefore, TODO, just look at the immediate preceiding instruction
	# ALTERNATIVE, keep the conditionality of the jump in the original hash function and put a non-conditional jump back to the original target at the end of the patch.
	# Note that this won't do the patch computations for the last iteration
		
	# Next We need to find where the intermediate hash value is stored (the intermediate hash value is the hash value at the end of every loop iteration)
	ddg = proj.analyses.DDG(hash_func_cfg, start=hash_func.addr)
	#nx.drawing.nx_pydot.write_dot(ddg.graph, 'ddg.dot')

	intermediate_storage_stmt = None # The final statement in the loop that touches the intermediate hash value. This statement should either PUT to a register or Store to a mem addr
	ret_val_stmts = find_ret_val_stmts(proj, hash_func_cfg, hash_func)
	for ret_val_stmt in ret_val_stmts:
		ret_val_stmt_addr, ret_val_stmt_idx = ret_val_stmt
		print("Ret val stmt:")
		print("0x{:x}[{}]".format(ret_val_stmt_addr, ret_val_stmt_idx))
		ret_val_insn_addr, ret_val_capstone_insn = get_insn_from_stmt(proj, ret_val_stmt_addr, ret_val_stmt_idx)
		print("0x{:x}: {}".format(ret_val_insn_addr, ret_val_capstone_insn))
		stmts_in_scc = trace_to_stmts_in_scc(proj, scc, ddg, ret_val_stmt)
		for stmt_in_scc in stmts_in_scc:
			if intermediate_storage_stmt is None:
				intermediate_storage_stmt = stmt_in_scc
			elif stmt_in_scc != intermediate_storage_stmt:
				raise Exception("For now, we only work with a single statement in the SCC. Statements: {}".format(stmts_in_scc))

	code_cave_addr = None
	if dummy_func is not None:
		code_cave_addr = dummy_func.addr
	# TODO find a code cave in the binary
	if code_cave_addr is None:
		raise Exception("I haven't actually written a way to find code caves in binaries yet...")

	print("Code cave addr: 0x{:x}".format(dummy_func.addr))
	hash_patch_addr = code_cave_addr

	if 	intermediate_storage_stmt is None:
		raise Exception("Could not find the intermediate storage statement in SCC.")
	store_stmt_block_addr, store_stmt_idx = intermediate_storage_stmt
	print("We trace the data dep into the SCC:")
	store_statement = get_vex_stmt(proj, store_stmt_block_addr, store_stmt_idx)
	print("Store statement: 0x{:x}[{}] : {}".format(store_stmt_block_addr, store_stmt_idx, store_statement))
	store_insn_addr, store_capstone_insn = get_insn_from_stmt(proj, store_stmt_block_addr, store_stmt_idx)
	print("0x{:x}: {}".format(store_insn_addr, store_capstone_insn))
	store_dst = extract_dst_from_capstone_insn(store_capstone_insn)
	print("Store dest: {}".format(store_dst))
	store_dst_type = get_dst_type(store_statement)
	print("Store dest type: {}".format(store_dst_type))
	print("Hash Patch assembly code:")
	jump_back_addr = outgoing_scc_node_succ.addr
	hash_patch_assembly_code = create_hash_patch_assembly_code(proj, store_dst, store_dst_type, jump_back_addr, patch_insns=patch_insns)
	print(hash_patch_assembly_code)
	pwn.context.arch = proj.arch.name
	print("Hash Patch machine code:")
	hash_patch_bytes = pwn.asm(hash_patch_assembly_code, vma=hash_patch_addr)
	print(binascii.hexlify(hash_patch_bytes))



	jump_patch_addr = jump_insn_addr
	jump_patch_offset = code_cave_addr - jump_insn_addr
	#print("0x{:x}".format(proj.loader.main_object.mapped_base))
	jmp_asm = "{} 0x{:x}".format(jump_insn.mnemonic, code_cave_addr)
	print("Jump patch assembly: {}".format(jmp_asm))
	#jump_patch_bytes = pwn.asm(jmp_asm, vma=jump_insn_addr)
	jump_patch_bytes = bcu.create_jump(jump_insn.mnemonic, jump_patch_offset)
	print("Jump patch bytes: {}".format(binascii.hexlify(jump_patch_bytes)))
	if len(jump_patch_bytes) > len(jump_insn.bytes):
		raise Exception("I cannot patch the jump instruction, because the patch for the jump instruction requires more bytes. jump: {} patched jump: {}".format(binascii.hexlify(jump_insn.bytes), binascii.hexlify(jump_patch_bytes)))
	elif len(jump_patch_bytes) < len(jump_insn.bytes):
		# If the patch is shorter than the original instruction, add NOPs to the end of the patch until they are of equal length
		jump_patch_bytes += '\x90' * (len(jump_insn.bytes) - len(jump_patch_bytes))

	# Finally we apply the patches
	patch_writer = patch_writer.PatchWriter(proj)
	patch_writer.add_patch(hash_patch_addr, hash_patch_bytes)
	patch_writer.add_patch(jump_patch_addr, jump_patch_bytes)
	patched_elf_name = elf_file_name + "_patched"
	for insn in patch_insns:
		insn_op = patch_insns[insn]
		patched_elf_name += "_{}{}".format(insn, insn_op)
	patch_writer.apply_patches(patched_elf_name)


# Creates the code to patch the binary
# Note, this does not insert the patch in any way.
# You still need to change something in the original code to jump to the patch
# TODO In order to add the jumps, you need to know where this will be inserted to calculate jump offsets
def create_hash_patch_assembly_code(proj, dst, dst_type, jump_back_addr, patch_insns={}):
	if proj.arch.bits == 32:
		use_reg = 'eax'
	elif proj.arch.bits == 64:
		use_reg = 'rax'
	else:
		raise Exception("Cannot create patch for {}-bit architecture".format(proj.arch.bits))
	assembly_code = ""
	reg = None
	if dst_type == 'reg':
		reg = dst
	elif dst_type == 'mem':
		reg = use_reg
		# Save value of rax
		assembly_code += "push {}\n".format(reg)
		assembly_code += "mov {}, {}\n".format(reg, dst)
	else:
		raise Exception("Unknown dst_type: {}".format(dst_type))

	if 'mul' in patch_insns:
		mul_op = patch_insns['mul']
		assembly_code += "imul {}, {}, {}\n".format(reg, reg, mul_op)

	if 'add' in patch_insns:
		add_op = patch_insns['add']
		assembly_code += "add {}, {}\n".format(reg, add_op)

	if dst_type == 'mem':
		assembly_code += 'mov {}, {}\n'.format(dst, reg)
		assembly_code += 'pop {}\n'.format(reg)


	assembly_code += "jmp {}\n".format(jump_back_addr)

	return assembly_code


	

# We're trying to find the nodes that exist the SCC
# SCC is a NX Digraph
def extract_outgoing_scc_nodes(proj, cfg, scc):
	outgoing_scc_nodes = []
	for scc_node in scc.nodes():
		if len(get_external_successors(proj, cfg, scc, scc_node)) > 0:
			outgoing_scc_nodes.append(scc_node)
	return outgoing_scc_nodes

# Retrieves the successors of scc_node that are not in scc
def get_external_successors(proj, cfg, scc, scc_node):
	external_successors = []
	scc_cfg_node = cfg.model.get_any_node(addr=scc_node.addr)
	for cfg_succ_node in cfg.model.get_successors(scc_cfg_node):
		# Check if this successor in the CFG is also in the SCC
		scc_has_succ_node = any(cfg_succ_node.addr == node.addr for node in scc.nodes())
		if not scc_has_succ_node:
			external_successors.append(cfg_succ_node)
	return external_successors
	
	

# Gets the locate where stmt saves its result.
# We use this to determine where the hash value is saved
def get_dst_type(stmt):
	if stmt.tag == 'Ist_Put' or any(expr.tag == 'Ist_Put' for expr in stmt.expressions):
		return 'reg'
		# TODO I'm not sure if this will work. I think we may have to try expr.addr
	elif stmt.tag == 'Ist_Store' or any(expr.tag == 'Ist_Store' for expr in stmt.expressions):
		return 'mem'
	else:
		raise Exception("I don't know where statement '{}' with tag: {} stores its result".format(stmt, stmt.tag))

# Jump site should be a block
def extract_jump_insn(proj, jump_site):
	return get_insn_from_stmt(proj, jump_site.addr, jump_site.vex.stmts_used - 1)
	
def get_vex_stmt(proj, addr, stmt_idx):
	block = proj.factory.block(addr=addr)
	irsb = block.vex
	return irsb.statements[stmt_idx]


# Takes a ret_val_stmt (addr, stmt_idx) and traces it backward to the first depending statement inside the SCC.
# Note we take the first SCC node on every path (but we terminate a path as soon as it reaches the SCC).
# Therefore, we may return more than one statement
# Returns list of (block_addr, stmt_idx)
def trace_to_stmts_in_scc(proj, scc, ddg, ret_val_stmt):
	ret_val_stmt_block_addr, ret_val_stmt_idx = ret_val_stmt
	stack = [ret_val_stmt]
	visited = set(stack)
	stmts_in_scc = []
	while len(stack) > 0:
		block_addr, stmt_idx = stack.pop()
		#print("Looking at: 0x{:x}[{}]".format(block_addr, stmt_idx))
		ddg_node = get_ddg_node(ddg, block_addr, stmt_idx)
		#assert ddg_node is not None
		if ddg_node is None:
			l.error("Could not find DDG node (0x{:x}, {})".format(block_addr, stmt_idx))
			continue
		# If this statement is in the SCC, add it to the list and stop the branch
		if any(block_addr == node.addr for node in scc.nodes()):
			stmts_in_scc.append((block_addr, stmt_idx))
		else:
			# Otherwise, continue from its predecessors
			for pred in ddg.get_predecessors(ddg_node):
				pred_stmt = (pred.block_addr, pred.stmt_idx)
				if pred_stmt not in visited:
					visited.add(pred_stmt)
					stack.append(pred_stmt)
			
	return stmts_in_scc

	

# Find those instructions that populate rax/eax with a value
# We start at the ret site and traverse the instructions backward.
# We note any instruction that writes to rax/eax
# Otherwise, we do the same with the CFG predecessors
# We stop a branch when we find an instruction
def find_ret_val_stmts(proj, cfg, func):
	ret_sites = func.ret_sites
	stack = [ret_site.addr for ret_site in ret_sites]
	visited = set([ret_site.addr for ret_site in ret_sites])
	ret_val_stmts = []
	while len(stack) > 0:
		addr = stack.pop()
		block = proj.factory.block(addr=addr)
		irsb = block.vex
		write_ret_val_stmt = None
		for stmt in reversed(irsb.statements):
			if stmt.tag == 'Ist_Put':
				# TODO what about Ist_Putl? This doesn't have a fixed offset
				reg_name = proj.arch.translate_register_name(stmt.offset)
				if reg_name == 'rax' or reg_name == 'eax':
					write_ret_val_stmt = stmt
					break
		if write_ret_val_stmt is not None:
			write_ret_val_stmt_idx = irsb.statements.index(write_ret_val_stmt)
			assert write_ret_val_stmt_idx != -1
			ret_val_stmts.append((addr, write_ret_val_stmt_idx))
		else:
			cfg_node = cfg.model.get_any_node(addr=addr)
			for pred in cfg.model.get_predecessors(cfg_node):
				if pred not in visited:
					visited.add(pred.addr)
					stack.append(pred.addr)
	return ret_val_stmts
			
# Returns (insn_addr, insn) where insn_addr is the address of the assembly instruction and insn is the assembly instruction
# insn_addr is an int and insn is CapstoneInsn
def get_insn_from_stmt(proj, block_addr, stmt_idx):
	block = proj.factory.block(addr=block_addr)
	irsb = block.vex
	stmts = irsb.statements
	target_insn_addr = None
	for i in range(stmt_idx, -1, -1): # stmt_idx, -1 because we actually want to search at index 0 too
		stmt = stmts[i]
		if stmt.tag == 'Ist_IMark':
			target_insn_addr = stmt.addr
			break
	assert target_insn_addr is not None
	for insn_addr, capstone_insn in zip(block.instruction_addrs, block.capstone.insns):
		if insn_addr == target_insn_addr:
			return insn_addr, capstone_insn
	return None
			
# Extract the destination operand from a capstone instruction:
# e.g.:
# mov rax, 5 ; should return rax
# mov    dword ptr [rbp - 8], eax ; should return dword ptr [rbp - 8]
def extract_dst_from_capstone_insn(capstone_insn):
	op_str = capstone_insn.op_str
	#pattern = r'(.*),'
	pattern = r'(\[[^\]]+\]|[a-z]{2,3}),'
	pattern_match = re.search(pattern, op_str)
	if pattern_match is not None:
		dst = pattern_match.group(1).strip()
		return dst
	else:
		raise Exception("Could not determine what is the destination in: {} op_str: {}".format(capstone_insn, op_str))
		

def extract_nontrivial_sccs(graph):
	for scc_nodes in nx.strongly_connected_components(graph):
		subgraph = graph.subgraph(scc_nodes)
		if len(subgraph.edges) > 0:
			yield subgraph

# Returns a node in the DDG with node.addr == addr and node.stmt_idx == stmt_idx
# Return value should be of type CodeLocation
def get_ddg_node(ddg, addr, stmt_idx):
	for node in ddg.graph.nodes():
		if node.block_addr == addr and node.stmt_idx == stmt_idx:
			return node
	return None
	

def symex_hash_func(proj, hash_func):
	start_state = proj.factory.call_state(addr=hash_func.addr)
	print(start_state.regs._sp)
	print(hex(start_state.callstack.top.stack_ptr))
	cur_sp = start_state.solver.max(start_state.regs._sp) if start_state.has_plugin('symbolizer') else start_state.regs._sp
	print(not start_state.solver.is_true(cur_sp > start_state.callstack.top.stack_ptr))
	#start_state.regs.rbp = 0
	#start_state.regs.rsp = 0
	def ret_break(state):
		print("Hit return 0x{:x}: rax = {}".format(state.addr, state.regs.rax))
		print("state history: {}".format(list(state.history.actions)))
	# This is an absolute nightmare, but because we are symexing at the top stack level, angr won't trigger break points at the return
	# See line 211-217 on https://github.com/angr/angr/blob/master/angr/engines/successors.py
	# state._inspect(...) triggers the breakpoint
	# The check if not state.solver.is_true(cur_sp > state.callstack.top.stack_ptr) fails because we're at the top of the call stack
	#start_state.inspect.b('return', when=angr.BP_BEFORE, action=ret_break)
	hash_func_ret_sites = hash_func.ret_sites
	for ret_site in hash_func_ret_sites:

		ret_block = proj.factory.block(addr=ret_site.addr)
		print("ret block: {}".format(ret_block))
		print("ret block insn addrs: {}".format(ret_block.instruction_addrs))

		start_state.inspect.b('instruction', instruction=max(ret_block.instruction_addrs), when=angr.BP_BEFORE, action=ret_break)

	simgr = proj.factory.simulation_manager(start_state)
	for i in range(5):
		for state in simgr.active:
			print(state)
		print("")
		simgr.step()

if __name__ == "__main__":
	main()
