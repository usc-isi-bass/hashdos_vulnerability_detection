import re
import math

import keystone
import pyvex

# We keep this a list so that the iteration order is always the same
X64_REGS = ["rax", "rcx", "rdx", "rbx", "rsi", "rdi", 'rsp', 'rbp', "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]

class HashPatchAsmGenerator():

    def __init__(self, proj, asm_file=None, asm_code=None, random_vals={}, buf_in_reg='rdi', len_in_reg='rsi', out_reg='rax', out_mod=None):
        '''
        Parameters
        ----------
            proj : angr.Project
                The current angr Project
            asm_file : str
                A file containing the assembly code for the replacement hash function.
                It should receive its input buffer in register rdi and the length of the input buffer in register rsi
                (mutually exclusive with asm_code)
            asm_code : list
                A list containing the assembly code instructions (strings) for the replacement hash function.
                It should receive its input buffer in register rdi and the length of the input buffer in register rsi
                (mutually exclusive with asm_file)
            random_vals: dict
                A dictionary mapping random value tags (rval\d+) found in the assembly code to concrete random values.
            buf_in_reg : str
                The register in which the call site places the input buffer for the hash function.
                (default rdi)
            len_in_reg : str
                The register in which the call site places the length of the input buffer.
                len_in_reg may be none, in which case it is assumed that the input buffer is terminated by a null byte.
                (default rsi)
            out_reg : str
                The register in which to put the return value.
                (default rax)
            out_mod : int
                The MOD that should be applied to the output.
                If out_mod is None, then the return value is left unchanged from the replacement hash function.
        '''
        self._proj = proj
        if proj.arch.name != 'AMD64':
            raise Exception("At the moment we only handle patching for projects with architecture \"AMD64\"")
        self._random_vals = random_vals
        # If both are None, or neither are None
        if (asm_file is not None) == (asm_code is not None):
            raise Exception("You must specify exactly one of asm_file or asm_code")
        if asm_file is not None:
            self._asm_code = self.extract_asm_code(asm_file)
        if asm_code is not None:
            self._asm_code = asm_code
        assert buf_in_reg in X64_REGS, "buf_in_reg must be a register"
        assert len_in_reg is None or len_in_reg in X64_REGS, "len_in_reg must be a register, or None"
        assert out_reg in X64_REGS, "out_reg must be a register"

        self._buf_in_reg = buf_in_reg
        self._len_in_reg = len_in_reg
        self._out_reg = out_reg
        self._out_mod = out_mod

    def get_asm_code(self):
        # Move the pointer to the input buffer to rdi
        mov_buf_in_asm_insns = []
        if self._buf_in_reg != 'rdi':
            mov_buf_in_asm_insns.append("mov rdi,{}".format(self._buf_in_reg))
        mov_len_in_asm_insns = []
        if self._len_in_reg is not None and self._len_in_reg != 'rsi':
            mov_len_in_asm_insns.append('mov rsi,{}'.format(self._len_in_reg))
        elif self._len_in_reg is None:
            # Assume the buffer is \0 terminated
            # Add code to calculate string length in rsi
            mov_len_in_asm_insns.append('xor rsi,rsi')
            mov_len_in_asm_insns.append('label_1170:')
            mov_len_in_asm_insns.append('cmp    BYTE PTR [rdi+rsi*1],0x0')
            mov_len_in_asm_insns.append('je     label_117c')
            mov_len_in_asm_insns.append('inc    rsi')
            mov_len_in_asm_insns.append('jmp    label_1170')
            mov_len_in_asm_insns.append('label_117c:')

        call_replacement_hash_asm_insns = ['call label_replace_hash']

        out_mod_insns = []
        if self._out_mod is not None:
            out_mod_insns.append('xor rdx,rdx') # Clear the upper part of the dividend
            # The lower part of the dividend is already in rax
            out_mod_insns.append('mov rcx,{}'.format(self._out_mod)) # put the divisor in rcx
            out_mod_insns.append('idiv rcx'.format(self._out_mod)) # After this, the ramainder should be in rdx
            out_mod_insns.append('mov rax,rdx'.format(self._out_mod)) # Move the remainder to rax

        # Move the return value of the replacement hash function (in rax) to the register the call site is expecting it
        mov_ret_val_insns = []
        if self._out_reg != 'rax':
            mov_ret_val_insns.append('mov {},rax'.format(self._out_reg))


        
        return_hash_asm_insns = ['ret']
        replacement_hash_asm_label = ['label_replace_hash:']
        replacement_hash_asm_insns = self._asm_code

        clobbered_regs = set()
        clobbered_regs = clobbered_regs.union(self.detect_clobbered_regs(mov_buf_in_asm_insns))
        #print('insns: {}'.format(mov_len_in_asm_insns))
        clobbered_regs = clobbered_regs.union(self.detect_clobbered_regs(mov_len_in_asm_insns))
        #clobbered_regs = clobbered_regs.union(self.detect_clobbered_regs(call_replacement_hash_asm_insns)) # (shouldn't be any)
        clobbered_regs = clobbered_regs.union(self.detect_clobbered_regs(out_mod_insns))
        clobbered_regs = clobbered_regs.union(self.detect_clobbered_regs(mov_ret_val_insns))
        #clobbered_regs = clobbered_regs.union(self.detect_clobbered_regs(return_hash_asm_insns)) # (shouldn't be any)
        clobbered_regs = clobbered_regs.union(self.detect_clobbered_regs(replacement_hash_asm_insns)) # This is most imporant

        to_save_regs = set().union(clobbered_regs)
        to_save_regs = to_save_regs.difference(set([self._out_reg])) # We do not want to restore the output register (this would defeat the purpose)
        to_save_regs = to_save_regs.difference(set(['rip'])) # Do not save rip
        to_save_regs = list(to_save_regs) # We convert to a list to keep the order the same


        save_regs_asm_insns = self.save_regs(to_save_regs)
        restore_regs_asm_insns = self.restore_regs(to_save_regs)

        save_regs_asm_insns = self.save_regs(to_save_regs)
        restore_regs_asm_insns = self.restore_regs(to_save_regs)
        assert len(save_regs_asm_insns) == len(restore_regs_asm_insns), "We are saving an restoring an unequal number of registers"

        patch_asm_code = save_regs_asm_insns \
                + mov_buf_in_asm_insns \
                + mov_len_in_asm_insns \
                + call_replacement_hash_asm_insns \
                + out_mod_insns \
                + mov_ret_val_insns \
                + restore_regs_asm_insns \
                + return_hash_asm_insns \
                + replacement_hash_asm_label \
                + replacement_hash_asm_insns
        patch_asm_code_str = '\n'.join(patch_asm_code)
        #print(patch_asm_code_str)
        return patch_asm_code
     

    # TODO update the save_regs and restore_regs to only save and restore registers that are actually used by the patch code
    def save_regs(self, regs):
        asm_code_insns = []
        #for reg in X64_REGS:
        for reg in regs:
            asm_code_insns.append("push {}".format(reg))
        return asm_code_insns
    def restore_regs(self, regs):
        asm_code_insns = []
        #for reg in X64_REGS[::-1]:
        for reg in regs[::-1]:
            asm_code_insns.append( "pop {}".format(reg))
        return asm_code_insns
        
       
    def extract_asm_code(self, asm_file):
        asm_code = []
        with open(asm_file, 'r') as fd:
            for line in fd:
                line = line.strip()
                line = self.remove_comment(line)
                # Randomize algorithm
                m = re.search(r'<<(?P<rval_tag>rval\d+)>>', line)
                if m is not None:
                    rval_tag = m.group('rval_tag')
                    if rval_tag not in self._random_vals:
                        raise Exception("HashPatchAsmGenerator requries a random value for: {} random vals: {}".format(rval_tag, self._random_vals))
                    rval = self._random_vals[rval_tag]
                    line = line.replace("<<" + rval_tag + ">>", hex(rval))
                if len(line) == 0:
                    continue
                # Lines starting with ; or # are treated as comments
                #if re.match(r'\s*[;#]', line):
                #    continue
                asm_code.append(line)
        return asm_code 

    def detect_clobbered_regs(self, asm_code):
        asm_insns = ''
        for asm_insn in asm_code:
            asm_insn = self.remove_comment(asm_insn)
            asm_insns = asm_insns + (asm_insn + '\n')
        ks = keystone.Ks(self._proj.arch.ks_arch, self._proj.arch.ks_mode)
        clobbered_regs = set()
        # The address of the instruction does not matter if we are only interested in which regs are used
        #print(asm_insns)
        bin_insn_list = ks.asm(asm_insns)[0]
        if bin_insn_list is None:
            return clobbered_regs
        bin_insn = bytes(bin_insn_list)
        if len(bin_insn) == 0:
            return clobbered_regs
        #print('bin_insn: {}'.format(bin_insn))
        irsb = pyvex.lift(bin_insn, addr=0, arch=self._proj.arch) 
        for stmt in irsb.statements:
            if stmt.tag == 'Ist_Put':
                reg_str = self._proj.arch.translate_register_name(stmt.offset)
                if reg_str in X64_REGS:
                    reg = self._proj.arch.get_register_by_name(reg_str)
                    if reg.general_purpose:
                        clobbered_regs.add(reg_str)
                    
        return clobbered_regs

    def remove_comment(self, asm_insn):
        return re.sub(r'\s*;.*$', '', asm_insn) # Everything after a ; is a comment
