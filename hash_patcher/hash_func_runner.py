import abc
from abc import ABC

import angr
import claripy

import util.angr_util as angr_util

CONC_BUFF_ADDR = 0x7fffffffffefff5

class HashFuncRunner(ABC):
    # TODO Consider using manually crafted SimCCs for the factory.call_state calls. If we try to symex patch code, this automatic setup of the call state may fail

    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        self._elf_file_name = elf_file_name
        self._hash_func_addr = hash_func_addr

        if proj is None:
            self._proj = angr.Project(self._elf_file_name, auto_load_libs=False)
        else:
            self._proj = proj

        self._run_symb_cache = {}

    #def eval(self, conc_buf):
    #    conc_buf_len = len(conc_buf)
    #    # TODO Make signature sensitive
    #    call_state, ret_state = self.run_conc_sig1(conc_buf, conc_buf_len)
    #    ret_reg = angr_util.get_ret_reg(self._proj, ret_state)
    #    hash_val = ret_state.solver.eval(ret_reg)
    #    return hash_val

    @abc.abstractmethod
    def eval(self, *args):
        raise NotImplementedError()

    def _eval(self, *args):
        call_state, ret_state = self.run_conc(*args)
        ret_reg = angr_util.get_ret_reg(self._proj, ret_state)
        hash_val = ret_state.solver.eval(ret_reg)
        return hash_val

    @abc.abstractmethod
    def run_conc(self, *args):
        raise NotImplementedError()

    # TODO add extra options as an argument
    def _run_conc(self, *args):
        call_state = self._hash_func_call_state(*args, extra_options=[angr.options.TRACK_MEMORY_ACTIONS])
        return self.trace_hash_func_conc(call_state)

    #def run_conc_sig1(self, buf, buf_len):
    #    call_state = self.hash_func_call_state(buf, buf_len, extra_options=[angr.options.TRACK_MEMORY_ACTIONS])
    #    #call_state = self._proj.factory.call_state(self._hash_func_addr, buf, buf_len, add_options=[angr.options.TRACK_MEMORY_ACTIONS])
    #    return self.run_conc(call_state)

    #def run_conc_sig2(self, buf):
    #    call_state = self.hash_func_call_state(buf, extra_options=[angr.options.TRACK_MEMORY_ACTIONS])
    #    #call_state = self._proj.factory.call_state(self._hash_func_addr, buf, add_options=[angr.options.TRACK_MEMORY_ACTIONS])
    #    return self.run_conc(call_state)


    def trace_hash_func_conc(self, call_state):
        ret_states = self.trace_hash_func(call_state)

        assert len(ret_states) == 1, "We executed the hash func with concrete input, but now we have more than one deadended state? deadeded states: {}".format(ret_states)
        ret_state = ret_states[0]

        return call_state, ret_state


    def run_symb(self, str_len, null_terminate=True):
        if str_len not in self._run_symb_cache:
            symbstr_addr, symbstr = self.create_symbstr('str_addr', 'str', str_len, null_terminate=null_terminate)
            call_state = self.hash_func_symb_call_state(symbstr_addr, symbstr, str_len)
            ret_states = self.trace_hash_func(call_state)

            self._run_symb_cache[str_len] = symbstr_addr, symbstr, ret_states
        else:
             symbstr_addr, symbstr, ret_states = self._run_symb_cache[str_len]
        return symbstr_addr, symbstr, ret_states

    # TODO Make signature sensitive
    def hash_func_symb_call_state(self, symbstr_addr, symbstr, str_len, extra_options=[]):
        call_state = self._hash_func_call_state(symbstr_addr, str_len)

        self.store_symbstr(call_state, symbstr_addr, symbstr, null_terminate=True, none_null=True)
        #call_state.add_constraints(symbstr_addr == CONC_BUFF_ADDR)
        #for i in range(buf_len):
        #    call_state.add_constraints(symbstr.get_byte(i) != 0)
        #    call_state.memory.store(symbstr_addr + i, symbstr.get_byte(i))
        #call_state.memory.store(symbstr_addr + buf_len, 0)

        return call_state

    def create_symbstr(self, symbstr_addr_name, symbstr_name, symbstr_len, null_terminate=True):
        symbstr_addr = claripy.BVS(name=symbstr_addr_name, explicit_name=True, size=self._proj.arch.bits)
        if null_terminate:
            buf_len = symbstr_len + 1
        else:
            buf_len = symbstr_len
        symbstr = claripy.BVS(symbstr_name, size=(buf_len) * 8)
        return symbstr_addr, symbstr


    def store_symbstr(self, call_state, symbstr_addr, symbstr, null_terminate=True, none_null=True, symbstr_constraints=None):
        call_state.add_constraints(symbstr_addr == CONC_BUFF_ADDR)
        symbstr_len = symbstr.size() // 8
        for i in range(symbstr_len):
            call_state.memory.store(symbstr_addr + i, symbstr.get_byte(i))
            if symbstr_constraints is not None:
                symbstr_constraint = symbstr_constraints(symbstr.get_byte(i), i)
                if symbstr_constraint is not None:
                    call_state.add_constraints(symbstr_constraint)
            if null_terminate and i == symbstr_len - 1:
                print("nt i: {}".format(i))
                call_state.add_constraints(symbstr.get_byte(i) == 0)
            elif none_null:
                print("nn i: {}".format(i))
                call_state.add_constraints(symbstr.get_byte(i) != 0)


    def trace_hash_func(self, call_state, n=None):
        print(call_state.solver.constraints)
        simgr = self._proj.factory.simgr(call_state)
        simgr.run(n=n)
        ret_states = []
        for state in simgr.deadended:
            ret_states.append(state)
        print(simgr.stashes)
        print(simgr.errored)
        return ret_states

    @abc.abstractmethod
    def _hash_func_call_state(self, *args, extra_options=[]):
        raise NotImplementedError()



class HashFuncRunnerSig1(HashFuncRunner):
    def eval(self, conc_buf, conc_buf_len):
        return self._eval(conc_buf, conc_buf_len)

    def run_conc(self, conc_buf, conc_buf_len):
        return self._run_conc(conc_buf, conc_buf_len)

    def _hash_func_call_state(self, *args, extra_options=[]):
        assert len(args) >= 2
        return self._proj.factory.call_state(self._hash_func_addr, args[0], args[1], add_options=extra_options)

class HashFuncRunnerSig2(HashFuncRunner):
    def eval(self, conc_buf):
        return self._eval(conc_buf)

    def run_conc(self, conc_buf):
        return self._run_conc(conc_buf)

    def _hash_func_call_state(self, *args, extra_options=[]):
        assert len(args) >= 1
        return self._proj.factory.call_state(self._hash_func_addr, args[0], add_options=extra_options)




