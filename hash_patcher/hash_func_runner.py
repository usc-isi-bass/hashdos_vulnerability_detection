import angr
import claripy

import util.angr_util as angr_util

class HashFuncRunner:
    # TODO Consider using manually crafted SimCCs for the factory.call_state calls. If we try to symex patch code, this automatic setup of the call state may fail

    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        self._elf_file_name = elf_file_name
        self._hash_func_addr = hash_func_addr

        if proj is None:
            self._proj = angr.Project(self._elf_file_name, auto_load_libs=False)
        else:
            self._proj = proj

    def eval(self, conc_buf):
        call_state, ret_state, ret_reg = self.run_conc(conc_buf)
        hash_val = ret_state.solver.eval(ret_reg)
        return hash_val

    def run_conc(self, buf):
        buf_len = len(buf)

        call_state = self._proj.factory.call_state(self._hash_func_addr, buf, buf_len, add_options=[angr.options.TRACK_MEMORY_ACTIONS])

        simgr = self._proj.factory.simulation_manager(call_state)

        simgr.run()

        assert len(simgr.deadended) == 1, "We executed the hash func with concrete input, but now we have more than one deadended state?"
        ret_state = simgr.deadended[0]
        ret_reg = angr_util.get_ret_reg(self._proj, ret_state)

        return call_state, ret_state, ret_reg


    def run_symb(self, buf_len):
        symbstr_addr = claripy.BVS(name='buf_addr', size=self._proj.arch.bits)
        call_state = self._proj.factory.call_state(self._hash_func_addr, symbstr_addr, buf_len)
        symbstr = claripy.StringS("buf", buf_len)
        call_state.memory.store(symbstr_addr, symbstr)
        call_state.memory.store(symbstr_addr + buf_len, 0)
        simgr = self._proj.factory.simgr(call_state)
        simgr.run()
        rets = []
        for state in simgr.deadended:
            rets.append((state, angr_util.get_ret_reg(self._proj, state)))
        return rets
