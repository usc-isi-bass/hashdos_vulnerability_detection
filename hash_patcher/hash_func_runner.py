import abc
from abc import ABC

import angr
import claripy

import util.angr_util as angr_util

#CONC_BUFF_ADDR = 0x7fffffffffefff5
CONC_BUFF_ADDR = 0

class HashFuncRunner(ABC):
    # TODO Consider using manually crafted SimCCs for the factory.call_state calls. If we try to symex patch code, this automatic setup of the call state may fail

    def __init__(self, elf_file_name, hash_func_addr, proj=None):
        self._elf_file_name = elf_file_name
        self._hash_func_addr = hash_func_addr

        if proj is None:
            self._proj = angr.Project(self._elf_file_name, auto_load_libs=False)
        else:
            self._proj = proj

        self._run_symb_cache = {}

        # Since we start symex at a call state libc is not initialized.
        # This causes unfortunate behaviour by some simprocs.
        # One example is __ctype_toupper_loc returns None because its table is not initialized
        self._setup_simprocs()

    #def eval(self, conc_buf):
    #    conc_buf_len = len(conc_buf)
    #    # TODO Make signature sensitive
    #    call_state, ret_state = self.run_conc_sig1(conc_buf, conc_buf_len)
    #    ret_reg = angr_util.get_ret_reg(self._proj, ret_state)
    #    hash_val = ret_state.solver.eval(ret_reg)
    #    return hash_val

    @abc.abstractmethod
    def eval(self, *args):
        raise NotImplementedError()

    def _eval(self, *args):
        call_state, ret_state = self.run_conc(*args)
        ret_reg = angr_util.get_ret_reg(self._proj, ret_state)
        hash_val = ret_state.solver.eval(ret_reg)
        return hash_val

    @abc.abstractmethod
    def run_conc(self, *args):
        raise NotImplementedError()

    # TODO add extra options as an argument
    def _run_conc(self, *args):
        call_state = self._hash_func_call_state(*args, extra_options=[angr.options.TRACK_MEMORY_ACTIONS, angr.options.MEMORY_CHUNK_INDIVIDUAL_READS])
        return self.trace_hash_func_conc(call_state)

    #def run_conc_sig1(self, buf, buf_len):
    #    call_state = self.hash_func_call_state(buf, buf_len, extra_options=[angr.options.TRACK_MEMORY_ACTIONS])
    #    #call_state = self._proj.factory.call_state(self._hash_func_addr, buf, buf_len, add_options=[angr.options.TRACK_MEMORY_ACTIONS])
    #    return self.run_conc(call_state)

    #def run_conc_sig2(self, buf):
    #    call_state = self.hash_func_call_state(buf, extra_options=[angr.options.TRACK_MEMORY_ACTIONS])
    #    #call_state = self._proj.factory.call_state(self._hash_func_addr, buf, add_options=[angr.options.TRACK_MEMORY_ACTIONS])
    #    return self.run_conc(call_state)


    def trace_hash_func_conc(self, call_state):
        ret_states = self.trace_hash_func(call_state)

        assert len(ret_states) == 1, "We executed the hash func with concrete input, but now we have more than one deadended state? deadeded states: {}".format(ret_states)
        ret_state = ret_states[0]

        return call_state, ret_state


    def run_symb(self, str_len, null_terminate=True, non_null=True):
        if str_len not in self._run_symb_cache:
            symbstr_addr, symbstr = self.create_symbstr('str_addr', 'str', str_len, null_terminate=null_terminate)
            call_state = self.hash_func_symb_call_state(symbstr_addr, symbstr, str_len, null_terminate=null_terminate, non_null=non_null)
            ret_states = self.trace_hash_func(call_state)

            self._run_symb_cache[str_len] = symbstr_addr, symbstr, ret_states
        else:
             symbstr_addr, symbstr, ret_states = self._run_symb_cache[str_len]
        return symbstr_addr, symbstr, ret_states

    # TODO Make signature sensitive
    def hash_func_symb_call_state(self, symbstr_addr, symbstr, str_len, null_terminate=True, non_null=True, extra_options=[]):
        call_state = self._hash_func_call_state(symbstr_addr, str_len)

        self.store_symbstr(call_state, symbstr_addr, symbstr, null_terminate=null_terminate, non_null=non_null)
        #call_state.add_constraints(symbstr_addr == CONC_BUFF_ADDR)
        #for i in range(buf_len):
        #    call_state.add_constraints(symbstr.get_byte(i) != 0)
        #    call_state.memory.store(symbstr_addr + i, symbstr.get_byte(i))
        #call_state.memory.store(symbstr_addr + buf_len, 0)

        return call_state

    def create_symbstr(self, symbstr_addr_name, symbstr_name, symbstr_len, null_terminate=True):
        symbstr_addr = claripy.BVS(name=symbstr_addr_name, explicit_name=True, size=self._proj.arch.bits)
        if null_terminate:
            buf_len = symbstr_len + 1
        else:
            buf_len = symbstr_len
        symbstr = claripy.BVS(symbstr_name, size=(buf_len) * 8)
        return symbstr_addr, symbstr


    def store_symbstr(self, call_state, symbstr_addr, symbstr, null_terminate=True, non_null=True, symbstr_constraints=None):
        call_state.add_constraints(symbstr_addr == CONC_BUFF_ADDR)
        symbstr_len = symbstr.size() // 8
        for i in range(symbstr_len):
            call_state.memory.store(symbstr_addr + i, symbstr.get_byte(i))
            if symbstr_constraints is not None:
                symbstr_constraint = symbstr_constraints(symbstr.get_byte(i), i)
                if symbstr_constraint is not None:
                    call_state.add_constraints(symbstr_constraint)
            if null_terminate and i == symbstr_len - 1:
                call_state.add_constraints(symbstr.get_byte(i) == 0)
                call_state.memory.store(symbstr_addr + i, 0)
            elif non_null:
                call_state.add_constraints(symbstr.get_byte(i) != 0)


    def trace_hash_func(self, call_state, n=None):
        simgr = self._proj.factory.simgr(call_state)
        simgr.run(n=n)
        ret_states = []
        for state in simgr.deadended:
            ret_states.append(state)
        return ret_states

    @abc.abstractmethod
    def _hash_func_call_state(self, *args, extra_options=[]):
        raise NotImplementedError()


    def _setup_simprocs(self):
        class MyToLowerSimProc(angr.SimProcedure):
            def run(self):
                if self.state.libc.ctype_tolower_loc_table_ptr is None:
                    malloc = angr.SIM_PROCEDURES['libc']['malloc']
                    # 384 entries, 4 bytes each
                    table = self.inline_call(malloc, 384*4).ret_expr
                    table_ptr = self.inline_call(malloc, self.state.arch.bytes).ret_expr

                    for pos, c in enumerate(self.state.libc.TOLOWER_LOC_ARRAY):
                        self.state.memory.store(table + (pos * 4),
                                                self.state.solver.BVV(c, 32),
                                                endness=self.state.arch.memory_endness,
                                                inspect=False,
                                                disable_actions=True,
                                                )

                    # Offset for negative chars: -128 index (4 bytes per index)
                    table += (128 * 4)
                    self.state.memory.store(table_ptr,
                                            table,
                                            size=self.state.arch.bytes,
                                            endness=self.state.arch.memory_endness,
                                            inspect=False,
                                            disable_actions=True,
                                            )

                    self.state.libc.ctype_tolower_loc_table_ptr = table_ptr
                return self.state.libc.ctype_tolower_loc_table_ptr
        self._proj.hook_symbol('__ctype_tolower_loc', MyToLowerSimProc())
        class MyToUpperSimProc(angr.SimProcedure):
            def run(self):
                if self.state.libc.ctype_toupper_loc_table_ptr is None:
                    malloc = angr.SIM_PROCEDURES['libc']['malloc']
                    # 384 entries, 4 bytes each
                    table = self.inline_call(malloc, 384*4).ret_expr
                    table_ptr = self.inline_call(malloc, self.state.arch.bytes).ret_expr

                    for pos, c in enumerate(self.state.libc.TOUPPER_LOC_ARRAY):
                        self.state.memory.store(table + (pos * 4),
                                                self.state.solver.BVV(c, 32),
                                                endness=self.state.arch.memory_endness,
                                                inspect=False,
                                                disable_actions=True,
                                                )

                    # Offset for negative chars: -128 index (4 bytes per index)
                    table += (128 * 4)
                    self.state.memory.store(table_ptr,
                                            table,
                                            size=self.state.arch.bytes,
                                            endness=self.state.arch.memory_endness,
                                            inspect=False,
                                            disable_actions=True,
                                            )

                    self.state.libc.ctype_toupper_loc_table_ptr = table_ptr
                return self.state.libc.ctype_toupper_loc_table_ptr
        self._proj.hook_symbol('__ctype_toupper_loc', MyToLowerSimProc())



class HashFuncRunnerSig1(HashFuncRunner):
    def eval(self, conc_buf, conc_buf_len):
        return self._eval(conc_buf, conc_buf_len)

    def run_conc(self, conc_buf, conc_buf_len):
        return self._run_conc(conc_buf, conc_buf_len)

    def _hash_func_call_state(self, *args, extra_options=[]):
        assert len(args) >= 2
        buf = args[0]
        l = args[1]
        if isinstance(buf, str):
            buf = buf.encode('ascii')
        call_state = self._proj.factory.call_state(self._hash_func_addr, buf, l, add_options=extra_options)
        return call_state

class HashFuncRunnerSig2(HashFuncRunner):
    def eval(self, conc_buf):
        return self._eval(conc_buf)

    def run_conc(self, conc_buf):
        return self._run_conc(conc_buf)

    def _hash_func_call_state(self, *args, extra_options=[]):
        assert len(args) >= 1
        buf = args[0]
        if isinstance(buf, str):
            buf = buf.encode('ascii')
        call_state = self._proj.factory.call_state(self._hash_func_addr, buf, add_options=extra_options)
        return call_state




