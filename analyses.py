import angr
import time
import itertools
import networkx as nx
import logging
import bip_manual_hooking

import common_input_functions

l = logging.getLogger(name=__name__)
l.setLevel('DEBUG')
#l.setLevel('ERROR')

def analyze(elf_file):
    result_dict = {}
    hash_symbols_to_search = ['hcreate', 'hcreate_r', 'hsearch', 'hsearch_r']
    path_set = set()
    result_dict['path'] = path_set # If we update path_set, it should update in the dict too, right?
    input_symbols = set(['fgets', 'gets', 'fgetc', 'recv', 'rcvfrom', 'recvmsg', 'read', 'fread', 'scanf', 'sscanf', 'fscanf', 'vscanf', 'vsscanf', 'vfscanf', 'getchar', 'getline', 'getdelim'])
    for hash_symbol in hash_symbols_to_search:
        result_dict[hash_symbol] = False
    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        #cfg = proj.analyses.CFGEmulated(context_sensitivity_level=1)
        cfg_fast = proj.analyses.CFGFast()
        input_hash_pairs = set()
        for hash_symbol in hash_symbols_to_search:
            contains_symbol = (proj.loader.main_object.get_symbol(hash_symbol) is not None)
            result_dict[hash_symbol] = contains_symbol
            if contains_symbol:
                hash_func = cfg_fast.functions.function(name=hash_symbol)
                hash_nodes = cfg_fast.model.get_all_nodes(addr=hash_func.addr)
                for input_symbol in input_symbols:
                    if proj.loader.main_object.get_symbol(input_symbol) is not None:
                        # It contains both the hash symbol and input symbol so check for a path between these two
                        input_func = cfg_fast.functions.function(name=input_symbol)
                        input_nodes = cfg_fast.model.get_all_nodes(addr=input_func.addr)
                        for input_node, hash_node in itertools.product(input_nodes, hash_nodes):
                            has_path = nx.has_path(cfg_fast.graph, input_node, hash_node)
                            if has_path:
                                input_hash_pairs.add(((input_symbol, input_func.addr), (hash_symbol, hash_func.addr)))
                                path_set.add("{}@0x{}->{}@0x{}".format(input_symbol, input_func.addr, hash_symbol, hash_func.addr))


    except Exception as e:
        #raise e
        result_dict['err'] = str(e)
    return result_dict

def intermediate_static_analysis(elf_file, get_hash_funcs):
    input_function_names = set(['fgets', 'gets', 'fgetc', 'recv', 'rcvfrom', 'recvmsg', 'read', 'fread', 'scanf', 'sscanf', 'fscanf', 'vscanf', 'vsscanf', 'vfscanf', 'getchar', 'getline', 'getdelim', 'SSL_read'])
    result_dict = {}   
    result_dict['analysis_metrics'] = {}
    result_dict['analysis_metrics']['hit'] = False

    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        cfg_fast = proj.analyses.CFGFast()
        target_nodes = set()
        target_node_addrs = set()
        for hash_func in get_hash_funcs(proj, cfg_fast, result_dict):
            target_node = cfg_fast.model.get_any_node(addr=hash_func.addr)
            target_nodes.add(target_node)
            target_node_addrs.add(target_node.addr)

        result_dict['static_analysis'] = {}
 
        callgraph = cfg_fast.functions.callgraph
        for input_func_name in input_function_names:
            cfg_fast = proj.analyses.CFGFast() # XXX It appears as if angr's CFGEmulated has some side effects on CFGFast. If we search for "read" first and then "fgets", CFGFast doesn't find "fgets", but if we search for "fgets" first, it does (what even?). So, we recreate CFGFast for every input function.
            input_func = cfg_fast.functions.function(name=input_func_name)
            if not input_func:
                continue
            input_func_ancestors = nx.ancestors(callgraph, input_func.addr).union({input_func.addr}) # For simplicity, assume a function is its own ancestor as well.
            #print("Input ancestors: ", [cfg_fast.functions.function(addr=cfg_fast.get_any_node(addr=addr).function_address).name for addr in input_func_ancestors])
            for target_node in target_nodes:
                target_func = cfg_fast.functions.function(addr=target_node.function_address)
                if not target_func: # TODO why would angr do this? :/
                    continue
                input_target_pair_label = str(("{}@0x{:x}".format(input_func.name, input_func.addr), "{}@0x{:x}".format(target_func.name, target_func.addr)))
                result_dict['static_analysis'][input_target_pair_label] = []
                target_func_ancestors = nx.ancestors(callgraph, target_func.addr).union({target_func.addr}) # For simplicity, assume a function is its own ancestor as well.
                #print("Target ancestors: ", [cfg_fast.functions.function(addr=cfg_fast.get_any_node(addr=addr).function_address).name for addr in target_func_ancestors])
                start_func_candidate_addrs = input_func_ancestors.intersection(target_func_ancestors)
                #print("Starts: {}".format(start_func_candidate_addrs))
                if len(start_func_candidate_addrs) == 0:
                    #print("No start function candidates!")
                    continue
                # Only consider those addresses that do not have outgoing edges to other addrs in the start candidate set (since the ancestors of each start candidate is also a start candidate, this should keep the paths shorter)
                filtered_start_func_candidate_addrs = set()
                for start_func_addr in start_func_candidate_addrs:
                    successor_in_start_addrs = False
                    for successor in callgraph.successors(start_func_addr):
                        if successor in start_func_candidate_addrs:
                            successor_in_start_addrs = True
                            break
                    if not successor_in_start_addrs:
                        filtered_start_func_candidate_addrs.add(start_func_addr)
                if len(filtered_start_func_candidate_addrs) > 0:
                    l.debug("Filtered out {} start candidates".format(len(start_func_candidate_addrs) - len(filtered_start_func_candidate_addrs)))
                    start_func_candidate_addrs = filtered_start_func_candidate_addrs
                l.debug("We have {} start candidates".format(len(start_func_candidate_addrs)))
    
    
                for start_func_addr in start_func_candidate_addrs:
                    start_func = cfg_fast.functions.function(addr=start_func_addr)
                    if start_func is None:
                        err_msg = "Could not find start func with addr: 0x{:x}".format(start_func_addr)
                        if 'err' in result_dict:
                            result_dict['err'].append(err_msg)
                        else:
                            result_dict['err'] = [err_msg]
                        continue
                    start_func_label = "{}@0x{:x}".format(start_func.name, start_func_addr)
                    partial_results_dict = {
                        'start':start_func_label,
                        'num_cfge_nodes':None,
                        'has_start_input_path':None,
                        'has_start_target_path':None,
                        'has_input_target_path':None,
                        'num_ddg_nodes':None,
                        'ddg_srcs':None,
                        'ddg_sinks':None,
                        'bs_targets':None,
                        'bs_start_wlisted':None,
                        'bs_input_wlisted':None,
                        'ddg_source_sink_path':None
                    }
                    result_dict['static_analysis'][input_target_pair_label].append(partial_results_dict)
                    l.debug("start candidate: {}".format(start_func_label))
                    l.debug("calculating paths from start to input")
                    # networkx doesn't like it when you ask if there are any paths between identical nodes... :(
                    if start_func_addr == input_func.addr:
                        start_input_paths = [[start_func_addr]]
                    else:
                        start_input_paths = list(nx.all_simple_paths(callgraph, start_func_addr, input_func.addr))

                    l.debug("calculating paths from start to target")
                    if start_func_addr == target_func.addr:
                        start_target_paths = [[start_func_addr]]
                    else:
                        start_target_paths = list(nx.all_simple_paths(callgraph, start_func_addr, target_func.addr))
    
                    whitelisted_addrs = set() # Set of addrs of whitelisted funcs
                    #print("Input paths:")
                    l.debug("creating whitelist")
                    for path in start_input_paths:
                        for addr in path:
                            #print("{:x}, ".format(addr), end='')
                            whitelisted_addrs.add(addr)
                        #print("")
                    #print("Target paths:")
                    for path in start_target_paths:
                        for addr in path:
                            #print("{:x}, ".format(addr), end='')
                            whitelisted_addrs.add(addr)
                        #print("")
                    
                    # Adding addresses of the input function to the whitelist
                    whitelisted_addrs.add(input_func.addr)
                    for addr in input_func.block_addrs:
                        whitelisted_addrs.add(addr)
                    # Adding addresses of the target function to the whitelist
                    whitelisted_addrs.add(target_func.addr)
                    for addr in target_func.block_addrs:
                        whitelisted_addrs.add(addr)
                    l.debug("extending whitelist")
                    extended_whitelisted_addrs = set(whitelisted_addrs) # We this use as the "visited" set for the DFS as well.
                    stack = list(whitelisted_addrs)
                    while len(stack) > 0:
                        curr_addr = stack.pop()
                        curr_func = cfg_fast.functions.function(addr=curr_addr)
                        if not curr_func:
                            continue
                        for callsite_addr in curr_func.get_call_sites():
                            call_target_func_addr = curr_func.get_call_target(callsite_addr)
                            if not call_target_func_addr in extended_whitelisted_addrs:
                                call_target_func = cfg_fast.functions.function(addr=call_target_func_addr)
                                if not call_target_func:
                                    continue
                                for addr in call_target_func.block_addrs:
                                    extended_whitelisted_addrs.add(addr)
                                extended_whitelisted_addrs.add(call_target_func_addr)
                                stack.append(call_target_func_addr)
                        for jmpout_site_addr in curr_func.jumpout_sites:
                            for target in cfg_fast.model.get_all_successors(cfg_fast.model.get_any_node(jmpout_site_addr)):
                                target_addr = target.addr
                                #print("Successor: {:x}".format(target_addr))
                                if not target_addr in extended_whitelisted_addrs:
                                    extended_whitelisted_addrs.add(target_addr)
                                    stack.append(target_addr)
                            
                    l.debug("We have {} whitelist addrs".format(len(whitelisted_addrs)))
                    l.debug("We have {} extended whitelist addrs".format(len(extended_whitelisted_addrs)))
     
                    l.debug("Constructing the emulated CFG")
                    cfg_slow_addr_whitelist = set()
                    for addr in extended_whitelisted_addrs:
                        cfg_slow_addr_whitelist.add(addr)
                        if addr not in cfg_fast.functions:
                            continue
                        for node in cfg_fast.functions[addr].nodes:
                            cfg_slow_addr_whitelist.add(node.addr)
                    #cfg_slow_addr_whitelist = extended_whitelisted_addrs.union(set([node.addr for node in cfg_fast.functions[addr].nodes for addr in extended_whitelisted_addrs]))
                    starts = [start_func_addr]
                    cfg_slow = proj.analyses.CFGEmulated(context_sensitivity_level=1, normalize=True, resolve_indirect_jumps=True, starts=starts, address_whitelist=cfg_slow_addr_whitelist, state_add_options=angr.sim_options.refs, keep_state=True)
                    #cfg_slow.remove_fakerets() # We cannot remove fakerets, because there is mostly not a path through the input function (even if we hook it).
                    l.debug("Emulated CFG constructed: {} nodes".format(len(cfg_slow.graph.nodes)))
                    partial_results_dict['num_cfge_nodes'] = len(cfg_slow.graph.nodes)
                    #nx.drawing.nx_pydot.write_dot(cfg_fast.graph, "cfg_fast_{}_{}.dot".format(input_func.name, target_func.name))
                    #nx.drawing.nx_pydot.write_dot(cfg_slow.graph, "cfg_slow_{}_{}.dot".format(input_func.name, target_func.name))

                    cfg_slow_start_node = cfg_slow.model.get_any_node(addr=start_func_addr)
                    if cfg_slow_start_node is None:
                        err_msg =  "Could not find func with addr 0x{:x} in CFGE for start func.".format(start_func_addr)
                        err_node = cfg_slow.model.get_any_node(addr=start_func_addr)
                        if err_node is None:
                            err_msg += " No node found with that address."
                        else:
                            err_func = cfg_slow.functions.function(addr=err_node.function_address)
                            if err_func is None:
                                err_msg += " Could not find function of node {} with function_address=0x{:x}".format(err_node, err_node.function_address)
                            else:
                                err_msg += " In CFGE, that addr is in func {}@0x{:x}".format(err_func, err_func.addr)
                        if 'err' in result_dict:
                            result_dict['err'].append(err_msg)
                        else:
                            result_dict['err'] = [err_msg]
                        continue
                    cfg_slow_input_node = cfg_slow.model.get_any_node(addr=input_func.addr)
                    if cfg_slow_input_node is None:
                        err_msg =  "Could not find func with addr 0x{:x} in CFGE for input func.".format(input_func.addr)
                        err_node = cfg_slow.model.get_any_node(addr=input_func.addr)
                        if err_node is None:
                            err_msg += " No node found with that address."
                        else:
                            err_func = cfg_slow.functions.function(addr=err_node.function_address)
                            if err_func is None:
                                err_msg += " Could not find function of node {} with function_address=0x{:x}".format(err_node, err_node.function_address)
                            else:
                                err_msg += " In CFGE, that addr is in func {}@0x{:x}".format(err_func, err_func.addr)
                        if 'err' in result_dict:
                            result_dict['err'].append(err_msg)
                        else:
                            result_dict['err'] = [err_msg]
                        continue
                    cfg_slow_target_node = cfg_slow.model.get_any_node(addr=target_func.addr)
                    if cfg_slow_target_node is None:
                        err_msg =  "Could not find func with addr 0x{:x} in CFGE for target func.".format(target_func.addr)
                        err_node = cfg_slow.model.get_any_node(addr=target_func.addr)
                        if err_node is None:
                            err_msg += " No node found with that address."
                        else:
                            err_func = cfg_slow.functions.function(addr=err_node.function_address)
                            if err_func is None:
                                err_msg += " Could not find function of node {} with function_address=0x{:x}".format(err_node, err_node.function_address)
                            else:
                                err_msg += " In CFGE, that addr is in func {}@0x{:x}".format(err_func, err_func.addr)
                        if 'err' in result_dict:
                            result_dict['err'].append(err_msg)
                        else:
                            result_dict['err'] = [err_msg]
                        continue
                    has_path_start_input = nx.has_path(cfg_slow.graph, cfg_slow_start_node, cfg_slow_input_node)
                    partial_results_dict['has_start_input_path'] = has_path_start_input
                    has_path_start_target = nx.has_path(cfg_slow.graph, cfg_slow_start_node, cfg_slow_target_node) 
                    partial_results_dict['has_start_target_path'] = has_path_start_target
                    has_path_input_target = nx.has_path(cfg_slow.graph, cfg_slow_input_node, cfg_slow_target_node) 
                    partial_results_dict['has_input_target_path'] = has_path_input_target

                    bs_targets = backward_slice_target_selection(target_func, cfg_slow)
                    partial_results_dict['bs_targets'] = ["0x{:x}[{}]".format(node.addr, i) for node, i in bs_targets]
               
                    #l.debug("Done")
                    #l.debug("Constructing CDG")
                    cdg = proj.analyses.CDG(cfg_slow, start=start_func_addr)
                    #l.debug("Done")
                    #l.debug("Constructing DDG")
                    ddg = proj.analyses.DDG(cfg_slow, start=start_func_addr)
                    partial_results_dict['num_ddg_nodes'] = len(ddg.graph.nodes)
                    ddg_sources = [node for node in ddg.graph.nodes if node.block_addr == input_func.addr]
                    ddg_sinks = [node for node in ddg.graph.nodes if any(node.block_addr == bs_target_addr and node.stmt_idx == bs_target_stmt_idx for bs_target_addr, bs_stmt_idx in bs_targets)]
                    partial_results_dict['ddg_srcs'] = ["0x{:x}[{}]".format(node.block_addr, node.stmt_idx) for node in ddg_sources]
                    partial_results_dict['ddg_sinks'] = ["0x{:x}[{}]".format(node.block_addr, node.stmt_idx) for node in ddg_sinks]
                    ddg_source_sink_paths = ['{} -> {}'.format(source, sink) for source, sink in itertools.product(ddg_sources, ddg_sinks) if nx.has_path(ddg.graph, source, sink)]
                    partial_results_dict['ddg_source_sink_path'] = ddg_source_sink_paths
                    if len(ddg_source_sink_paths) > 0:
                        result_dict['analysis_metrics']['hit'] = True
                    #l.debug("Done")
                    #l.debug("Constructing BS")
                    bs = proj.analyses.BackwardSlice(cfg_slow, cdg=cdg, ddg=ddg, targets=bs_targets)
                    #l.debug("Done")
                    #l.debug("Constructing Annotated CFG")
                    bs_acfg = bs.annotated_cfg()
                    partial_results_dict['bs_start_wlisted'] = bs_acfg.get_whitelisted_statements(start_func.addr)
                    partial_results_dict['bs_input_wlisted'] = bs_acfg.get_whitelisted_statements(input_func.addr)
                    #l.debug("Done")
    except Exception as e:
        #raise e
        l.debug("Exception: {}".format(str(e)))
        if 'err' in result_dict:
            result_dict['err'].append(str(e))
        else:
            result_dict['err'] = [str(e)]

    return result_dict


                   
 

# Lightweight analysis: Get the hash functions in the program, and see if there exists a cfg_fast path from an input func
def analyze4(elf_file, get_hash_funcs):
    result_dict = {}
    path_set = set()
    hash_set = set()
    result_dict['path'] = path_set # If we update path_set, it should update in the dict too, right?
    result_dict['hash_funcs'] = hash_set
    input_symbols = set(['fgets', 'gets', 'fgetc', 'recv', 'rcvfrom', 'recvmsg', 'read', 'fread', 'scanf', 'sscanf', 'fscanf', 'vscanf', 'vsscanf', 'vfscanf', 'getchar', 'getline', 'getdelim'])
    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        #cfg = proj.analyses.CFGEmulated(context_sensitivity_level=1)
        cfg_fast = proj.analyses.CFGFast()
        for hash_func in get_hash_funcs(proj, cfg_fast):

            hash_name = hash_func.name
            hash_nodes = cfg_fast.model.get_all_nodes(addr=hash_func.addr)
            for input_symbol in input_symbols:
                if proj.loader.main_object.get_symbol(input_symbol) is not None:
                    # It contains both the hash symbol and input symbol so check for a path between these two
                    input_func = cfg_fast.functions.function(name=input_symbol)
                    input_nodes = cfg_fast.model.get_all_nodes(addr=input_func.addr)
                    for input_node, hash_node in itertools.product(input_nodes, hash_nodes):
                        has_path = nx.has_path(cfg_fast.graph, input_node, hash_node)
                        if has_path:
                            path_set.add("{}@0x{}->{}@0x{}".format(input_symbol, input_func.addr, hash_func.name, hash_func.addr))

    except Exception as e:
        #raise e
        result_dict['err'] = str(e)
    return result_dict

def analyze_get_just_hash(elf_file, get_hash_funcs):
    analysis_start_time = time.time()
    result_dict = {}
    result_dict['analysis_metrics'] = {}
    result_dict['analysis_metrics']['hit'] = False
    path_set = set()
    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        cfg_fast = proj.analyses.CFGFast()
        for hash_func in get_hash_funcs(proj, cfg_fast, result_dict):
            # Just indicate that we found something, don't do anything else, get_hash_funcs will put the discovered hash functions in result_dict
            result_dict['analysis_metrics']['hit'] = True
            pass
    except Exception as e:
        #raise e
        result_dict['err'] = str(e)
    analysis_end_time = time.time()
    analysis_time_delta = analysis_end_time - analysis_start_time
    result_dict['analysis_metrics']['total_time'] = analysis_time_delta
    return result_dict


def analyze2(elf_file):
    input_function_names = set(['fgets', 'gets', 'fgetc', 'recv', 'rcvfrom', 'recvmsg', 'read', 'fread', 'scanf', 'sscanf', 'fscanf', 'vscanf', 'vsscanf', 'vfscanf', 'getchar', 'getline', 'getdelim'])
    hash_symbols_to_search = ['hsearch', 'hsearch_r']
    result_dict = {}
    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        cfg_fast = proj.analyses.CFGFast()
        target_nodes = set()
        target_node_addrs = set()
        for hash_symbol in hash_symbols_to_search:
            hash_func = cfg_fast.functions.function(name=hash_symbol)
            if hash_func:
                target_node = cfg_fast.model.get_any_node(addr=hash_func.addr)
                target_nodes.add(target_node)
                target_node_addrs.add(target_node.addr)
    
        # State inspection break point functions
        # Keep track of symvars created in the source function
        def act_symbolic_variable(state):
            #l.debug("State {} creates symvar {}".format(state, state.inspect.symbolic_expr))
            state_node = cfg_fast.model.get_any_node(addr=state.addr)
            if not state_node:
                state_node = cfg_fast.model.get_any_node(addr=state.addr, anyaddr=True)
            if not state_node:
                l.error("Could not find node for address: {}".format(state.addr))
                return
    
            state_func = cfg_fast.functions.function(addr=state_node.function_address)
            if state_func and state_func.name == input_func_name:
                #print('State {} creates {} {}'.format(state, state.inspect.symbolic_name, type(state.inspect.symbolic_name)))
                state.globals['symvars_write'].update(state.inspect.symbolic_expr.variables)
    
        # If a mem/reg/tmp write occurrs that is dependent on a variable in the tracked variables, put write dst variables also in the tracked variable set.
        def act_mem_write(state):
            #l.debug("State {} mem writes {} to {}".format(state, state.inspect.mem_write_expr, state.inspect.mem_write_address))
            if state.inspect.mem_write_expr.variables.intersection(state.globals['symvars_write']):
                #print("State {} writes {} to mem {}".format(state, state.inspect.mem_write_expr, state.inspect.mem_write_address))
                mem_write_address = state.inspect.mem_write_address
                if type(mem_write_address) == int: # For some reason the mem_write_address is sometimes an int.
                    state.globals['symvars_write'].update(state.solver.BVV(mem_write_address, 64))
                else:
                    state.globals['symvars_write'].update(mem_write_address.variables)
    
        # if a mem_read occurrs in the target function, add it to a different set.
        def act_mem_read(state):
            #l.debug("State {} mem reads {} from {}".format(state, state.inspect.mem_read_expr, state.inspect.mem_read_address))
            state_node = cfg_fast.model.get_any_node(addr=state.addr)
            if not state_node:
                state_node = cfg_fast.model.get_any_node(addr=state.addr, anyaddr=True)
            if not state_node:
                l.error("Could not find node for address: {}".format(state.addr))
                return
            if state_node.addr == state.globals['target_addr']:
                state.globals['symvars_read'].update(state.inspect.mem_read_expr.variables)
                #print('State {} reads {} {} {} from {}'.format(state, state.inspect.mem_read_expr, type(state.inspect.mem_read_expr), list(state.inspect.mem_read_expr.variables), state.inspect.mem_read_address))
    
        #l.debug("Target nodes: {}".format(["{}@{:x}".format(node, node.addr) for node in target_nodes]))
        callgraph = cfg_fast.functions.callgraph
        for input_func_name in input_function_names:
            input_func = cfg_fast.functions.function(name=input_func_name)
            if not input_func:
                continue
            input_func_ancestors = nx.ancestors(callgraph, input_func.addr).union({input_func.addr}) # For simplicity, assume a function is its own ancestor as well.
            #print("Input ancestors: ", [cfg_fast.functions.function(addr=cfg_fast.get_any_node(addr=addr).function_address).name for addr in input_func_ancestors])
            for target_node in target_nodes:
                target_func = cfg_fast.functions.function(addr=target_node.function_address)
                target_func_ancestors = nx.ancestors(callgraph, target_func.addr).union({target_func.addr}) # For simplicity, assume a function is its own ancestor as well.
                #print("Target ancestors: ", [cfg_fast.functions.function(addr=cfg_fast.get_any_node(addr=addr).function_address).name for addr in target_func_ancestors])
                start_func_candidate_addrs = input_func_ancestors.intersection(target_func_ancestors)
                #print("Starts: {}".format(start_func_candidate_addrs))
                if len(start_func_candidate_addrs) == 0:
                    #print("No start function candidates!")
                    continue
                # Only consider those addresses that do not have outgoing edges to other addrs in the start candidate set (since the ancestors of each start candidate is also a start candidate, this should keep the paths shorter)
                filtered_start_func_candidate_addrs = set()
                for start_func_addr in start_func_candidate_addrs:
                    successor_in_start_addrs = False
                    for successor in callgraph.successors(start_func_addr):
                        if successor in start_func_candidate_addrs:
                            successor_in_start_addrs = True
                            break
                    if not successor_in_start_addrs:
                        filtered_start_func_candidate_addrs.add(start_func_addr)
                if len(filtered_start_func_candidate_addrs) > 0:
                    l.debug("Filtered out {} start candidates".format(len(start_func_candidate_addrs) - len(filtered_start_func_candidate_addrs)))
                    start_func_candidate_addrs = filtered_start_func_candidate_addrs
                l.debug("We have {} start candidates".format(len(start_func_candidate_addrs)))
    
    
                for start_func_addr in start_func_candidate_addrs:
                    # networkx doesn't like it when you ask if there are any paths between identical nodes... :(
                    if start_func_addr == input_func.addr:
                        start_input_paths = [[start_func_addr]]
                    else:
                        start_input_paths = list(nx.all_simple_paths(callgraph, start_func_addr, input_func.addr))
                    if start_func_addr == target_func.addr:
                        start_target_paths = [[start_func_addr]]
                    else:
                        start_target_paths = list(nx.all_simple_paths(callgraph, start_func_addr, target_func.addr))
                    #print("Input: {}@0x{:x}, Target: {}@0x{:x}, Start: 0x{:x}".format(input_func.name, input_func.addr, target_func.name, target_func.addr, start_func_addr))
    
                    state = proj.factory.blank_state(addr=start_func_addr)
                    state.globals['symvars_write'] = set([])
                    state.globals['symvars_read'] = set([])
                    state.globals['visited'] = set([])
                    state.globals['target_addr'] = target_node.addr
                    
                    state.inspect.b('symbolic_variable', when=angr.BP_AFTER, action=act_symbolic_variable)
                    state.inspect.b('mem_write', when=angr.BP_AFTER, action=act_mem_write)
                    #state.inspect.b('reg_write', when=angr.BP_AFTER, action=act_reg_write)
                    #state.inspect.b('tmp_write', when=angr.BP_AFTER, action=act_tmp_write)
                    state.inspect.b('mem_read', when=angr.BP_AFTER, action=act_mem_read)
                    #state.inspect.b('constraints', when=angr.BP_AFTER, action=act_constraints)
                    state.options.add(angr.sim_options.TRACK_ACTION_HISTORY)
                    #state.regs.sp = 0
                    #state.regs.bp = 0
    
                    whitelisted_funcs = set() # Set of addrs of whitelisted funcs
                    #print("Input paths:")
                    for path in start_input_paths:
                        for addr in path:
                            #print("{:x}, ".format(addr), end='')
                            whitelisted_funcs.add(addr)
                        #print("")
                    #print("Target paths:")
                    for path in start_target_paths:
                        for addr in path:
                            #print("{:x}, ".format(addr), end='')
                            whitelisted_funcs.add(addr)
                        #print("")
                    #whitelisted_funcs.add(addr for addr in start_input_paths).union(set(addr for addr in start_target_paths))
                    #print("whitelisted blocks: {}".format(["{:x}".format(addr) for addr in whitelisted_funcs]))
                    hooks_added = set()
                    extended_whitelisted_funcs = set(whitelisted_funcs) # We this use as the "visited" set for the DFS as well.
                    stack = list(whitelisted_funcs)
                    while len(stack) > 0:
                        curr_func_addr = stack.pop()
                        ###curr_func = cfg_slow.functions.function(addr=curr_func_addr)
                        curr_func = cfg_fast.functions.function(addr=curr_func_addr)
                        if not curr_func:
                            continue
                        for callsite_addr in curr_func.get_call_sites():
                            target_func_addr = curr_func.get_call_target(callsite_addr)
                            if not target_func_addr in extended_whitelisted_funcs:
                                extended_whitelisted_funcs.add(target_func_addr)
                                if target_func_addr not in whitelisted_funcs and not proj.is_hooked(target_func_addr):
                                    proj.hook(target_func_addr, angr.procedures.stubs.ReturnUnconstrained.ReturnUnconstrained())
                                    hooks_added.add(target_func_addr)
                                stack.append(target_func_addr)
                        #for jmpout_site_addr in curr_func.jumpout_sites:
                        #    ###for target in cfg_slow.get_all_successors(cfg_slow.get_any_node(jmpout_site_addr)):
                        #    for target in cfg_fast.model.get_all_successors(cfg_fast.model.get_any_node(jmpout_site_addr)):
                        #        target_addr = target.addr
                        #        #print("Successor: {:x}".format(target_addr))
                        #        if not target_addr in extended_whitelisted_funcs:
                        #            extended_whitelisted_funcs.add(target_addr)
                        #            stack.append(target_addr)
    
                            
                    l.debug("We have {} whitelist funcs".format(len(whitelisted_funcs)))
                    l.debug("We have {} extended whitelist funcs".format(len(extended_whitelisted_funcs)))
                    def avoid_func(state):
                        ###state_node = cfg_slow.get_any_node(addr=state.addr)
                        state_node = cfg_fast.model.get_any_node(addr=state.addr)
                        if not state_node:
                            ###state_node = cfg_slow.get_any_node(addr=state.addr, anyaddr=True)
                            state_node = cfg_fast.model.get_any_node(addr=state.addr, anyaddr=True)
                        state_func_addr = state_node.function_address
                        
                        return not (state_func_addr in extended_whitelisted_funcs)
                    l.debug("Constructing the emulated CFG")
                    cfg_slow = proj.analyses.CFGEmulated(context_sensitivity_level=1, starts=whitelisted_funcs, address_whitelist=extended_whitelisted_funcs, state_add_options=angr.sim_options.refs, keep_state=True)
                    l.debug("Done")
                    l.debug("Constructing CDG")
                    cdg = proj.analyses.CDG(cfg_slow)
                    l.debug("Done")
                    l.debug("Constructing DDG")
                    ddg = proj.analyses.DDG(cfg_slow)
                    l.debug("Done")
                                
    
                    simgr = proj.factory.simgr(state)
                    #dfs_explore_tech = angr.exploration_techniques.DFS()
                    #simgr.use_technique(dfs_explore_tech)
    
                    symex_visited = set()
                    found_states = set()
                    done = False
                    step_counter = 0
                    step_count_limit = 50
                    while len(simgr.active) >= 1:
                        for state in simgr.active:
                            # TODO Maybe you can here check for a data dependency before descending into a call instruction? How does one skip over functions?
                            state_block = state.block()
                            #if state_block.addr == target_node.addr:
                            #    found_states.add(state)
                            #    simgr.step() # Step the target block
                            #    l.debug("symvars read: {}".format(state.globals['symvars_read']))
                            #    l.debug("symvars write: {}".format(state.globals['symvars_write']))
                            #    if state.globals['symvars_read'].intersection(state.globals['symvars_write']):
                            #        return True
                            if state.globals['symvars_read'].intersection(state.globals['symvars_write']):
                                result_dict[((input_func.name, input_func.addr), (target_func.name, target_func.addr))] = True
                                done = True
                                break
                        if done:
                            break
    
                        if avoid_func(state):
                            simgr.move('active', 'force_stopped', filter_func=lambda s: s == state)
                        if state.addr in state.globals['visited']:
                            simgr.move('active', 'revisited', filter_func=lambda s: s == state)
                        else:
                            state.globals['visited'].add(state.addr)
                        if state.addr in symex_visited:
                            simgr.move('active', 'revisited', filter_func=lambda s: s == state)
                        else:    
                            symex_visited.add(state.addr)
            
                        simgr.step()
                        step_counter += 1
                        if step_count_limit >= 0 and step_counter > step_count_limit:
                            break
                    #'''
                    #print("Done with symex; steps = {}".format(step_counter))
                    for addr in hooks_added:
                        proj.unhook(addr)
    except Exception as e:
        raise e
        l.debug("Exception: {}".format(str(e)))
        result_dict['err'] = str(e)
    return result_dict


def analyze3(elf_file, get_hash_funcs):
    #input_function_names = set(['fgets', 'gets', 'fgetc', 'recv', 'rcvfrom', 'recvmsg', 'read', 'fread', 'scanf', 'sscanf', 'fscanf', 'vscanf', 'vsscanf', 'vfscanf', 'getchar', 'getline', 'getdelim'])
    input_function_names = set(['SSL_read'])
    result_dict = {}   

    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        #proj.hook_symbol('mylog', angr.procedures.stubs.ReturnUnconstrained.ReturnUnconstrained())
        #proj.hook_symbol('clock_gettime', angr.procedures.stubs.ReturnUnconstrained.ReturnUnconstrained())
        #proj.hook_symbol('fatal', angr.procedures.stubs.ReturnUnconstrained.ReturnUnconstrained())
        #proj.hook_symbol('strlen', angr.procedures.stubs.ReturnUnconstrained.ReturnUnconstrained())
        #proj.hook_symbol('irc_line_to_string', angr.procedures.stubs.ReturnUnconstrained.ReturnUnconstrained())
        #common_input_functions.hook_input_funcs(proj)
        cfg_fast = proj.analyses.CFGFast()
        target_nodes = set()
        target_node_addrs = set()
        for hash_func in get_hash_funcs(proj, cfg_fast, result_dict):
            if hash_func.name == 'md5_process': # This is only for bip
                continue
            target_node = cfg_fast.model.get_any_node(addr=hash_func.addr)
            target_nodes.add(target_node)
            target_node_addrs.add(target_node.addr)
        l.debug("Hash func search results:")
        l.debug(result_dict['hash_funcs'])
    
 
        #l.debug("Target nodes: {}".format(["{}@{:x}".format(node, node.addr) for node in target_nodes]))
        callgraph = cfg_fast.functions.callgraph
        for input_func_name in input_function_names:
            cfg_fast = proj.analyses.CFGFast() # XXX It appears as if angr's CFGEmulated has some side effects on CFGFast. If we search for "read" first and then "fgets", CFGFast doesn't find "fgets", but if we search for "fgets" first, it does (what even?). So, we recreate CFGFast for every input function.
            input_func = cfg_fast.functions.function(name=input_func_name)
            if not input_func:
                continue
            input_func_ancestors = nx.ancestors(callgraph, input_func.addr).union({input_func.addr}) # For simplicity, assume a function is its own ancestor as well.
            #print("Input ancestors: ", [cfg_fast.functions.function(addr=cfg_fast.get_any_node(addr=addr).function_address).name for addr in input_func_ancestors])
            for target_node in target_nodes:
                target_func = cfg_fast.functions.function(addr=target_node.function_address)
                if not target_func: # TODO why would angr do this? :/
                    continue
                target_func_ancestors = nx.ancestors(callgraph, target_func.addr).union({target_func.addr}) # For simplicity, assume a function is its own ancestor as well.
                #print("Target ancestors: ", [cfg_fast.functions.function(addr=cfg_fast.get_any_node(addr=addr).function_address).name for addr in target_func_ancestors])
                start_func_candidate_addrs = input_func_ancestors.intersection(target_func_ancestors)
                #print("Starts: {}".format(start_func_candidate_addrs))
                if len(start_func_candidate_addrs) == 0:
                    #print("No start function candidates!")
                    continue
                # Only consider those addresses that do not have outgoing edges to other addrs in the start candidate set (since the ancestors of each start candidate is also a start candidate, this should keep the paths shorter)
                filtered_start_func_candidate_addrs = set()
                for start_func_addr in start_func_candidate_addrs:
                    successor_in_start_addrs = False
                    for successor in callgraph.successors(start_func_addr):
                        if successor in start_func_candidate_addrs:
                            successor_in_start_addrs = True
                            break
                    if not successor_in_start_addrs:
                        filtered_start_func_candidate_addrs.add(start_func_addr)
                if len(filtered_start_func_candidate_addrs) > 0:
                    l.debug("Filtered out {} start candidates".format(len(start_func_candidate_addrs) - len(filtered_start_func_candidate_addrs)))
                    start_func_candidate_addrs = filtered_start_func_candidate_addrs
                l.debug("We have {} start candidates".format(len(start_func_candidate_addrs)))
    
    
                for start_func_addr in start_func_candidate_addrs:
                    # networkx doesn't like it when you ask if there are any paths between identical nodes... :(
                    l.debug("start candidate: 0x{:x}".format(start_func_addr))
                    l.debug("calculating paths from start to input")
                    if start_func_addr == input_func.addr:
                        start_input_paths = [[start_func_addr]]
                    else:
                        start_input_paths = list(nx.all_simple_paths(callgraph, start_func_addr, input_func.addr))
                    l.debug("calculating paths from start to target")
                    if start_func_addr == target_func.addr:
                        start_target_paths = [[start_func_addr]]
                    else:
                        start_target_paths = list(nx.all_simple_paths(callgraph, start_func_addr, target_func.addr))
                    #print("Input: {}@0x{:x}, Target: {}@0x{:x}, Start: 0x{:x}".format(input_func.name, input_func.addr, target_func.name, target_func.addr, start_func_addr)


    
                    whitelisted_addrs = set() # Set of addrs of whitelisted funcs
                    #print("Input paths:")
                    l.debug("creating whitelist")
                    for path in start_input_paths:
                        for addr in path:
                            #print("{:x}, ".format(addr), end='')
                            whitelisted_addrs.add(addr)
                        #print("")
                    #print("Target paths:")
                    for path in start_target_paths:
                        for addr in path:
                            #print("{:x}, ".format(addr), end='')
                            whitelisted_addrs.add(addr)
                        #print("")
                    
                    # Adding addresses of the input function to the whitelist
                    whitelisted_addrs.add(input_func.addr)
                    for addr in input_func.block_addrs:
                        whitelisted_addrs.add(addr)
                    # Adding addresses of the target function to the whitelist
                    whitelisted_addrs.add(target_func.addr)
                    for addr in target_func.block_addrs:
                        whitelisted_addrs.add(addr)
                    l.debug("extending whitelist")
                    extended_whitelisted_addrs = set(whitelisted_addrs) # We this use as the "visited" set for the DFS as well.
                    stack = list(whitelisted_addrs)
                    while len(stack) > 0:
                        curr_addr = stack.pop()
                        ###curr_func = cfg_slow.functions.function(addr=curr_func_addr)
                        curr_func = cfg_fast.functions.function(addr=curr_addr)
                        if not curr_func:
                            continue
                        for callsite_addr in curr_func.get_call_sites():
                            call_target_func_addr = curr_func.get_call_target(callsite_addr)
                            if not call_target_func_addr in extended_whitelisted_addrs:
                                call_target_func = cfg_fast.functions.function(addr=call_target_func_addr)
                                if not call_target_func:
                                    continue
                                for addr in call_target_func.block_addrs:
                                    extended_whitelisted_addrs.add(addr)
                                extended_whitelisted_addrs.add(call_target_func_addr)
                                stack.append(call_target_func_addr)
                        for jmpout_site_addr in curr_func.jumpout_sites:
                            ###for target in cfg_slow.get_all_successors(cfg_slow.get_any_node(jmpout_site_addr)):
                            for target in cfg_fast.model.get_all_successors(cfg_fast.model.get_any_node(jmpout_site_addr)):
                                target_addr = target.addr
                                #print("Successor: {:x}".format(target_addr))
                                if not target_addr in extended_whitelisted_addrs:
                                    extended_whitelisted_addrs.add(target_addr)
                                    stack.append(target_addr)
    
                            
                    l.debug("We have {} whitelist addrs".format(len(whitelisted_addrs)))
                    l.debug("We have {} extended whitelist addrs".format(len(extended_whitelisted_addrs)))
     
                    l.debug("Constructing the emulated CFG")
                    cfg_slow_addr_whitelist = set()
                    for addr in extended_whitelisted_addrs:
                        cfg_slow_addr_whitelist.add(addr)
                        if addr not in cfg_fast.functions:
                            continue
                        for node in cfg_fast.functions[addr].nodes:
                            cfg_slow_addr_whitelist.add(node.addr)
                    #cfg_slow_addr_whitelist = extended_whitelisted_addrs.union(set([node.addr for node in cfg_fast.functions[addr].nodes for addr in extended_whitelisted_addrs]))
                    assert input_func.addr in cfg_slow_addr_whitelist
                    assert target_func.addr in cfg_slow_addr_whitelist
                    starts = [start_func_addr]
                    #print("Starts: {}".format(starts))
                    #print("Whitelist: {}".format(cfg_slow_addr_whitelist))
                    cfg_slow = proj.analyses.CFGEmulated(context_sensitivity_level=1, normalize=True, resolve_indirect_jumps=True, starts=starts, address_whitelist=cfg_slow_addr_whitelist, state_add_options=angr.sim_options.refs, keep_state=True)
                    #cfg_slow.remove_fakerets() # We cannot remove fakerets, because there is mostly not a path through the input function (even if we hook it).
                    l.debug("Emulated CFG constructed: {} nodes".format(len(cfg_slow.graph.nodes)))
                    #nx.drawing.nx_pydot.write_dot(cfg_fast.graph, "cfg_fast_{}_{}.dot".format(input_func.name, target_func.name))
                    #nx.drawing.nx_pydot.write_dot(cfg_slow.graph, "cfg_slow_{}_{}.dot".format(input_func.name, target_func.name))
                    #cfg_slow = proj.analyses.CFGEmulated(context_sensitivity_level=1, normalize=True, resolve_indirect_jumps=True, state_add_options=angr.sim_options.refs, keep_state=True)
                    print("Input function: {}".format(input_func.name))
                    #print("Input func addr: 0x{:x}".format(input_func.addr))
                    cfg_slow_input_func = cfg_slow.functions.function(name=input_func.name)
                    if not cfg_slow_input_func: # TODO, why ever would this be?
                        continue
                    #print("CFG Slow input name: {}".format(cfg_slow_input_func))

                    cfg_slow_start_node = cfg_slow.model.get_any_node(addr=start_func_addr)
                    assert cfg_slow_start_node is not None
                    cfg_slow_input_node = cfg_slow.model.get_any_node(addr=cfg_slow_input_func.addr)
                    assert cfg_slow_input_node is not None
                    cfg_slow_target_node = cfg_slow.model.get_any_node(target_func.addr, anyaddr=True)
                    assert cfg_slow_target_node is not None
                    #l.debug("Done")
                    #l.debug("Constructing CDG")
                    #cdg = proj.analyses.CDG(cfg_slow)
                    #l.debug("Done")
                    #l.debug("Constructing DDG")
                    #ddg = proj.analyses.DDG(cfg_slow)
                    #l.debug("Done")
                    #bs_targets = backward_slice_target_selection(target_func, cfg_slow)
                    #l.debug("Constructing BS")
                    #bs = proj.analyses.BackwardSlice(cfg_slow, cdg=cdg, ddg=ddg, targets=bs_targets)
                    #l.debug("Done")
                    #l.debug("Constructing Annotated CFG")
                    #annotated_cfg = bs.annotated_cfg()
                    #l.debug("Done")
                    #has_path = nx.has_path(cfg_slow.graph, cfg_slow_input_node, cfg_slow_target_node)
                    has_path = nx.has_path(cfg_slow.graph, cfg_slow_start_node, cfg_slow_input_node) and nx.has_path(cfg_slow.graph, cfg_slow_start_node, cfg_slow_input_node)
                    result_dict["{}@0x{:x} --> {}@0x{:x}".format(input_func.name, input_func.addr, target_func.name, target_func.addr)] = {"has_path": has_path}
                    print("Target func ret site: {}".format(target_func.ret_sites))
                    #print("Total #paths from input to target: {}".format(len(list(nx.all_simple_paths(cfg_slow.graph, cfg_slow_input_node, cfg_slow_target_node)))))

                    if has_path:
                        hooks_added = set()
                        for func_addr in cfg_slow.functions:
                            if func_addr not in whitelisted_addrs and not proj.is_hooked(func_addr):
                                func = cfg_slow.functions[func_addr]
                                #proj.hook(func_addr, angr.procedures.stubs.ReturnUnconstrained.ReturnUnconstrained())
                                #proj.hook_symbol(func_addr, angr.procedures.stubs.ReturnUnconstrained.ReturnUnconstrained()) # Apparantly you can hook_symbol on addresses too
                                proj.hook_symbol(func.name, angr.procedures.stubs.ReturnUnconstrained.ReturnUnconstrained())
                                hooks_added.add(func_addr)
                        #cfg_slow_start_input_path = next(nx.all_simple_paths(cfg_slow.graph, cfg_slow_start_node, cfg_slow_input_node))
                        #cfg_slow_start_target_path = next(nx.all_simple_paths(cfg_slow.graph, cfg_slow_start_node, cfg_slow_target_node))
                        #symex_whitelist = [addr for addr in cfg_slow_start_input_path] + [addr for addr in cfg_slow_start_target_path]
                        symex_whitelist = cfg_slow_addr_whitelist
                        def avoid_func(state):
                            
                            #whitelisted_statements = annotated_cfg.get_whitelisted_statements(state.addr)
                            #any_whitelisted = whitelisted_statements is None or len(whitelisted_statements) > 0
                            return state.addr not in symex_whitelist #or not any_whitelisted
                        start_state = proj.factory.blank_state(addr=start_func_addr)
                        start_state.globals['symvars_write'] = set([])
                        start_state.globals['symvars_read'] = set([])
                        symex_target_addrs =  [node.addr for node in target_func.nodes]
                        start_state.globals['target_addrs'] = symex_target_addrs

                        #start_state.inspect.b('symbolic_variable', when=angr.BP_AFTER, action=act_symbolic_variable)
                        #start_state.inspect.b('mem_write', when=angr.BP_AFTER, action=act_mem_write)
                        #start_state.inspect.b('mem_read', when=angr.BP_AFTER, action=act_mem_read)
                        simgr = proj.factory.simgr(start_state)
                        l.debug("Starting Symbolic execution")
                        #director_goal = angr.exploration_techniques.director.CallFunctionGoal(target_func, None)
                        #director_goal = angr.exploration_techniques.director.ExecuteAddressGoal(target_func.addr)
                        #director_goal = angr.exploration_techniques.director.ExecuteAddressGoal(cfg_slow_input_node.addr)
                        #director = angr.exploration_techniques.director.Director(peek_blocks=100, peek_functions=5, goals=[director_goal])
                        #simgr.use_technique(director)
                        #simgr.explore(find=target_func.addr, cfg=cfg_slow, avoid=avoid_func)
                        bip_manual_hooking.add_manual_hooks(proj)
                        #simgr.explore(find=cfg_slow_input_node.addr)
                        #print(simgr.stashes)
                        
                        done = False
                        step_count = 0
                        step_limit = 110
                        state_transitions = {}
                        prev_step_time = time.time()
                        while len(simgr.active) >= 1:
                            step_duration = time.time() - prev_step_time
                            print("Step: {} time: {}s #active: {}".format(step_count, round(step_duration), len(simgr.active)))
                            prev_step_time = time.time()
                            for state in simgr.active:
                                state_pred = list(state.plugins['history'].lineage)[-1]
                                state_transition = (state_pred.addr, state.addr)
                                if state_transition in state_transitions:
                                    state_transitions[state_transition] += 1
                                else:
                                    state_transitions[state_transition] = 1

                                #print("{} --> {}".format(state.get_plugin('history'), state))
                                frm = state_pred.addr
                                to = state.addr
                                if isinstance(frm, int) and isinstance(to, int):
                                    frm_node = cfg_slow.model.get_any_node(addr=frm, anyaddr=True)
                                    to_node = cfg_slow.model.get_any_node(addr=to, anyaddr=True)
                                    frm_func_name = "?"
                                    to_func_name = "?"
                                    if frm_node:
                                        frm_func = cfg_slow.functions.function(addr=frm_node.function_address)
                                        frm_func_name = frm_func.name
                                    if to_node:
                                        to_func = cfg_slow.functions.function(addr=to_node.function_address)
                                        to_func_name = to_func.name
                                    print("{}@0x{:0x} --> {}@0x{:0x}".format(frm_func_name, frm, to_func_name, to))
                                if state.addr == target_func.addr:
                                    simgr.move('active', 'found', filter_func=lambda s: s == state)
                                    done = True
                                    break
                            if done:
                                break
                            simgr.step()
                            step_count += 1
                            if step_count >= step_limit:
                                break

                        for state_transition, freq in sorted(state_transitions.items(), key=lambda item: item[1]):
                            #freq = state_transitions[state_transition]
                            frm = state_transition[0]
                            to = state_transition[1]
                            if isinstance(frm, int) and isinstance(to, int):

                                frm_node = cfg_slow.model.get_any_node(addr=frm, anyaddr=True)
                                to_node = cfg_slow.model.get_any_node(addr=to, anyaddr=True)
                                frm_func_name = "?"
                                to_func_name = "?"
                                if frm_node:
                                    frm_func = cfg_slow.functions.function(addr=frm_node.function_address)
                                    frm_func_name = frm_func.name
                                if to_node:
                                    to_func = cfg_slow.functions.function(addr=to_node.function_address)
                                    to_func_name = to_func.name
                                print("{}@0x{:0x} --> {}@0x{:0x}: {}".format(frm_func_name, frm, to_func_name, to, freq))
                        
                
    
                        '''
                        done = False
                        while len(simgr.active) >= 1:
                            for state in simgr.active:
                                state_block = state.block()
                                intersection = state.globals['symvars_read'].intersection(state.globals['symvars_write'])
                                if intersection:
                                    result_dict["{}@0x{:x} --> {}@0x{:x}".format(input_func.name, input_func.addr, target_func.name, target_func.addr)] = (has_path, intersection)
                                    done = True
                                    break
                                #if state.addr in symex_target_addrs:
                                #    simgr.move('active', 'found', filter_func=lambda s: s == state)
                                #    break
                                if avoid_func(state):
                                    simgr.move('active', 'force_stopped', filter_func=lambda s: s == state)
                            if done:
                                break
                            simgr.step()
                        '''
                        l.debug("Done")
                        #print(simgr.stashes)
                        #print(simgr.errored)
                        found_states = simgr.stashes['found']
                        if len(found_states) > 0:
                            found_state = found_states[0]
                            print("Found state: {}".format(found_state))
                            found_state_rdi = found_state.regs.get('rdi')
                            found_state_rsi = found_state.regs.get('rsi')
                        
                            passed_symbolic_to_target = False
                            passed_input_to_target = False
                            data_passed_to_target = [found_state.memory.load(addr=found_state_rdi, size=4), found_state.memory.load(addr=found_state_rsi, size=4)]
                            for data in data_passed_to_target:
                                passed_symbolic_to_target = passed_symbolic_to_target or data.symbolic
                                passed_input_to_target = passed_input_to_target or any(input_func.name in variable for variable in data.variables)

                            result_dict["{}@0x{:x} --> {}@0x{:x}".format(input_func.name, input_func.addr, target_func.name, target_func.addr)]['passed_symbolic_data_to_target'] = passed_symbolic_to_target
                            result_dict["{}@0x{:x} --> {}@0x{:x}".format(input_func.name, input_func.addr, target_func.name, target_func.addr)]['passed_input_data_to_target'] = passed_input_to_target
                            print("Result dict:")
                            print(result_dict)
                            for addr in hooks_added:
                                proj.unhook(addr)
                        else:
                            print("Symbolic execution did not reach target state")
                        



 
    except Exception as e:
        raise e
        l.debug("Exception: {}".format(str(e)))
        result_dict['err'] = str(e)
    return result_dict

def analyze5(elf_file, get_hash_funcs):
    # XXX This analysis doesn't work yet. The problem is deciding where to start for symex. For a path, we may have multiple nodes at the least call depth we need to pick one and trace its fakeret edge back to the callsite of the ret site (that lead to the least call depth).
    #input_function_names = set(['fgets', 'gets', 'fgetc', 'recv', 'rcvfrom', 'recvmsg', 'read', 'fread', 'scanf', 'sscanf', 'fscanf', 'vscanf', 'vsscanf', 'vfscanf', 'getchar', 'getline', 'getdelim'])
    input_function_names = set(['SSL_read'])
    result_dict = {}   
    # Make sure we always return to the func that was called
    def validate_path(cfg_fast, path):
        call_stack = []
        u = path[0]
        for v in path[1:]:
            assert cfg_fast.graph.has_edge(u, v)
            v_node = cfg_fast.model.get_any_node(addr=v)
            assert v_node
            v_func = cfg_fast.functions.function(addr=v_node.function_address)
            assert v_func

            jumpkind = cfg_fast.graph.get_edge_data(u, v)['jumpkind']
            if jumpkind == 'Ijk_Call':
                call_stack.append(v_func.name)
            elif jumpkind == 'Ijk_Ret':
                if len(call_stack) >= 1:
                    last_called_func = call_stack.pop()
                    if last_called_func != v_func.name:
                        return False
            u = v
        return True
    def find_start_addr(cfg_fast, path):
        min_call_depth = float('inf')
        call_depth = 0

        u = path[0]
        min_call_depth_addr = u
        for v in path[1:]:
            assert cfg_fast.graph.has_edge(u, v)
            v_node = cfg_fast.model.get_any_node(addr=v)
            assert v_node
            v_func = cfg_fast.functions.function(addr=v_node.function_address)
            assert v_func

            jumpkind = cfg_fast.graph.get_edge_data(u, v)['jumpkind']
            if jumpkind == 'Ijk_Call':
                call_depth += 1
            elif jumpkind == 'Ijk_Ret':
                call_depth -= 1
                if call_depth < min_call_depth:
                    min_call_depth = call_depth
                    min_call_depth_addr = v
            u = v
        
        return True


    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        common_input_functions.hook_input_funcs(proj)
        cfg_fast = proj.analyses.CFGFast()
        target_nodes = set()
        target_node_addrs = set()
        for hash_func in get_hash_funcs(proj, cfg_fast, result_dict):
            target_node = cfg_fast.model.get_any_node(addr=hash_func.addr)
            target_nodes.add(target_node)
            target_node_addrs.add(target_node.addr)
        l.debug("Hash func search results:")
        l.debug(result_dict['hash_funcs'])
    
        for input_func_name in input_function_names:
            cfg_fast = proj.analyses.CFGFast() # XXX It appears as if angr's CFGEmulated has some side effects on CFGFast. If we search for "read" first and then "fgets", CFGFast doesn't find "fgets", but if we search for "fgets" first, it does (what even?). So, we recreate CFGFast for every input function.
            input_func = cfg_fast.functions.function(name=input_func_name)
            input_node = cfg_fast.model.get_any_node(input_func.addr)
            if not input_func:
                continue

            for target_node in target_nodes:
                target_func = cfg_fast.functions.function(addr=target_node.function_address)
                if not target_func: # TODO why would angr do this? :/
                    continue
                # Find all paths from input to target in CFG fast
                input_target_paths = []
                for path in nx.all_simple_paths(cfg_fast.graph, input_node, target_node):
                    if validate_path(cfg_fast, path):
                        input_target_paths.append(path)
            
                 
                l.debug("Constructing the emulated CFG")
                cfg_slow_addr_whitelist = set()
                for path in input_target_paths:
                    for addr in path:
                        cfg_slow_addr_whitelist.add(addr)
                #cfg_slow_addr_whitelist = extended_whitelisted_addrs.union(set([node.addr for node in cfg_fast.functions[addr].nodes for addr in extended_whitelisted_addrs]))
                assert input_func.addr in cfg_slow_addr_whitelist
                assert target_func.addr in cfg_slow_addr_whitelist
                #print("Starts: {}".format(starts))
                #print("Whitelist: {}".format(cfg_slow_addr_whitelist))
                #cfg_slow = proj.analyses.CFGEmulated(context_sensitivity_level=1, normalize=True, resolve_indirect_jumps=True, starts=cfg_slow_addr_whitelist, address_whitelist=cfg_slow_addr_whitelist, state_add_options=angr.sim_options.refs, keep_state=True)
                cfg_slow = proj.analyses.CFGEmulated(context_sensitivity_level=1, normalize=True, resolve_indirect_jumps=True, starts=cfg_slow_addr_whitelist, address_whitelist=cfg_slow_addr_whitelist)
                cfg_slow.remove_fakerets()
                #nx.drawing.nx_pydot.write_dot(cfg_fast.graph, "cfg_fast_{}_{}.dot".format(input_func.name, target_func.name))
                #nx.drawing.nx_pydot.write_dot(cfg_slow.graph, "cfg_slow_{}_{}.dot".format(input_func.name, target_func.name))
                print("Input function: {}".format(input_func.name))
                #print("Input func addr: 0x{:x}".format(input_func.addr))
                cfg_slow_input_func = cfg_slow.functions.function(name=input_func.name)
                if not cfg_slow_input_func: # TODO, why ever would this be?
                    continue
                #print("CFG Slow input name: {}".format(cfg_slow_input_func))


                cfg_slow_input_node = cfg_slow.model.get_any_node(addr=cfg_slow_input_func.addr)
                assert cfg_slow_input_node is not None
                cfg_slow_target_node = cfg_slow.get_any_node(target_func.addr, anyaddr=True)
                assert cfg_slow_target_node is not None
                has_path = nx.has_path(cfg_slow.graph, cfg_slow_input_node, cfg_slow_target_node)
                result_dict["{}@0x{:x} --> {}@0x{:x}".format(input_func.name, input_func.addr, target_func.name, target_func.addr)] = {"has_path": has_path}
                print("Target func ret site: {}".format(target_func.ret_sites))
                print("Total #paths from input to target: {}".format(len(list(nx.all_simple_paths(cfg_slow.graph, cfg_slow_input_node, cfg_slow_target_node)))))

                if has_path:
                    symex_path = next(nx.all_simple_paths(cfg_slow.graph, cfg_slow_input_node, cfg_slow_target_node))
                    def avoid_func(state):        
                        return state.addr not in symex_path
                    start_state = proj.factory.blank_state(addr=start_func_addr)

                    simgr = proj.factory.simgr(start_state)
                    l.debug("Starting Symbolic execution")
                    simgr.explore(find=target_func.addr, cfg=cfg_slow, avoid=avoid_func)
                    found_states = simgr.stashes['found']
                    if len(found_states) > 0:
                        found_state = found_states[0]
                        print("Found state: {}".format(found_state))
                        found_state_rdi = found_state.regs.get('rdi')
                        found_state_rsi = found_state.regs.get('rsi')
                        
                        passed_symbolic_to_target = False
                        passed_input_to_target = False
                        data_passed_to_target = [found_state.memory.load(addr=found_state_rdi, size=4), found_state.memory.load(addr=found_state_rsi, size=4)]
                        for data in data_passed_to_target:
                            passed_symbolic_to_target = passed_symbolic_to_target or data.symbolic
                            passed_input_to_target = passed_input_to_target or any(input_func.name in variable for variable in data.variables)

                        result_dict["{}@0x{:x} --> {}@0x{:x}".format(input_func.name, input_func.addr, target_func.name, target_func.addr)]['passed_symbolic_data_to_target'] = passed_symbolic_to_target
                        result_dict["{}@0x{:x} --> {}@0x{:x}".format(input_func.name, input_func.addr, target_func.name, target_func.addr)]['passed_input_data_to_target'] = passed_input_to_target
                        print("Result dict:")
                        print(result_dict)
                    else:
                        print("Symbolic execution did not reach target state")
                        
    except Exception as e:
        raise e
        l.debug("Exception: {}".format(str(e)))
        result_dict['err'] = str(e)
    return result_dict



def analyze_hash_func_retrieval(elf_file, get_hash_funcs):
    result_dict = {}
    try:
        proj = angr.Project(elf_file, auto_load_libs=False)
        cfg_fast = proj.analyses.CFGFast()
        for hash_func in get_hash_funcs(proj, cfg_fast):
            hash_name = hash_func.name
            hash_addr = hash_func.addr
            result_dict["{}@0x{:x}".format(hash_name, hash_addr)] = True
    except Exception as e:
        #raise e
        l.debug("Exception: {}".format(str(e)))
        result_dict['err'] = str(e)
    return result_dict



def backward_slice_target_selection(func, cfg):
    targets = set()
    for addr in func.block_addrs:
        node = cfg.model.get_any_node(addr=addr, anyaddr=True)
        if not node:
            continue
        block = node.block
        block_vex = block.vex
        for i, stmt in enumerate(block_vex.statements):
            if stmt.tag == 'Iex_Load' or any(expr.tag == 'Iex_Load' for expr in stmt.expressions):
                targets.add((node, i)) # TODO make sure the enumerated i actually corresponds to the stmt_idx
                # TODO make sure you don't include stupid statements like leave as targets
    return targets



def deb_filter(full_deb_file_name, deb_file_name, deb_file_md5):
    return deb_file_name in debs_with_elf_that_use_glibc_hash

def elf_filter(full_elf_file_name, elf_file_name, elf_file_md5, elf_file_size):
    return elf_file_name in elfs_that_use_glibc_hash

def elf_size_filter(full_elf_file_name, elf_file_name, elf_file_md5, elf_file_size):
    return elf_file_size <= (1024 * 1024)


elfs_that_use_glibc_hash = set((
"libsaproc.so",
"drbdadm-83",
"drbdadm-84",
"lbcd",
"libpsm_infinipath.so.1.16",
"libpsm2.so.2.1",
"stress-ng",
"mtr",
#"libc.so",
"eu-ar",
"viva",
#"libc-2.28.so",
"b9a9a8c523e5cfe5b5d946d605d09242f09798.debug",
"remap_stats.so",
"uri_signing.so",
"arp-scan",
"trafshow",
"libnss_wrapper.so",
"hxaddid",
"hxref",
"hxmkbib",
"hxtoc",
"hxcite",
"librc.so.1"
))
debs_with_elf_that_use_glibc_hash = set((
"nvidia-openjdk-8-jre_9.+8u77~9.2.148-7_amd64.deb",
"drbd-utils_9.5.0-1_i386.deb",
"drbd-utils_9.5.0-1_amd64.deb",
"lbcd_3.5.2-3_amd64.deb",
"lbcd_3.5.2-3_i386.deb",
"libpsm-infinipath1_3.3+20.604758e7-6_i386.deb",
"libpsm-infinipath1_3.3+20.604758e7-6_amd64.deb",
"libpsm2-2_11.2.78-1_amd64.deb",
"stress-ng_0.09.50-1_amd64.deb",
"stress-ng_0.09.50-1_i386.deb",
"mtr-tiny_0.92-2_amd64.deb",
"mtr_0.92-2_amd64.deb",
"mtr_0.92-2_i386.deb",
"mtr-tiny_0.92-2_i386.deb",
"musl_1.1.21-2_i386.deb",
"musl_1.1.21-2_amd64.deb",
"elfutils_0.176-1.1_i386.deb",
"elfutils_0.176-1.1_amd64.deb",
"viva_1.2-1.1_amd64.deb",
"viva_1.2-1.1_i386.deb",
"libc6-xen_2.28-10_i386.deb",
"libc6-dbg_2.28-10_amd64.deb",
"libc6_2.28-10_amd64.deb",
"libc6-amd64_2.28-10_i386.deb",
"libc6-x32_2.28-10_i386.deb",
"libc6-i386_2.28-10_amd64.deb",
"libc6-x32_2.28-10_amd64.deb",
"libc6_2.28-10_i386.deb",
"trafficserver-experimental-plugins_8.0.2+ds-1_i386.deb",
"trafficserver-experimental-plugins_8.0.2+ds-1_amd64.deb",
"arp-scan_1.9.5-1_amd64.deb",
"arp-scan_1.9.5-1_i386.deb",
"netdiag_1.2-1+b1_i386.deb",
"netdiag_1.2-1+b1_amd64.deb",
"libnss-wrapper_1.1.3-1_amd64.deb",
"libnss-wrapper_1.1.3-1_i386.deb",
"html-xml-utils_7.7-1_amd64.deb",
"html-xml-utils_7.7-1_i386.deb",
"libc6-armhf-cross_2.28-7cross1_all.deb",
"libc6-mipsn32-mipsel-cross_2.28-7cross1_all.deb",
"libc6-armel-cross_2.28-7cross1_all.deb",
"libc6-mips64-mipsel-cross_2.28-7cross1_all.deb",
"libc6-x32-amd64-cross_2.28-7cross1_all.deb",
"libc6-s390x-cross_2.28-7cross1_all.deb",
"libc6-arm64-cross_2.28-7cross1_all.deb",
"libc6-amd64-cross_2.28-7cross1_all.deb",
"libc6-mips32-mips64el-cross_2.28-7cross1_all.deb",
"libc6-mipsn32-mips64el-cross_2.28-7cross1_all.deb",
"libc6-mipsel-cross_2.28-7cross1_all.deb",
"libc6-x32-i386-cross_2.28-7cross1_all.deb",
"libc6-i386-cross_2.28-7cross1_all.deb",
"libc6-mips-cross_2.28-7cross1_all.deb",
"libc6-i386-amd64-cross_2.28-7cross1_all.deb",
"libc6-amd64-i386-cross_2.28-7cross1_all.deb",
"libc6-mips64el-cross_2.28-7cross1_all.deb",
"libc6-mipsn32-mips-cross_2.28-7cross1_all.deb",
"libc6-mips64-mips-cross_2.28-7cross1_all.deb",
"libc6-mips32-mipsn32r6el-cross_2.28-7cross2_all.deb",
"libc6-mips32-mips64r6el-cross_2.28-7cross2_all.deb",
"libc6-mipsn32-mipsr6el-cross_2.28-7cross2_all.deb",
"libc6-mipsn32r6el-cross_2.28-7cross2_all.deb",
"libc6-mipsr6-cross_2.28-7cross2_all.deb",
"libc6-mipsn32-mipsr6-cross_2.28-7cross2_all.deb",
"libc6-mips64-mipsn32r6-cross_2.28-7cross2_all.deb",
"libc6-mips64-mipsr6-cross_2.28-7cross2_all.deb",
"libc6-mips32-mipsn32el-cross_2.28-7cross2_all.deb",
"libc6-mipsn32-cross_2.28-7cross2_all.deb",
"libc6-mips32-mipsn32r6-cross_2.28-7cross2_all.deb",
"libc6-mips32-mips64-cross_2.28-7cross2_all.deb",
"libc6-mipsn32r6-cross_2.28-7cross2_all.deb",
"libc6-mips64-cross_2.28-7cross2_all.deb",
"libc6-mips32-mips64r6-cross_2.28-7cross2_all.deb",
"libc6-mipsn32el-cross_2.28-7cross2_all.deb",
"libc6-mips64r6-cross_2.28-7cross2_all.deb",
"libc6-mipsn32-mips64r6el-cross_2.28-7cross2_all.deb",
"libc6-mipsn32-mips64-cross_2.28-7cross2_all.deb",
"libc6-mips64-mipsr6el-cross_2.28-7cross2_all.deb",
"libc6-mips64-mipsn32-cross_2.28-7cross2_all.deb",
"libc6-mips64r6el-cross_2.28-7cross2_all.deb",
"libc6-mipsr6el-cross_2.28-7cross2_all.deb",
"libc6-mips32-mipsn32-cross_2.28-7cross2_all.deb",
"libc6-mips64-mipsn32el-cross_2.28-7cross2_all.deb",
"libc6-mips64-mipsn32r6el-cross_2.28-7cross2_all.deb",
"libc6-mipsn32-mips64r6-cross_2.28-7cross2_all.deb",
"libc6-powerpc-cross_2.28-7cross1_all.deb",
"libc6-powerpc-ppc64-cross_2.28-7cross1_all.deb",
"libc6-ppc64-cross_2.28-7cross1_all.deb",
"libc6-i386-x32-cross_2.28-7cross1_all.deb",
"libc6-ppc64-powerpc-cross_2.28-7cross1_all.deb",
"libc6-powerpcspe-cross_2.28-7cross1_all.deb",
"libc6-amd64-x32-cross_2.28-7cross1_all.deb",
"libc6-x32-cross_2.28-7cross1_all.deb",
"openjdk-11-jre-headless_11.0.4+11-1~deb10u1_amd64.deb",
"openjdk-11-jre-headless_11.0.4+11-1~deb10u1_i386.deb",
"librc1_0.40.3-1_i386.deb",
"librc1_0.40.3-1_amd64.deb")
)

