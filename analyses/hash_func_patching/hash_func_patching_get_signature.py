#! /usr/bin/env python3
import angr
import argparse
import claripy
import ghidra_bridge
import os
import subprocess
import time

# The location of Ghidra's analyzeHeadless script
GHIDRA_ANALYZEHEADLESS = '/opt/ghidra/support/analyzeHeadless'

parser = argparse.ArgumentParser(
    description='Get hash signatures.')
parser.add_argument('--hash', action='store', metavar='STRING',
                    required=True, help='Hash to match to')
parser.add_argument('--program', action='store', metavar='FILE',
                    required=True, help='Location of the program')
parser.add_argument('--bounds', action='store', metavar='INT',
                    required=False, help='Bounds for hash')


def prime_addr(addr):
    '''
    This just takes in an address given by the user (i.e. 0x64a) and
    converts it to what angr uses (e.g. 0x40064a)
    You can ignore this if you are using argv in terminal
    '''
    angr_addr = "0x400000"
    return eval("hex(" + angr_addr + " + " + addr + ")")


def params(fun_name):
    '''
    Takes in the name of a function and returns its parameters
    Uses ghidra_bridge to create a high function using ready(). It then gets
    the parameters and returns them as an array
    Returns 0 if theres an error (no parameters)
    '''
    f = getFirstFunction()  # Gets the first function
    while f is not None:  # loops until it finds function or is none
        if (f.getName() == fun_name):  # check names
            temp = []
            ready(f)  # YOu have to commit params to get decent results
            for i in range(f.getParameterCount()):
                # makes an array with all function names
                temp.append(f.getParameters()[i])
            return temp
        f = getFunctionAfter(f)  # gets next function
    return 0


def get_name_with_angr(addr, cfg, prime=1):
    '''takes in an address and a cfg, and gets the name of the function '''
    if (
            prime
    ):  # prime is for if the addr is 0x400 angr base (prime = 0) or 0x0 base
        addr = prime_addr(addr)
    print(addr)
    return eval("cfg.functions.function(" + addr + ").name")


def bounds(fun_name, cfg, proj, bnds=7, address=False):
    ''' Takes in the name of a function, the cfg, and the project itself
        Outputs the bounds of what a function returns (assuming int or similar)
        Kind of fails when they are using a custom type/struct'''
    if (address):  # Can work with name or addr
        func = eval("cfg.functions.function(addr = " + fun_name + ")")
        state = eval("proj.factory.call_state(" + fun_name + ")")
    else:
        func = cfg.functions.function(name=fun_name)
        # Make a call state at function addr
        state = proj.factory.call_state(func.addr)
    # Get the return reg (e.g. rax)
    reg = func.calling_convention.RETURN_VAL.reg_name
    regVal = claripy.BVS('regVal', 64)  # Symbolic bv
    # Symbolic BV on call state of register from above
    exec("state.regs." + reg + " = regVal")
    simgr = proj.factory.simgr(state)  # simulation
    while (len(simgr.deadended) == 0):
        simgr.step()  # getting first deadened or maybe only deadended
    if (len(simgr.active) == 0):  # program is at return, no loops
        # r is the symbolic register of the simgr
        r = eval("simgr.deadended[0].regs." + reg)
        # finding max and min of the deadended state
        high = simgr.deadended[0].solver.max(r)
        low = simgr.deadended[0].solver.min(r)
    else:  # TODO: Find a better way to get bounds
        maxs = []
        mins = []
        for i in range(0, bnds * 2):
            if (len(simgr.deadended) < bnds):
                simgr.step()
        for i in range(len(simgr.deadended)):
            # Doing the same thing as before but w/
            r = eval("simgr.deadended[i].regs." + reg)
            maxs.append(simgr.deadended[i].solver.max(r))  # i instead of 0
            mins.append(simgr.deadended[i].solver.min(r))
            simgr.step()
            print(i)
        # taking the max and min of all the maxes and mins, (global max/min)
        high = max(maxs)
        low = min(maxs)
    print("max is ", high)
    print("min is ", low)
    return low, high


def find_mod_bounds(addr, pars, cfg, proj, bnds=7):
    '''
    If a function takes in more than one parameter (and only one string), try
    to see if the return is modified by a parameter. Construct a call state,
    where the parameter with the string is a symbolic value. The rest are
    filled in with 3*i. This is because no good function would return mod 3,
    mod 6, etc. So if the bounds come back (0,3) it isnt a coincidence. Then,
    if we see bounds are like (0,6) or (0, 3*2) , we can assume the second
    input is messing with it.
    '''
    wheresChar = []
    for j in range(len(pars)):
        i = pars[j].toString()
        if (("byte *" in i) or ("char * " in i)):
            wheresChar.append(1)
        else:
            wheresChar.append(0)
    if (sum(wheresChar) != 1):
        return  # hard to do for a case with more than/less than 1 str
    buildState = ""
    test = claripy.BVS("test", 64)
    NUM = 3
    mult = 1
    for i in wheresChar:
        if (i):
            buildState = buildState + "test,"
        else:
            buildState = buildState + str(NUM * mult + 1) + ","
        mult += 1
    buildState = buildState[0:-1]
    func = eval("cfg.functions.function(addr = " + addr + ")")
    state = eval("proj.factory.call_state(" + addr + "," + buildState + ")")
    # Get the return reg (e.g. rax)
    reg = func.calling_convention.RETURN_VAL.reg_name
    # regVal = claripy.BVS('regVal', 64)  # Symbolic bv
    # Symbolic BV on call state of register from above
    exec("state.regs." + reg + " = regVal")
    simgr = proj.factory.simgr(state)  # simulation
    while (len(simgr.deadended) == 0):
        simgr.step()  # getting first deadened or maybe only deadended
    if (len(simgr.active) == 0):  # program is at return, no loops
        # r is the symbolic register of the simgr
        r = eval("simgr.deadended[0].regs." + reg)
        # finding max and min of the deadended state
        high = simgr.deadended[0].solver.max(r)
        low = simgr.deadended[0].solver.min(r)
    else:  # TODO: Taking ~15 iterations and finding the maxs and mins, improve
        maxs = []
        mins = []
        for i in range(0, bnds * 2):
            if (len(simgr.deadended) < bnds):
                simgr.step()
        for i in range(len(simgr.deadended)):
            # Doing the same thing as before but w/
            r = eval("simgr.deadended[i].regs." + reg)
            maxs.append(simgr.deadended[i].solver.max(r))  # i instead of 0
            mins.append(simgr.deadended[i].solver.min(r))
            simgr.step()
            print(i)
        # taking the max and min of all the maxes and mins, (global max/min)
        high = max(maxs)
        # low = min(maxs)
    if (((high % NUM) != 0) or (high // NUM > len(wheresChar))):
        print("Bounds are probably unrelated to input")
        return
    print("Bounds are probably related to input number ", high // NUM)
    return


def ready(f):
    ''' This is required for f.getFunctionParameters() to work

        Just readys ghidra to allow for a highFunction to be made. '''
    t = currentProgram.startTransaction("hello")
    interface = ghidra.app.decompiler.DecompInterface()
    interface.openProgram(currentProgram)
    d = interface.decompileFunction(f, 5, None)
    high = d.getHighFunction()
    user = ghidra.program.model.symbol.SourceType.USER_DEFINED
    y = ghidra.program.model.pcode.HighFunctionDBUtil
    y.commitParamsToDatabase
    y.commitReturnToDatabase
    y.commitParamsToDatabase(high, True, user)
    y.commitReturnToDatabase(high, user)


def printg(strg, param):
    ''' just a print function '''
    if param == 0:
        print()
        print("Error or you misspelled function")
        return
    print(strg)
    for i in range(len(param)):
        print(param[i])


def listAll(strn=None):
    g = input("There may be a lot of functions. Are you sure? [y\ n]:", )
    if (g != "n"):
        f = getFirstFunction()
        while f is not None:
            if strn is None:
                print(f.getName())
            else:
                if f.getName()[0:len(strn)] == strn:
                    print(f.getName())
            f = getFunctionAfter(f)
    print("~ done! ~")


def setup_patching():
    dir_path = os.path.dirname(os.path.realpath(__file__))
    project_path = os.path.join(dir_path, 'ghidra')
    script_path = os.path.join(dir_path,
                               'ghidra_scripts',
                               'ghidra_bridge_server.py')
    subprocess.run([GHIDRA_ANALYZEHEADLESS,
                    project_path,
                    'stashed',
                    '-preScript',
                    script_path])

    # Wait 10 seconds for server to start
    time.sleep(10)


def run_patching(program, hash_name, bounds=None):
    b = ghidra_bridge.GhidraBridge(namespace=globals())
    proj = angr.Project(program,
                        auto_load_libs=False,
                        load_debug_info=False)
    cfg = proj.analyses.CFGFast()
    proj.analyses.CompleteCallingConventions(cfg=cfg.model)
    name = get_name_with_angr(hash_name, cfg, 0)
    p = name + " params are : "
    c = name + "bounds are : "
    if (bounds is not None):
        print(c, bounds(hash_name,
                        cfg,
                        proj,
                        bnds=int(bounds),
                        address=True))
    else:
        print(c, bounds(hash_name, cfg, proj, address=True))
    pars = params(name)
    printg(p, pars)
    if (len(pars) > 1):  # Might crash
        find_mod_bounds(hash_name, pars, cfg, proj)
        # b.bridge.remote_shutdown()
        return
    actual_program_name = currentProgram.toString().split(" ")[0]
    proj = angr.Project(actual_program_name,
                        auto_load_libs=False,
                        load_debug_info=False)
    cfg = proj.analyses.CFGFast()
    print("we made it!")
    proj.analyses.CompleteCallingConventions(
        cfg=cfg.model)  # , analyze_callsites=True)
    g = "1"
    print("Finding functions of : ", currentProgram.toString())
    print("Note: some params may be listed as undefined or out of order")
    print("To look using an address type 'addr 0x....' ")
    print(
        "Type 'l s' to list all functions or 'l s *' to list all functions starting w/ *"
    )
    print("Type 'e n d' to shutdown")
    print("Press enter to quit w/o shutdown")
    if (bounds is None):
        name = get_name_with_angr(hash_name, cfg, prime=0)
        p = name + " params are : "
        b = name + "bounds are : "
        print(b, bounds(name, cfg, proj))
        printg(p, params(name))
        return
    while True:
        g = input("function to find signature :", )
        g = g.strip()
        if (g == ""):
            break
        if (g == "e n d"):
            b.bridge.remote_shutdown()
            break
        if ((len(g) >= 3) and (g[0:3] == "l s")):
            if (len(g) == 3):
                listAll()
            else:
                print(g[4:])
                listAll(g[4:])
        elif ((len(g) >= 4) and (g[0:4] == "get ")):
            print(hex(cfg.functions.function(name=g[4:]).addr - 0x400000))
        elif ((len(g) >= 6) and (g[0:6] == "addr 0")):
            name = get_name_with_angr(g[5:].split(" ")[0], cfg)
            p = name + " params are : "
            c = name + "bounds are : "
            if (len(g[5:].split(" ")) == 2):
                print(c, bounds(name, cfg, proj, int(g[5:].split(" ")[1])))
            else:
                print(c, bounds(name, cfg, proj))
            printg(p, params(name))
        else:
            p = g + " params are : "
            printg(p, params(g))


if __name__ == '__main__':
    args = parser.parse_args()

    run_patching(args.program,
                 args.hash,
                 args.bounds if args.bounds is not None else None)
