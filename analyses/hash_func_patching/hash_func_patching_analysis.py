import sys
import os
import angr
import claripy

from binalyzer.analyzers.analysis import Analysis
from binalyzer.analyzers.analysis_results import AnalysisResults

import util.angr_util as angr_util

from hash_patcher.hash_patch_evaluator import HashPatchEvaluator

from hash_patcher.static_patcher import StaticPatcher
from hash_patcher.hash_patch_asm_generator import HashPatchAsmGenerator

from analyses.hash_func_use.hash_func_use_analysis import HashFuncUseAnalysis
from analyses.hash_func_use.hash_func_use_analysis import HashFuncUseAnalysisResults

case_sensitivity_check_strs = ['Ab', 'bD', '0sY']

# Note we only use strings that are not affected by case-sensitivity
hash_vals_checks = {'bkdrhash':{'123':847490, '!@#$':75289928},
    'dekhash':{'123':82547, '!@#$':5342276},
    'pjwhash':{'123':13395, '!@#$':152148},
    'rshash':{'123':3350397308, '!@#$':3818697610},
    'jshash':{'123':446351968, '!@#$':1131574688},
    'sdbmhash':{'123':408093746, '!@#$':520606112},
    'djbhash':{'123':193432059, '!@#$':2087730413},
    'elfhash':{'123':13395, '!@#$':152148},
    'aphash':{'123':1654819135, '!@#$':4030010601}


}

ext_mem_refs_checks = ['aa', 'abcd']

hash_patches_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'hash_patches')
case_sensitive_hash_patch_asm_files = [os.path.join(hash_patches_location, 'sip_hash_func.s'),
    os.path.join(hash_patches_location, 'univ_hash_func.s')
]
case_insensitive_hash_patch_asm_files = [os.path.join(hash_patches_location, 'sip_hash_func_case_insensitive.s'),
    os.path.join(hash_patches_location, 'univ_hash_func_case_insensitive.s')
]


class HashFuncPatchingAnalysis(Analysis):

    def __init__(self, similarity_score_cutoff, block_symex_upperbound, patch_dir):
        self._similarity_score_cutoff = similarity_score_cutoff
        self._hash_func_use_analysis = HashFuncUseAnalysis(similarity_score_cutoff, block_symex_upperbound)
        self._patch_dir = patch_dir
    
    def analyze(self, analysis_target):
        errs = []
        results = HashFuncPatchingAnalysisResults(None, errs)

        try:
            full_target_file_path = analysis_target.full_file_path
            target_file_name = analysis_target.file_name
            hash_func_use_analysis_results = self._hash_func_use_analysis.analyze(analysis_target)
            hash_func_discovery_analysis_results = hash_func_use_analysis_results.hash_func_discovery_analysis_results

            hash_func_uses = hash_func_use_analysis_results.hash_func_uses
            
            results = HashFuncPatchingAnalysisResults(hash_func_use_analysis_results, errs)

            # Find all used hash functions
            used_hash_funcs = set()
            # Go through all the hash function uses (hash function + call site + reads/writes/seeks)
            for hash_func_use in hash_func_uses:
                # If the hash function is used, add it to a set
                # (We need to use a set, because one hash function can have many call sites)
                if self.hash_func_is_used(hash_func_use):
                    hash_func = hash_func_use.discovered_hash_func
                    used_hash_funcs.add(hash_func)
            if len(used_hash_funcs) <= 0:
                return results
            proj = angr.Project(full_target_file_path, auto_load_libs=False)
            cfg_fast = proj.analyses.CFGFast()


            # For every used hash function patch it
            for discovered_hash_func in used_hash_funcs:
                hash_func_patch_details = HashFuncPatchDetails(discovered_hash_func)
                results.add_hash_func_patch_details(hash_func_patch_details)
                func_addr = discovered_hash_func.func_addr
                
                patched_elf_file_name = target_file_name + "_patch_0x{:x}".format(func_addr)
                patched_elf_file_path = os.path.join(self._patch_dir, patched_elf_file_name)
                hash_func = cfg_fast.functions.function(addr=func_addr)
                hash_alg_name = discovered_hash_func.hash_func_name

                if hash_func is None:
                    hash_func_patch_details.add_err("Could not find function at addr 0x{:x} (aborting patching).".format(func_addr))
                    continue

                # We start with checks on the original hash function
                hash_patch_evaluator_sig1 = HashPatchEvaluator(full_target_file_path, func_addr, 'sig1', vuln_proj=proj)
                hash_patch_evaluator_sig2 = HashPatchEvaluator(full_target_file_path, func_addr, 'sig2', vuln_proj=proj)


                # Check the signature
                sig1_check = hash_patch_evaluator_sig1.check_signature(check_original=True)
                sig2_check = hash_patch_evaluator_sig2.check_signature(check_original=True)

                hash_func_patch_details.orig_hash_sig1 = sig1_check
                hash_func_patch_details.orig_hash_sig2 = sig2_check

                if not (sig1_check or sig2_check):
                    hash_func_patch_details.add_err("Could not find a signature that works (aborting patching).")
                    continue

                # If both are true, we can probably pick either right?
                if sig1_check:
                    hash_patch_evaluator = hash_patch_evaluator_sig1
                else:
                    hash_patch_evaluator = hash_patch_evaluator_sig2

                # Check for case sensitivity
                case_sensitivity = hash_patch_evaluator.check_case_sensitivity(case_sensitivity_check_strs, check_original=True)
                hash_func_patch_details.orig_case_sensitive = case_sensitivity

                str_to_hashval_map = hash_vals_checks[hash_alg_name]

                # Check the hash values
                # XXX This causes a problem for hash functions that cast down their return
                hash_val_irregularities = hash_patch_evaluator.check_hash_vals(hash_alg_name, str_to_hashval_map, check_original=True)
                hash_func_patch_details.orig_hash_val_irregularities = hash_val_irregularities


                # Check the external memory references (outside the stack-frame of the hash function)
                ext_mem_refs_irregularities = hash_patch_evaluator.check_ext_mem_refs(ext_mem_refs_checks, check_original=True)
                hash_func_patch_details.orig_hash_ext_mem_ref_irregularities = ext_mem_refs_irregularities
    

                # Now do the patch
                if case_sensitivity:
                    hash_patch_asm_files = case_sensitive_hash_patch_asm_files
                else:
                    hash_patch_asm_files = case_insensitive_hash_patch_asm_files
                if sig1_check:
                    len_in_reg = 'rsi'
                else:
                    len_in_reg = None

                hash_func_patch_details.patch_insert_successes = {}
                for hash_patch_asm_file in hash_patch_asm_files:
                    hash_func_patch_details.patch_insert_successes[os.path.basename(hash_patch_asm_file)] = False
                    hpag = HashPatchAsmGenerator(proj, asm_file=hash_patch_asm_file, buf_in_reg='rdi', len_in_reg=len_in_reg, out_mod=2**32)
                    hash_patch_asm_code = hpag.get_asm_code()
                    patcher = StaticPatcher(full_target_file_path)
                    patch_success = patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)


                    if patch_success:
                        patcher.apply_patches(patched_elf_file_path)
                        hash_func_patch_details.patch_insert_successes[os.path.basename(hash_patch_asm_file)] = True
                        break
                if not patch_success:
                    hash_func_patch_details.add_err("Could not add replacement hash function to binary (aborting patching).")
                    continue

                # Now check the patched hash function
                hash_patch_evaluator.set_patch(patched_elf_file_path)

                # Case sensitivity
                patch_case_sensitivity = hash_patch_evaluator.check_case_sensitivity(case_sensitivity_check_strs, check_original=False)
                hash_func_patch_details.patch_case_sensitive = patch_case_sensitivity

                # Check the external memory references (outside the stack-frame of the hash function)
                ext_mem_refs_irregularities = hash_patch_evaluator.check_ext_mem_refs(ext_mem_refs_checks, check_original=False) # We need to use the same concrete buffers so that we know what memory references to expect
                hash_func_patch_details.patch_hash_ext_mem_ref_irregularities = ext_mem_refs_irregularities


                # Check that hash values we get for the patched hash function have preimages for the original hash function
                range_irregularities = hash_patch_evaluator.check_hash_vals_range(conc_bufs=['aa', 'AbC'])
                hash_func_patch_details.range_irregularities = range_irregularities



        except Exception as e:
            results.add_err(str(e))
        return results 

    def hash_func_is_used(self, hash_func_use):
        hash_func_reads = hash_func_use.reads
        hash_func_writes = hash_func_use.writes
        hash_func_seeks = hash_func_use.seeks

        return len(hash_func_reads) > 0 or len(hash_func_writes) > 0 or len(hash_func_seeks) > 0

class HashFuncPatchingAnalysisResults(AnalysisResults):

    def __init__(self, hash_func_use_analysis_results, errs):
        AnalysisResults.__init__(self)
        self.hash_func_use_analysis_results = hash_func_use_analysis_results
        self.hash_func_patch_details_list = []
        self.errs = errs


    def add_hash_func_patch_details(self, hash_func_patch_details):
        self.hash_func_patch_details_list.append(hash_func_patch_details)

    def get_tracked_events(self):
        tracked_events = {}
        tracked_events['errs'] = len(self.errs)

        return tracked_events

class HashFuncPatchDetails():

    # patch_target should be  discovered hash func
    def __init__(self, patch_target):
        self.patch_target = patch_target

        self.orig_case_sensitive = None
        self.orig_hash_val_irregularities = []
        self.orig_hash_sig1 = None
        self.orig_hash_sig2 = None
        self.orig_hash_val_irregularities = None
        self.orig_hash_ext_mem_ref_irregularities = None

        self.patch_insert_successes = None

        self.patch_case_sensitive = None
        self.patch_hash_ext_mem_ref_irregularities = None

        self.range_irregularities = None

        self.errs = []

    def add_err(self, err):
        self.errs.append(err)
    

