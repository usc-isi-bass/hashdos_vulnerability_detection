import angr

from binalyzer.analyzers.analysis import Analysis
from binalyzer.analyzers.analysis_results import AnalysisResults

from hash_func_discovery.hash_func_discoverer import HashFuncDiscoverer

hash_names = ['bkdr', 'dek', 'djb', 'elf', 'fnv', 'js', 'rs', 'sdbm']
class HashFuncElfSymbolAnalysis(Analysis):


    def __init__(self, cached_results_path: str=None):
        super().__init__(cached_results_path)

    def results_constructor(self):
        return HashFuncElfSymbolAnalysisResults
    
    def analyze(self, analysis_target, results):
        errs = []

        try:
            full_target_file_path = analysis_target.full_file_path
            proj = angr.Project(full_target_file_path, auto_load_libs=False)
            for symbol in proj.loader.symbols:
                symbol_name = symbol.name
                symbol_addr = symbol.rebased_addr
                if 'hash' in symbol_name.lower():
                    unknown_hash = True
                    for hash_name in hash_names:
                        if hash_name in symbol_name.lower():
                            dfes = DiscoveredFuncElfSymbol(symbol_name, symbol_addr, hash_name)
                            results.add_discovered_hash_func_elf_symbol(dfes)
                            unknown_hash = False
                    if unknown_hash:
                        dfes = DiscoveredFuncElfSymbol(symbol_name, symbol_addr, 'unknown')
        except Exception as e:
            #raise e
            results.add_err(str(e))
            
                   

class HashFuncElfSymbolAnalysisResults(AnalysisResults):

    def __init__(self):
        AnalysisResults.__init__(self)
        self.discovered_hash_func_elf_symbols = []
        self.errs = []

    def add_discovered_hash_func_elf_symbol(self, discovered_hash_func_elf_symbol):
        self.discovered_hash_func_elf_symbols.append(discovered_hash_func_elf_symbol)

    def get_tracked_events(self):
        tracked_events = {}
        tracked_events['errs'] = len(self.errs)
        tracked_events['hashes_discovered'] = len(self.discovered_hash_func_elf_symbols)
        tracked_events['timeouts'] = len([e for e in self.errs if 'timeout' in e])

        return tracked_events

    def copy_from_inner(self, other_analysis_results):
        for discovered_hash_func_elf_symbol in other_analysis_results.discovered_hash_func_elf_symbols:
            self.add_discovered_hash_func_elf_symbol(discovered_hash_func_elf_symbol)

        for err in other_analysis_results.errs:
            self.add_err(err)

class DiscoveredFuncElfSymbol():
    def __init__(self, func_name, func_addr, hash_func_name):
        self.func_name = func_name
        self.func_addr = func_addr
        self.hash_func_name = hash_func_name

    def __eq__(self, o):
        if not isinstance(o, DiscoveredFuncElfSymbol):
            raise NotImplementedError(" __eq__ not defined for types {} and {}".format(type(self), type(o)))

        return self.func_name == o.func_name \
            and self.func_addr == o.func_addr \
            and self.hash_func_name == o.hash_func_name

    def __hash__(self):
        return hash((self.func_name, self.func_addr, self.hash_func_name))

