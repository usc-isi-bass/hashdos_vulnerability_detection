import angr
import re

from binalyzer.analyzers.analysis import Analysis
from binalyzer.analyzers.analysis_results import AnalysisResults

from hash_func_discovery.hash_func_discoverer import HashFuncDiscoverer

hash_names = {'bkdr': 131, 'dek':27, 'djb':5381, 'elf':4026531840, 'fnv':2166136261, 'js':1315423911, 'rs':378551, 'sdbm':65599}
class HashFuncElfSymbolAnalysis(Analysis):


    def __init__(self, cached_results_path: str=None):
        super().__init__(cached_results_path)

    def results_constructor(self):
        return HashFuncElfSymbolAnalysisResults
    
    def analyze(self, analysis_target, results):
        errs = []

        try:
            full_target_file_path = analysis_target.full_file_path
            proj = angr.Project(full_target_file_path, auto_load_libs=False)
            cfg = proj.analyses.CFGFast(normalize=True)
            for func_addr, func in cfg.functions.items():
                if func.is_plt:
                    continue
                func_name = func.name
                if 'hash' in func_name.lower():
                    for hash_name, imm in hash_names.items():
                        if self.contains_imm(func, imm):
                            dfes = DiscoveredFuncElfSymbol(func_name, func_addr, hash_name)
                            results.add_discovered_hash_func_elf_symbol(dfes)
        except Exception as e:
            #raise e
            results.add_err(str(e))


    def contains_imm(self, func, imm):
        for block in func.blocks:
            insns = block.capstone.insns
            for insn in insns:
                if insn.mnemonic[0] == 'j':
                    # Probably a jump instruction
                    continue
                for op in insn.operands:
                    if op.type == 2: # Capstone uses 2 for immediate operand types
                        if op.imm == imm:
                            return True
        return False
            
                   

class HashFuncElfSymbolAnalysisResults(AnalysisResults):

    def __init__(self):
        AnalysisResults.__init__(self)
        self.discovered_hash_func_elf_symbols = []
        self.errs = []

    def add_discovered_hash_func_elf_symbol(self, discovered_hash_func_elf_symbol):
        self.discovered_hash_func_elf_symbols.append(discovered_hash_func_elf_symbol)

    def get_tracked_events(self):
        tracked_events = {}
        tracked_events['errs'] = len(self.errs)
        tracked_events['hashes_discovered'] = len(self.discovered_hash_func_elf_symbols)
        tracked_events['timeouts'] = len([e for e in self.errs if 'timeout' in e])

        return tracked_events

    def copy_from_inner(self, other_analysis_results):
        for discovered_hash_func_elf_symbol in other_analysis_results.discovered_hash_func_elf_symbols:
            self.add_discovered_hash_func_elf_symbol(discovered_hash_func_elf_symbol)

        for err in other_analysis_results.errs:
            self.add_err(err)

class DiscoveredFuncElfSymbol():
    def __init__(self, func_name, func_addr, hash_func_name):
        self.func_name = func_name
        self.func_addr = func_addr
        self.hash_func_name = hash_func_name

    def __eq__(self, o):
        if not isinstance(o, DiscoveredFuncElfSymbol):
            raise NotImplementedError(" __eq__ not defined for types {} and {}".format(type(self), type(o)))

        return self.func_name == o.func_name \
            and self.func_addr == o.func_addr \
            and self.hash_func_name == o.hash_func_name

    def __hash__(self):
        return hash((self.func_name, self.func_addr, self.hash_func_name))

