import angr

from binalyzer.analyzers.analysis import Analysis
from binalyzer.analyzers.analysis_results import AnalysisResults

import stashed_extended.stashed as stashed

class HashFuncDiscoveryAnalysis(Analysis):

    def __init__(self, similarity_score_cutoff):
        self._similarity_score_cutoff = similarity_score_cutoff

    def results_constructor(self):
        return HashFuncDiscoveryAnalysisResults
    
    def analyze(self, analysis_target, results):
        errs = []
        results.set_similarity_score_cutoff(self._similarity_score_cutoff)
        

        try:
            full_target_file_path = analysis_target.full_file_path
            proj = angr.Project(full_target_file_path, auto_load_libs=False)

            cfg_fast = proj.analyses.CFGFast()
            func_addrs_with_constants = self.constant_search(proj, cfg_fast)
            if len(func_addrs_with_constants) <= 0:
                return
            results.set_constants_found(True)
            stashed_cfg = proj.analyses.CFGFast(normalize=True, force_complete_scan=False, function_starts=func_addrs_with_constants, start_at_entry=False)
            stash = stashed.Stashed(proj, stashed_cfg)
            stashed_times = stash.get_times()
            results.add_stashed_times(stashed_times)
            # func_match is the hash function name (str) that the one in the binary appears to be
            for func_match in stash.func_matches:
                discovered_func, discovered_func_addr, discovered_func_score = stash.func_matches[func_match]    
                if discovered_func_score >= self._similarity_score_cutoff:
                    discovered_func_num_blocks = len(list(discovered_func.blocks))
                    discovered_func_byte_size = sum(len(block.bytes) for block in discovered_func.blocks)
                    discovered_func_obj = DiscoveredFunc(discovered_func.name, discovered_func.addr, discovered_func_num_blocks, discovered_func_byte_size, discovered_func_score, func_match)
                    results.add_discovered_hash_func(discovered_func_obj)
        except Exception as e:
            results.add_err(str(e))
            
                

    def constant_search(self, proj, cfg):
        func_addrs = set()
        for addr, func in cfg.functions.items():
            for block in func.blocks:
                insns = block.capstone.insns
                for insn in insns:
                    for op in insn.operands:
                        for mmnem, mimm in constants:
                            mhash = constants[(mmnem, mimm)]
                            if mimm == op.imm and (insn.mnemonic in mmnem or mmnem in insn.mnemonic):
                                    func_addrs.add(addr)
        return func_addrs
                

class HashFuncDiscoveryAnalysisResults(AnalysisResults):

    def __init__(self):
        AnalysisResults.__init__(self)
        self.similarity_score_cutoff = None
        self.constants_found = False
        self.discovered_hash_funcs = []
        self.errs = []

    def set_similarity_score_cutoff(self, value):
        self.similarity_score_cutoff = value

    def set_constants_found(self, value):
        self.constants_found = value


    def add_stashed_times(self, stashed_times):
        self.stashed_times = stashed_times

    def add_discovered_hash_func(self, discovered_hash_func):
        self.discovered_hash_funcs.append(discovered_hash_func)

    def get_tracked_events(self):
        tracked_events = {}
        tracked_events['errs'] = len(self.errs)
        tracked_events['hashes_discovered'] = len(self.discovered_hash_funcs)

        return tracked_events

class DiscoveredFunc():
    def __init__(self, func_name, func_addr, func_num_blocks, func_byte_size, similarity_score, hash_func_name):
        self.func_name = func_name
        self.func_addr = func_addr
        self.func_num_blocks = func_num_blocks
        self.func_byte_size = func_byte_size
        self.similarity_score = similarity_score
        self.hash_func_name = hash_func_name

    def __eq__(self, o):
        if not isinstance(o, DiscoveredHashFunc):
            raise NotImplementedError(" __eq__ not defined for types {} and {}".format(type(self), type(o)))

        return self.func_name == o.func_name \
            and self.func_addr == o.func_addr \
            and self.func_num_blocks == o.func_num_blocks \
            and self.func_byte_size == o.func_byte_size \
            and self.similarity_score == o.similarity_score \
            and self.hash_func_name == o.hash_func_name

    def __hash__(self):
        return hash((self.func_name, self.func_addr, self.func_num_blocks, self.func_byte_size, self.similarity_score, self.hash_func_name))

constants = {
    ('imul', 0x5c6b7):'rshash',
    ('mov', 0x5c6b7):'rshash',
    ('mov', 0xf8c9):'rshash',
    ('mov', 0x4e67c6a7):'jshash',
    ('xor', 0x4e67c6a7):'jshash',
    ('add', 0xe092c689):'jshash',
    ('and', 0xF0000000):'elfhash',
    ('xor', 0xF0000000):'elfhash',
    ('mov', 0xF0000000):'elfhash',
    #('imul', 0x1f):'bkdrhash',
    #('mov', 0x1f):'bkdrhash',
    ('imul', 0x83):'bkdrhash',
    ('mov', 0x83):'bkdrhash',
    ('imul', 0x521):'bkdrhash',
    ('mov', 0x521):'bkdrhash',
    ('imul', 0x334b):'bkdrhash',
    ('mov', 0x334b):'bkdrhash',
    ('imul', 0x200f1):'bkdrhash',
    ('mov', 0x200f1):'bkdrhash',
    ('mov', 0x811c9dc5):'fnvhash',
    ('imul', 0x811c9dc5):'fnvhash',
    ('imul', 0x1003f):'sdbmhash',
    ('imul', 0x10040):'sdbmhash',
    ('shl', 6):'sdbmhash',
    ('mov', 0x1505):'djbhash',
    ('imul', 0x21):'djbhash',
    ('ror', 0x1b):'dekhash',
    ('shr', 0x1b):'dekhash',
    ('rol', 0x5):'dekhash',
    ('mov', 0xaaaaaaaa):'aphash'
}


