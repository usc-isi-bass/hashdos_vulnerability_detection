import sys
import angr
import claripy

from binalyzer.analyzers.analysis import Analysis
from binalyzer.analyzers.analysis_results import AnalysisResults

import util.angr_util as angr_util

from analyses.hash_func_discovery.hash_func_discovery_analysis import HashFuncDiscoveryAnalysis
from analyses.hash_func_discovery.hash_func_discovery_analysis import HashFuncDiscoveryAnalysisResults

class HashFuncUseAnalysis(Analysis):

    def __init__(self, similarity_score_cutoff, block_symex_upperbound):
        self._similarity_score_cutoff = similarity_score_cutoff
        self._hash_func_discovery_analysis = HashFuncDiscoveryAnalysis(similarity_score_cutoff)
        self._block_symex_upperbound = block_symex_upperbound
    
    def analyze(self, analysis_target):
        errs = []
        results = HashFuncUseAnalysisResults(None, errs)

        try:
            full_target_file_path = analysis_target.full_file_path
            hash_func_discovery_analysis_results = self._hash_func_discovery_analysis.analyze(analysis_target)
            results = HashFuncUseAnalysisResults(hash_func_discovery_analysis_results, errs)
            discovered_hash_funcs = hash_func_discovery_analysis_results.discovered_hash_funcs
            if len(discovered_hash_funcs) <= 0:
                return results
                
            proj = angr.Project(full_target_file_path, auto_load_libs=False)
            cfg_fast = proj.analyses.CFGFast()
            for discovered_hash_func in discovered_hash_funcs:
                hash_func = cfg_fast.functions.function(discovered_hash_func.func_addr)
                hash_func_contexts = get_func_contexts(cfg_fast, hash_func)
                for hash_func, hash_func_caller, hash_func_call_site, hash_func_ret_site in hash_func_contexts:
                    mem_read_hash_deps = []
                    mem_write_hash_deps = []
                    file_seek_hash_deps = []

                    hash_func_use = HashFuncUse(discovered_hash_func, hash_func_caller.name, hash_func_call_site, hash_func_ret_site, mem_read_hash_deps, mem_write_hash_deps, file_seek_hash_deps)
                    results.add_hash_func_use(hash_func_use)
                    # A break point for memory reads. Flag if the address being read from depends on the hash return value.
                    def mem_read_break(state):
                        try:
                            read_addr = state.inspect.mem_read_address
                            if angr_util.symbolic_var_depends_on_varname(read_addr, 'hash_ret_val'):
                                mem_read_hash_deps.append(state.addr)
                                #l.debug("Mem read: state Addr: 0x{:x} read addr: {}".format(state.addr, read_addr))
                        except Exception as e:
                            #print("Err: {}".format(str(e)), file=sys.stderr)
                            results.add_err(str(e))
                            raise e
                    # A break point for memory writes. Flag if the address being written to depends on the hash return value.
                    def mem_write_break(state):
                        try:
                            write_addr = state.inspect.mem_write_address
                            if angr_util.symbolic_var_depends_on_varname(write_addr, 'hash_ret_val'):
                                mem_write_hash_deps.append(state.addr)
                                #l.debug("Mem write: state Addr: 0x{:x} read addr: {}".format(state.addr, write_addr))

                        except Exception as e:
                            #print("Err: {}".format(str(e)), file=sys.stderr)
                            results.add_err(str(e))
                            raise e

                    class FseekHook(angr.SimProcedure):
                        def run(self, stream, offset, origin):
                            try:
                                if angr_util.symbolic_var_depends_on_varname(offset, 'hash_ret_val'):
                                    # state.addr is in the library the predecessor is in the PLT and the next predecessor is the call site we want
                                    call_site = list(self.state.history.lineage)[-3]
                                    #l.debug("Fseek: state Addr: 0x{:x} offset: {}".format(call_site.addr, offset))
                                    file_seek_hash_deps.append(call_site.addr)

                            except Exception as e:
                                #print("Err: {}".format(str(e)), file=sys.stderr)
                                results.add_err(str(e))
                                raise e
                    class LseekHook(angr.SimProcedure):
                        def run(self, fd, offset, whence):
                            try:
                                if angr_util.symbolic_var_depends_on_varname(offset, 'hash_ret_val'):
                                    # state.addr is in the library the predecessor is in the PLT and the next predecessor is the call site we want
                                    call_site = list(self.state.history.lineage)[-3]
                                    #l.debug("Lseek: state Addr: 0x{:x} offset: {}".format(call_site.addr, offset))
                                    file_seek_hash_deps.append(call_site.addr)

                            except Exception as e:
                                #print("Err: {}".format(str(e)), file=sys.stderr)
                                results.add_err(str(e))
                                raise e

                    return_state = proj.factory.blank_state(addr=hash_func_ret_site)
                    return_state.inspect.b('mem_read', when=angr.BP_BEFORE, action=mem_read_break)
                    return_state.inspect.b('mem_write', when=angr.BP_BEFORE, action=mem_write_break)
                    proj.hook_symbol('fseek', FseekHook())
                    proj.hook_symbol('lseek', LseekHook())
                    hash_return_val = claripy.BVS('hash_ret_val', size=proj.arch.bits)
                    angr_util.set_state_ret_reg(proj, return_state, hash_return_val)
                    return_state.add_constraints(hash_return_val == 0) # Makes it a bit faster... we may assume the hash function returns 0 right?
                    simgr = proj.factory.simulation_manager(return_state)
                    for i in range(self._block_symex_upperbound):
                        if len(simgr.active) <= 0:
                            break
                        simgr.step()
                    proj.unhook_symbol('fseek')
                    proj.unhook_symbol('lseek')



        except Exception as e:
            results.add_err(str(e))
        return results 

# Returns a set of tuples, each containing (called_func, calling_func, called_func_call_site (in calling_func), called_func_ret_site (in calling_func))
# calling_func is the function calling called_func
# called_func_call_site is the call site of called_func in calling_func
# called_func_ret_site is the site to which the call_site returns
def get_func_contexts(cfg, called_func):
    contexts = set()
    callgraph = cfg.functions.callgraph
    called_func_addr = called_func.addr
    called_func_pred_addrs = callgraph.predecessors(called_func_addr)
    for called_func_pred_addr in called_func_pred_addrs:
        called_func_pred_node = cfg.model.get_any_node(called_func_pred_addr)
        called_func_pred_func_addr = called_func_pred_node.function_address
        calling_func = cfg.functions.function(called_func_pred_func_addr)
        if calling_func is None:
            #l.error("Could not find calling function of called function {} at address 0x{:x}".format(called_func.name, func_pred_addr))
            continue

        # Find the return sites of the called function
        called_func_call_sites = angr_util.get_func_call_sites_for(calling_func, called_func)
        for called_func_call_site in called_func_call_sites:
            called_func_ret_site = calling_func.get_call_return(called_func_call_site)
            contexts.add((called_func, calling_func, called_func_call_site, called_func_ret_site))
    return contexts

class HashFuncUseAnalysisResults(AnalysisResults):

    def __init__(self, hash_func_discovery_analysis_results, errs):
        AnalysisResults.__init__(self)
        self.hash_func_discovery_analysis_results = hash_func_discovery_analysis_results
        self.errs = errs
        self.hash_func_uses = []

    def add_hash_func_use(self, hash_func_use):
        self.hash_func_uses.append(hash_func_use)


    def get_tracked_events(self):
        tracked_events = {}
        tracked_events['errs'] = len(self.errs)
        tracked_events['reads/writes/seeks discovered'] = sum([1 for hfu in self.hash_func_uses if (len(hfu.reads) > 0 or len(hfu.writes) > 0 or len(hfu.seeks) > 0)])

        return tracked_events


class HashFuncUse():
    def __init__(self, discovered_hash_func, caller, call_site, ret_site, reads, writes, seeks):
        self.discovered_hash_func = discovered_hash_func
        self.caller = caller
        self.call_site = call_site
        self.ret_site = ret_site
        self.reads = reads
        self.writes = writes
        self.seeks = seeks

