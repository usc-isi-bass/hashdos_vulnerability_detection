import os
from nose.tools import *
import tempfile
import shutil
import subprocess

import angr
import claripy

from hash_patcher.static_patcher import StaticPatcher
from hash_patcher.hash_patch_asm_generator import HashPatchAsmGenerator
from hash_patcher.hash_func_evaluator import HashFuncEvaluator

test_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'test_binaries')
test_data_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'hash_patches')

def test_get_buf_reads_bkdr_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'BKDRHash')

def test_get_buf_reads_bkdr_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'BKDRHash')

def test_get_buf_reads_dek_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'DEKHash')

def test_get_buf_reads_dek_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'DEKHash')

def test_get_buf_reads_pjw_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'PJWHash')

def test_get_buf_reads_pjw_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'PJWHash')

def test_get_buf_reads_rs_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'RSHash')

def test_get_buf_reads_rs_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'RSHash')

def test_get_buf_reads_js_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'JSHash')

def test_get_buf_reads_js_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'JSHash')

def test_get_buf_reads_sdbm_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'SDBMHash')

def test_get_buf_reads_sdbm_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'SDBMHash')

def test_get_buf_reads_djb_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'DJBHash')

def test_get_buf_reads_djb_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'DJBHash')

def test_get_buf_reads_elf_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'ELFHash')

def test_get_buf_reads_elf_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'ELFHash')

def test_get_buf_reads_ap_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'APHash')

def test_get_buf_reads_ap_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'APHash')

def test_get_buf_reads_siphash_case_insensitive_sig1():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    hash_func = cfg.functions.function(name='patch_target_func')


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func_case_insensitive.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func')

    shutil.rmtree(tempdir)

def test_get_buf_reads_siphash_case_insensitive_sig2():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    hash_func = cfg.functions.function(name='patch_target_func')


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func_case_insensitive.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func')


    shutil.rmtree(tempdir)

def test_get_buf_reads_siphash_sig1():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func')

    shutil.rmtree(tempdir)

def test_get_buf_reads_siphash_sig2():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func')

    shutil.rmtree(tempdir)

def test_get_buf_reads_univhash_sig1():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func')

    shutil.rmtree(tempdir)

def test_get_buf_reads_univhash_sig2():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()



    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func')

    shutil.rmtree(tempdir)

def test_get_buf_reads_univhash_case_insensitive_sig1():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func_case_insensitive.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func')

    shutil.rmtree(tempdir)

def test_get_buf_reads_univhash_case_insensitive_sig2():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func_case_insensitive.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func')

    shutil.rmtree(tempdir)



def check_elf_and_hash(elf_file_path, hash_func_name):
    elf_file_path = os.path.join(test_location, elf_file_path)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()

    hash_func = cfg.functions.function(name=hash_func_name)

    hash_func_evaluator = HashFuncEvaluator(elf_file_path, hash_func.addr, proj=proj)

    for i in range(1, 11):

        buf = 'a' * i
        buf_addr, actions = hash_func_evaluator.get_buf_reads(buf)
        check_addr_reads(buf, buf_addr, actions)

# Check that all addr reads happen within range
def check_addr_reads(buf, buf_addr, actions):
    buf_len = len(buf)
    solver = claripy.Solver()
    buf_addr = solver.eval(buf_addr, 1)[0]
    read_addrs = set()
    for action in actions:
        addr = solver.eval(action.addr.to_claripy(), 1)[0]
        size = solver.eval(action.size.to_claripy(), 1)[0]
        size_bytes = size // 8
        assert_greater_equal(addr, buf_addr, msg='Illegal buffer access buffer: 0x{:x} read: 0x{:x} size: {}'.format(buf_addr, addr, size))
        assert_less_equal(addr + size_bytes, buf_addr + buf_len, msg='Illegal buffer access buffer: 0x{:x} read: 0x{:x} size: {}'.format(buf_addr, addr, size))

        # SipHash does not access addrs one by one
        for i in range(size_bytes):
            read_addrs.add(addr + i)

    assert_equals(len(read_addrs), buf_len, msg='Not all addresses in the buffer were accessed: buf: {} buf_addr: {} accesses: {}'.format(buf, buf_addr, read_addrs))

