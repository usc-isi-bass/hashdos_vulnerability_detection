import os
from nose.tools import *
import tempfile
import shutil
import subprocess
import logging

import angr
import claripy

from hash_patcher.static_patcher import StaticPatcher
from hash_patcher.hash_patch_asm_generator import HashPatchAsmGenerator
from hash_patcher.hash_func_evaluator import HashFuncEvaluatorSig1, HashFuncEvaluatorSig2

logging.getLogger('angr').setLevel(logging.CRITICAL)
logging.getLogger('cle').setLevel(logging.CRITICAL)
logging.getLogger('claripy').setLevel(logging.CRITICAL)
logging.getLogger('claripy.balancer').setLevel(logging.CRITICAL)
logging.getLogger('pyvex').setLevel(logging.CRITICAL)
logging.getLogger('pyvex.lifting.libvex').setLevel(logging.CRITICAL)
logging.getLogger('archinfo.arch').setLevel(logging.CRITICAL)



test_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'test_binaries')
test_data_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'hash_patches')

def test_get_ext_mem_refs_bkdr_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'BKDRHash', 'sig1')

def test_get_ext_mem_refs_bkdr_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'BKDRHash', 'sig2')

def test_get_ext_mem_refs_dek_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'DEKHash', 'sig1')

def test_get_ext_mem_refs_dek_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'DEKHash', 'sig2')

def test_get_ext_mem_refs_pjw_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'PJWHash', 'sig1')

def test_get_ext_mem_refs_pjw_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'PJWHash', 'sig2')

def test_get_ext_mem_refs_rs_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'RSHash', 'sig1')

def test_get_ext_mem_refs_rs_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'RSHash', 'sig2')

def test_get_ext_mem_refs_js_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'JSHash', 'sig1')

def test_get_ext_mem_refs_js_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'JSHash', 'sig2')

def test_get_ext_mem_refs_sdbm_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'SDBMHash', 'sig1')

def test_get_ext_mem_refs_sdbm_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'SDBMHash', 'sig2')

def test_get_ext_mem_refs_djb_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'DJBHash', 'sig1')

def test_get_ext_mem_refs_djb_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'DJBHash', 'sig2')

def test_get_ext_mem_refs_elf_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'ELFHash', 'sig1')

def test_get_ext_mem_refs_elf_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'ELFHash', 'sig2')

def test_get_ext_mem_refs_ap_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'APHash', 'sig1')

def test_get_ext_mem_refs_ap_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'APHash', 'sig2')

def test_get_ext_mem_refs_siphash_case_insensitive_sig1():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    hash_func = cfg.functions.function(name='patch_target_func')


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func_case_insensitive.s')
    random_vals = {'rval1': 0x3837363534333231 ^ 0x6c7967656e657261, 'rval2': 0x3837363534333231 ^ 0x646f72616e646f6d, 'rval3': 0x3837363534333231 ^ 0x736f6d6570736575, 'rval4': 0x3837363534333231 ^ 0x7465646279746573}
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, random_vals=random_vals, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    patcher = StaticPatcher(elf_file_path)
    patch_success = patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    assert_true(patch_success, msg="Could not add patch to code")
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func', 'sig1')

    shutil.rmtree(tempdir)

def test_get_ext_mem_refs_siphash_case_insensitive_sig2():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    hash_func = cfg.functions.function(name='patch_target_func')


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func_case_insensitive.s')
    random_vals = {'rval1': 0x3837363534333231 ^ 0x6c7967656e657261, 'rval2': 0x3837363534333231 ^ 0x646f72616e646f6d, 'rval3': 0x3837363534333231 ^ 0x736f6d6570736575, 'rval4': 0x3837363534333231 ^ 0x7465646279746573}
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, random_vals=random_vals, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    patcher = StaticPatcher(elf_file_path)
    patch_success = patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    assert_true(patch_success, msg="Could not add patch to code")
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func', 'sig2')


    shutil.rmtree(tempdir)

def test_get_ext_mem_refs_siphash_sig1():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func.s')
    random_vals = {'rval1': 0x3837363534333231 ^ 0x6c7967656e657261, 'rval2': 0x3837363534333231 ^ 0x646f72616e646f6d, 'rval3': 0x3837363534333231 ^ 0x736f6d6570736575, 'rval4': 0x3837363534333231 ^ 0x7465646279746573}
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, random_vals=random_vals, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patch_success = patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    assert_true(patch_success, msg="Could not add patch to code")
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func', 'sig1')

    shutil.rmtree(tempdir)

def test_get_ext_mem_refs_siphash_sig2():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func.s')
    random_vals = {'rval1': 0x3837363534333231 ^ 0x6c7967656e657261, 'rval2': 0x3837363534333231 ^ 0x646f72616e646f6d, 'rval3': 0x3837363534333231 ^ 0x736f6d6570736575, 'rval4': 0x3837363534333231 ^ 0x7465646279746573}
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, random_vals=random_vals, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patch_success = patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    assert_true(patch_success, msg="Could not add patch to code")
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func', 'sig2')

    shutil.rmtree(tempdir)

def test_get_ext_mem_refs_univhash_sig1():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func.s')
    random_vals = {'rval1': 0x4078601, 'rval2': 0x42021}
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, random_vals=random_vals, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patch_success = patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    assert_true(patch_success, msg="Could not add patch to code")
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func', 'sig1')

    shutil.rmtree(tempdir)

def test_get_ext_mem_refs_univhash_sig2():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func.s')
    random_vals = {'rval1': 0x4078601, 'rval2': 0x42021}
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, random_vals=random_vals, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()



    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patch_success = patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    assert_true(patch_success, msg="Could not add patch to code")
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func', 'sig2')

    shutil.rmtree(tempdir)

def test_get_ext_mem_refs_univhash_case_insensitive_sig1():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func_case_insensitive.s')
    random_vals = {'rval1': 0x4078601, 'rval2': 0x42021}
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, random_vals=random_vals, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patch_success = patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    assert_true(patch_success, msg="Could not add patch to code")
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func', 'sig1')

    shutil.rmtree(tempdir)

def test_get_ext_mem_refs_univhash_case_insensitive_sig2():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func_case_insensitive.s')
    random_vals = {'rval1': 0x4078601, 'rval2': 0x42021}
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, random_vals=random_vals, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patch_success = patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    assert_true(patch_success, msg="Could not add patch to code")
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(patched_elf_file_path, 'patch_target_func', 'sig2')

    shutil.rmtree(tempdir)



def check_elf_and_hash(elf_file_path, hash_func_name, sig):
    elf_file_path = os.path.join(test_location, elf_file_path)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()

    hash_func = cfg.functions.function(name=hash_func_name)

    if sig == 'sig1':
        hash_func_evaluator = HashFuncEvaluatorSig1(elf_file_path, hash_func.addr, proj=proj)
    elif sig == 'sig2':
        hash_func_evaluator = HashFuncEvaluatorSig2(elf_file_path, hash_func.addr, proj=proj)
    else:
        raise Exception("Unknown signature: {}".format(sig))

    for i in range(1, 11):

        buf = 'a' * i
        if sig == 'sig1':
            call_state, ret_state = hash_func_evaluator.run_conc(buf, i)
        elif sig == 'sig2':
            call_state, ret_state = hash_func_evaluator.run_conc(buf)
        else:
            raise Exception("Unknown signature: {}".format(sig))

        ret_state_action_pairs = hash_func_evaluator._get_ext_mem_refs(call_state, [ret_state])
        buf_addr = call_state.solver.eval(call_state.regs.rdi)

        check_ext_mem_refs(buf, buf_addr, ret_state_action_pairs)

# Check that all external (out of stack) addr reads happen within range of the buffer
def check_ext_mem_refs(buf, buf_addr, ret_state_action_pairs):
    buf_len = len(buf)
    read_addrs = set()
    for ret_state, action in ret_state_action_pairs:
        addr = ret_state.solver.eval(action.addr.to_claripy())
        size = ret_state.solver.eval(action.size.to_claripy())
        size_bytes = size // 8
        assert_false(action.action == angr.state_plugins.SimActionData.WRITE, msg="Hash function writes to an external address! buf: {} @ 0x{:x} write: 0x{:x} size: {} action: {}".format(buf, buf_addr, addr, size, action))
        assert action.action == angr.state_plugins.SimActionData.READ, "Test logic error, not a read or a write: {}".format(action.action)
        assert_greater_equal(addr, buf_addr, msg='Illegal buffer access buffer: {} @ 0x{:x} read: 0x{:x} size: {} action: {}'.format(buf, buf_addr, addr, size, action))
        # Sometimes the hash function also accesses the NULL byte at the end
        assert_less_equal(addr + size_bytes, buf_addr + buf_len + 1, msg='Illegal buffer access buffer: {} @ 0x{:x} read: 0x{:x} size: {} action: {}'.format(buf, buf_addr, addr, size, action))

        # SipHash does not access addrs one by one
        for i in range(size_bytes):
            read_addrs.add(addr + i)


    # The number of addresses we access must be greater than the length of the buffer (if \0 is also accessed)
    # or equal
    # Since we ensure that all accesses occur in [buf_addr, buf_addr + buf_len + 1]
    # The pigeon hole principle will ensure that this is not greater than by more than 1
    assert_greater_equal(len(read_addrs), buf_len, msg='Not all addresses in the buffer were accessed: buf: {} buf_addr: {} accesses: {}'.format(buf, buf_addr, read_addrs))
    # But just to be safe, we check it anyway
    assert_less_equal(len(read_addrs), buf_len + 1, msg='Too many addresses in the buffer were accessed: buf: {} buf_addr: {} accesses: {}'.format(buf, buf_addr, read_addrs))

