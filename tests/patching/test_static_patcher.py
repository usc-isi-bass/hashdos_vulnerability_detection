import os
from nose.tools import *
import sys
import tempfile
import shutil
import subprocess

import angr

from hash_patcher.static_patcher import StaticPatcher

test_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'test_binaries')

def test_burn_code_caves():
    elf_file_name = os.path.join(test_location, 'inter_func_code_caves')
    patcher = StaticPatcher(elf_file_name)
    code_cave_graph = patcher._code_cave_graph
    patcher.burn_code_caves([0x401099])

    assert_true(0x401099 not in code_cave_graph.nodes, 'We burned code cave 0x{:x}, but its still in the cave.')

    patcher = StaticPatcher(elf_file_name)
    code_cave_graph = patcher._code_cave_graph
    patcher.burn_code_caves([0x40109a])

    assert_true(0x401099 not in code_cave_graph.nodes, 'We burned code cave 0x{:x}, but its still in the cave.')

    patcher = StaticPatcher(elf_file_name)
    code_cave_graph = patcher._code_cave_graph
    patcher.burn_code_caves([0x40109a])

    assert_true(0x401099 not in code_cave_graph.nodes, 'We burned code cave 0x{:x}, but its still in the cave.')


def test_hook_func1():
    elf_file_name = os.path.join(test_location, 'ret_0')
    return_code = subprocess.run(elf_file_name).returncode
    assert_equal(return_code, 0, msg='The test binary {} did not exit with code 0, as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    


    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov eax, 1", "pop rbp", "ret"] # A function that returns 1
    patch_target_func = cfg.functions.function(name='f')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    return_code = subprocess.run(patched_elf_file_path).returncode
    assert_equal(return_code, 1, msg='The patched binary {} created from {} should have returned 1, not {}'.format(patched_elf_file_path, elf_file_name, return_code))

    shutil.rmtree(tempdir)

def test_hook_func_ptr_callsite():
    # Function that calls a function pointer is called twice.
    # First with a function returning -1 and then a function returning 1
    # The results are added and returned from main
    # We wish to patch the function returning -1 so that it returns 0 instead
    # Therefore, main must return 1
    # If we patch at the call site, the replacement function will be called twice and main will return 0 (this is incorrect)
    elf_file_name = os.path.join(test_location, 'func_ptr_expanded')
    return_code = subprocess.run(elf_file_name).returncode
    assert_equal(return_code, 0, msg='The test binary {} did not exit with code 0, as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    


    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov eax, 0", "pop rbp", "ret"] # A function that returns 0
    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, patch_asm_code, patch_call_sites=True, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    return_code = subprocess.run(patched_elf_file_path).returncode
    assert_equal(return_code, 1, msg='The patched binary {} created from {} should have returned 1, not {}'.format(patched_elf_file_path, elf_file_name, return_code))

    shutil.rmtree(tempdir)

def test_hook_func2():
    elf_file_name = os.path.join(test_location, 'bip_hash')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 228', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))
    output = subprocess.check_output([elf_file_name, 'ab']).strip()
    assert_equal(output, b'h(ab) = 38', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))
    output = subprocess.check_output([elf_file_name, 'abc']).strip()
    assert_equal(output, b'h(abc) = 165', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    

    patch_asm_code = ["push rcx",
        "push rdx",
        "mov    ecx,0x4078601",
        "mov    eax,0x42021",
        "loop: inc    rdi",
        "mov    dl,BYTE PTR [rdi-0x1]",
        "test   dl,dl",
        "je     done",
        "lea    esi,[rdx-0x61]",
        "cmp    sil,0x19",
        "ja     fi",
        "xor    edx,0x20",
        "fi: movsx  edx,dl",
        "imul   edx,ecx",
        "add    eax,edx",
        "mov    edx,ecx",
        "shl    edx,0xd",
        "xor    edx,ecx",
        "mov    ecx,edx",
        "sar    ecx,0x11",
        "xor    edx,ecx",
        "mov    ecx,edx",
        "shl    ecx,0x5",
        "xor    ecx,edx",
        "jmp    loop",
        "done: pop rdx",
        "pop rcx",
        "ret"
    ]

    patch_target_func = cfg.functions.function(name='hash_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    output = subprocess.check_output([patched_elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 98', msg='The patched binary {} did not output as expected.'.format(patched_elf_file_path))
    output = subprocess.check_output([patched_elf_file_path, 'ab']).strip()
    assert_equal(output, b'h(ab) = 38', msg='The patched binary {} did not output as expected.'.format(patched_elf_file_path))
    output = subprocess.check_output([patched_elf_file_path, 'abc']).strip()
    assert_equal(output, b'h(abc) = 177', msg='The patched binary {} did not output as expected.'.format(patched_elf_file_path))
    shutil.rmtree(tempdir)



