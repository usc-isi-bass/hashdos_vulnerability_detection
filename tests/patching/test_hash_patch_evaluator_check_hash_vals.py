import os
from nose.tools import *
import tempfile
import shutil
import subprocess
import logging

import angr
import claripy

from hash_patcher.static_patcher import StaticPatcher
from hash_patcher.hash_patch_asm_generator import HashPatchAsmGenerator
from hash_patcher.hash_patch_evaluator import HashPatchEvaluator

logging.getLogger('angr').propagate = False
logging.getLogger('angr').disabled = True

test_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'test_binaries')
test_data_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'hash_patches')

hash_name_to_str_to_hashvals_map = {
        'BKDRHash': ({
            'zewcjMwibYN': 405292455,
            'wjsIk17Xt': 1492716444,
            'riirCNiePuU': 1323517445
        },),
	'DEKHash': ({
            'zewcjMwibYN': 421648236,
            'wjsIk17Xt': 1420362552,
            'riirCNiePuU': 1592165493
        },),
	'PJWHash': ({
            'zewcjMwibYN': 265108046,
            'wjsIk17Xt': 134099684,
            'riirCNiePuU': 137799621
        },),
	'RSHash': ({
            'zewcjMwibYN': 1726383709,
            'wjsIk17Xt': 858476154,
            'riirCNiePuU': 386955679
        },),
	'JSHash': ({
            'zewcjMwibYN': 2626515957,
            'wjsIk17Xt': 3925558630,
            'riirCNiePuU': 2466560561
        },),
	'SDBMHash': ({
            'zewcjMwibYN': 1052930155,
            'wjsIk17Xt': 2504187716,
            'riirCNiePuU': 3453000169
        },),
	'DJBHash': ({
            'zewcjMwibYN': 821053982,
            'wjsIk17Xt': 831859233,
            'riirCNiePuU': 3598206324
        },),
	'ELFHash': ({
            'zewcjMwibYN': 265108046,
            'wjsIk17Xt': 134099684,
            'riirCNiePuU': 137799621
        },),
	'APHash': ({
            'zewcjMwibYN': 2794787121,
            'wjsIk17Xt': 179435880,
            'riirCNiePuU': 1918854007
        },)
}

def test_check_hash_vals_bkdr_sig1():
    check_elf_and_hash('hash_funcs_sig1', None, 'BKDRHash', 'sig1', {})
    check_elf_and_hash_irregular('hash_funcs_sig1', None, 'BKDRHash', 'sig1')

def test_check_hash_vals_bkdr_sig2():
    check_elf_and_hash('hash_funcs_sig2', None, 'BKDRHash', 'sig2', {})
    check_elf_and_hash_irregular('hash_funcs_sig2', None, 'BKDRHash', 'sig2')

def test_check_hash_vals_dek_sig1():
    check_elf_and_hash('hash_funcs_sig1', None, 'DEKHash', 'sig1', {})
    check_elf_and_hash_irregular('hash_funcs_sig1', None, 'DEKHash', 'sig1')

def test_check_hash_vals_dek_sig2():
    check_elf_and_hash('hash_funcs_sig2', None, 'DEKHash', 'sig2', {})
    check_elf_and_hash_irregular('hash_funcs_sig2', None, 'DEKHash', 'sig2')

def test_check_hash_vals_pjw_sig1():
    check_elf_and_hash('hash_funcs_sig1', None, 'PJWHash', 'sig1', {})
    check_elf_and_hash_irregular('hash_funcs_sig1', None, 'PJWHash', 'sig1')

def test_check_hash_vals_pjw_sig2():
    check_elf_and_hash('hash_funcs_sig2', None, 'PJWHash', 'sig2', {})
    check_elf_and_hash_irregular('hash_funcs_sig2', None, 'PJWHash', 'sig2')

def test_check_hash_vals_rs_sig1():
    check_elf_and_hash('hash_funcs_sig1', None, 'RSHash', 'sig1', {})
    check_elf_and_hash_irregular('hash_funcs_sig1', None, 'RSHash', 'sig1')

def test_check_hash_vals_rs_sig2():
    check_elf_and_hash('hash_funcs_sig2', None, 'RSHash', 'sig2', {})
    check_elf_and_hash_irregular('hash_funcs_sig2', None, 'RSHash', 'sig2')

def test_check_hash_vals_js_sig1():
    check_elf_and_hash('hash_funcs_sig1', None, 'JSHash', 'sig1', {})
    check_elf_and_hash_irregular('hash_funcs_sig1', None, 'JSHash', 'sig1')

def test_check_hash_vals_js_sig2():
    check_elf_and_hash('hash_funcs_sig2', None, 'JSHash', 'sig2', {})
    check_elf_and_hash_irregular('hash_funcs_sig2', None, 'JSHash', 'sig2')

def test_check_hash_vals_sdbm_sig1():
    check_elf_and_hash('hash_funcs_sig1', None, 'SDBMHash', 'sig1', {})
    check_elf_and_hash_irregular('hash_funcs_sig1', None, 'SDBMHash', 'sig1')

def test_check_hash_vals_sdbm_sig2():
    check_elf_and_hash('hash_funcs_sig2', None, 'SDBMHash', 'sig2', {})
    check_elf_and_hash_irregular('hash_funcs_sig2', None, 'SDBMHash', 'sig2')

def test_check_hash_vals_djb_sig1():
    check_elf_and_hash('hash_funcs_sig1', None, 'DJBHash', 'sig1', {})
    check_elf_and_hash_irregular('hash_funcs_sig1', None, 'DJBHash', 'sig1')

def test_check_hash_vals_djb_sig2():
    check_elf_and_hash('hash_funcs_sig2', None, 'DJBHash', 'sig2', {})
    check_elf_and_hash_irregular('hash_funcs_sig2', None, 'DJBHash', 'sig2')

def test_check_hash_vals_elf_sig1():
    check_elf_and_hash('hash_funcs_sig1', None, 'ELFHash', 'sig1', {})
    check_elf_and_hash_irregular('hash_funcs_sig1', None, 'ELFHash', 'sig1')

def test_check_hash_vals_elf_sig2():
    check_elf_and_hash('hash_funcs_sig2', None, 'ELFHash', 'sig2', {})
    check_elf_and_hash_irregular('hash_funcs_sig2', None, 'ELFHash', 'sig2')

def test_check_hash_vals_ap_sig1():
    check_elf_and_hash('hash_funcs_sig1', None, 'APHash', 'sig1', {})

def test_check_hash_vals_ap_sig2():
    check_elf_and_hash('hash_funcs_sig2', None, 'APHash', 'sig2', {})
    check_elf_and_hash_irregular('hash_funcs_sig2', None, 'APHash', 'sig2')

def test_check_hash_vals_siphash_case_insensitive_sig1():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    hash_func = cfg.functions.function(name='patch_target_func')


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func_case_insensitive.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig1', ({'asdf': 3358194305, 'aSdf': 3358194305, 'ASDF': 3358194305, '1234qwerty': 2506759691, '1234qwertY': 2506759691},))
    check_elf_and_hash_irregular(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig1')

    shutil.rmtree(tempdir)

def test_check_hash_vals_siphash_case_insensitive_sig2():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    hash_func = cfg.functions.function(name='patch_target_func')


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func_case_insensitive.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig2', ({'asdf': 3358194305, 'aSdf': 3358194305, 'ASDF': 3358194305, '1234qwerty': 2506759691, '1234qwertY': 2506759691},))
    check_elf_and_hash_irregular(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig2')


    shutil.rmtree(tempdir)

def test_check_hash_vals_siphash_sig1():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig1', ({'asdf': 1120073065, 'aSdf': 795266138, 'ASDF': 3358194305, '1234qwerty': 1822118885, '1234qwertY': 1073798917},))
    check_elf_and_hash_irregular(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig1')

    shutil.rmtree(tempdir)

def test_check_hash_vals_siphash_sig2():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig2', ({'asdf': 1120073065, 'aSdf': 795266138, 'ASDF': 3358194305, '1234qwerty': 1822118885, '1234qwertY': 1073798917},))
    check_elf_and_hash_irregular(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig2')

    shutil.rmtree(tempdir)

def test_check_hash_vals_univhash_sig1():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig1', (({'asdf': 2191461160, 'aSdf': 4230285032, 'ASDF': 1803756648, '1234qwerty': 3302325571, '1234qwertY': 2681412067},)))
    check_elf_and_hash_irregular(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig1')

    shutil.rmtree(tempdir)

def test_check_hash_vals_univhash_sig2():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()



    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig2', ({'asdf': 2191461160, 'aSdf': 4230285032, 'ASDF': 1803756648, '1234qwerty': 3302325571, '1234qwertY': 2681412067},))
    check_elf_and_hash_irregular(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig2')

    shutil.rmtree(tempdir)

def test_check_hash_vals_univhash_case_insensitive_sig1():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func_case_insensitive.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg='rsi', out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig1', ({'asdf': 1803756648, 'aSdf': 1803756648, 'ASDF': 1803756648, '1234qwerty': 1377037283, '1234qwertY': 1377037283},))
    check_elf_and_hash_irregular(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig1')

    shutil.rmtree(tempdir)

def test_check_hash_vals_univhash_case_insensitive_sig2():
    elf_file_path = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func_case_insensitive.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig2', ({'asdf': 1803756648, 'aSdf': 1803756648, 'ASDF': 1803756648, '1234qwerty': 1377037283, '1234qwertY': 1377037283},))
    check_elf_and_hash_irregular(elf_file_path, patched_elf_file_path, 'patch_target_func', 'sig2')

    shutil.rmtree(tempdir)



def check_elf_and_hash(elf_file_path, patch_file_path, hash_func_name, sig, patch_hash_func_conc_buf_hash_vals_map):
    elf_file_path = os.path.join(test_location, elf_file_path)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()

    hash_func = cfg.functions.function(name=hash_func_name)

    hash_patch_evaluator = HashPatchEvaluator(elf_file_path, hash_func.addr, sig, vuln_proj=proj)

    if patch_file_path is None:
        conc_buf_hash_vals_map = hash_name_to_str_to_hashvals_map[hash_func_name]
        irregularities = hash_patch_evaluator.check_hash_vals(hash_func_name, conc_buf_hash_vals_map, check_original=True)

        assert_equal(len(irregularities), 0, msg="We were not expecting irregularities, but got: {}".format(irregularities))
    else:
        hash_patch_evaluator.set_patch(patch_file_path)
        irregularities = hash_patch_evaluator.check_hash_vals(hash_func_name, patch_hash_func_conc_buf_hash_vals_map, check_original=False)
        assert_equal(len(irregularities), 0, msg="We were not expecting irregularities, but got: {}".format(irregularities))

def check_elf_and_hash_irregular(elf_file_path, patch_file_path, hash_func_name, sig):
    elf_file_path = os.path.join(test_location, elf_file_path)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()

    hash_func = cfg.functions.function(name=hash_func_name)

    hash_patch_evaluator = HashPatchEvaluator(elf_file_path, hash_func.addr, sig, vuln_proj=proj)

    conc_buf_hash_vals_map = ({'a': 0},) # Hopefully this is not true for any of our hash funcs
    if patch_file_path is None:
        irregularities = hash_patch_evaluator.check_hash_vals(hash_func_name, conc_buf_hash_vals_map, check_original=True)
    else:
        hash_patch_evaluator.set_patch(patch_file_path)
        irregularities = hash_patch_evaluator.check_hash_vals(hash_func_name, conc_buf_hash_vals_map, check_original=False)
    assert_not_equal(len(irregularities), 0, msg="We were expecting irregularities, but got none")

