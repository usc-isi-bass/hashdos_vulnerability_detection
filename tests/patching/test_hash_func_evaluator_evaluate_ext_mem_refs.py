import os
from nose.tools import *
import tempfile
import shutil
import subprocess
import logging

import angr
import claripy

from hash_patcher.static_patcher import StaticPatcher
from hash_patcher.hash_patch_asm_generator import HashPatchAsmGenerator
from hash_patcher.hash_func_evaluator import HashFuncEvaluatorSig1,HashFuncEvaluatorSig2

logging.getLogger('angr').setLevel(logging.CRITICAL)
logging.getLogger('cle').setLevel(logging.CRITICAL)
logging.getLogger('claripy').setLevel(logging.CRITICAL)
logging.getLogger('claripy.balancer').setLevel(logging.CRITICAL)
logging.getLogger('pyvex').setLevel(logging.CRITICAL)
logging.getLogger('pyvex.lifting.libvex').setLevel(logging.CRITICAL)
logging.getLogger('archinfo.arch').setLevel(logging.CRITICAL)



test_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'test_binaries')
test_data_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'hash_patches')

def test_evaluate_ext_mem_refs_bkdr_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'BKDRHash', 'sig1')

def test_evaluate_ext_mem_refs_bkdr_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'BKDRHash', 'sig2')

def test_evaluate_ext_mem_refs_dek_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'DEKHash', 'sig1')

def test_evaluate_ext_mem_refs_dek_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'DEKHash', 'sig2')

def test_evaluate_ext_mem_refs_pjw_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'PJWHash', 'sig1')

def test_evaluate_ext_mem_refs_pjw_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'PJWHash', 'sig2')

def test_evaluate_ext_mem_refs_rs_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'RSHash', 'sig1')

def test_evaluate_ext_mem_refs_rs_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'RSHash', 'sig2')

def test_evaluate_ext_mem_refs_js_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'JSHash', 'sig1')

def test_evaluate_ext_mem_refs_js_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'JSHash', 'sig2')

def test_evaluate_ext_mem_refs_sdbm_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'SDBMHash', 'sig1')

def test_evaluate_ext_mem_refs_sdbm_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'SDBMHash', 'sig2')

def test_evaluate_ext_mem_refs_djb_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'DJBHash', 'sig1')

def test_evaluate_ext_mem_refs_djb_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'DJBHash', 'sig2')

def test_evaluate_ext_mem_refs_elf_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'ELFHash', 'sig1')

def test_evaluate_ext_mem_refs_elf_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'ELFHash', 'sig2')

def test_evaluate_ext_mem_refs_ap_sig1():
    check_elf_and_hash('hash_funcs_sig1', 'APHash', 'sig1')

def test_evaluate_ext_mem_refs_ap_sig2():
    check_elf_and_hash('hash_funcs_sig2', 'APHash', 'sig2')

def check_elf_and_hash(elf_file_path, hash_func_name, sig):
    elf_file_path = os.path.join(test_location, elf_file_path)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()

    hash_func = cfg.functions.function(name=hash_func_name)

    if sig == 'sig1':
        hash_func_evaluator = HashFuncEvaluatorSig1(elf_file_path, hash_func.addr, proj=proj)
    elif sig == 'sig2':
        hash_func_evaluator = HashFuncEvaluatorSig2(elf_file_path, hash_func.addr, proj=proj)
    else:
        raise Exception("Unknown signature: {}".format(sig))

    for i in range(1, 11):

        buf = 'a' * i
        ret_state_action_pairs, irregularities = hash_func_evaluator.evaluate_ext_mem_refs(buf, i)
        assert_equal(len(irregularities), 0, msg="We were not expecting any irregularities for elf {} and hash {}, but found: {}".format(elf_file_path, hash_func_name, irregularities))

def test_evaluate_ext_mem_refs_irregular_hash_func_ext_memwrite_sig1():
    check_elf_and_hash_irregularity('irregular_hash_func_ext_memwrite_sig1', 'irr_hash', 'sig1', 'external_memwrite')

def test_evaluate_ext_mem_refs_irregular_hash_func_ext_memwrite_sig2():
    check_elf_and_hash_irregularity('irregular_hash_func_ext_memwrite_sig2', 'irr_hash', 'sig2', 'external_memwrite')


def check_elf_and_hash_irregularity(elf_file_path, hash_func_name, sig, irregularity_type):
    elf_file_path = os.path.join(test_location, elf_file_path)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()

    hash_func = cfg.functions.function(name=hash_func_name)

    if sig == 'sig1':
        hash_func_evaluator = HashFuncEvaluatorSig1(elf_file_path, hash_func.addr, proj=proj)
    elif sig == 'sig2':
        hash_func_evaluator = HashFuncEvaluatorSig2(elf_file_path, hash_func.addr, proj=proj)
    else:
        raise Exception("Unknown signature: {}".format(sig))

    for i in range(1, 11):

        buf = 'a' * i
        ret_state_action_pairs, irregularities = hash_func_evaluator.evaluate_ext_mem_refs(buf, i)
        assert_not_equal(len(irregularities), 0, msg="We were expecting an irregulary of type {} for elf {} and hash {}, but found nothing".format(elf_file_path, hash_func_name, irregularity_type))
        for irregularity in irregularities:
            assert_equal(irregularity.irregularity_type, irregularity_type, msg="We were expecting irregularity of type {} buf found {}".format(irregularity_type, irregularity.irregularity_type))

def test_evaluate_ext_mem_refs_siphash_sig2():
    elf_file_path = os.path.join(test_location, 'sn_hash')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 3524', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'sip_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()

    hash_func = cfg.functions.function(name='dhhash')
    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash_patch(elf_file_path, patched_elf_file_path, 'dhhash', 'sig2')

    shutil.rmtree(tempdir)

def test_evaluate_ext_mem_refs_univhash_sig2():
    elf_file_path = os.path.join(test_location, 'sn_hash')
    output = subprocess.check_output([elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 3524', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_path))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_path + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    patch_asm_code_file = os.path.join(test_data_location, 'univ_hash_func.s')
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rdi', len_in_reg=None, out_mod=2**32)
    hash_patch_asm_code = hpag.get_asm_code()



    hash_func = cfg.functions.function(name='dhhash')
    patcher = StaticPatcher(elf_file_path)
    patcher.hook_func(hash_func.addr, hash_patch_asm_code, patch_call_sites=False, patch_orig_func=True)
    patcher.apply_patches(patched_elf_file_path)

    check_elf_and_hash_patch(elf_file_path, patched_elf_file_path, 'dhhash', 'sig2')

    shutil.rmtree(tempdir)

def check_elf_and_hash_patch(elf_file_path, patched_elf_file_path, hash_func_name, sig):
    elf_file_path = os.path.join(test_location, elf_file_path)
    proj = angr.Project(elf_file_path, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()

    hash_func = cfg.functions.function(name=hash_func_name)

    if sig == 'sig1':
        hash_func_evaluator = HashFuncEvaluatorSig1(elf_file_path, hash_func.addr, proj=proj)
        patched_hash_func_evaluator = HashFuncEvaluatorSig1(patched_elf_file_path, hash_func.addr)
    elif sig == 'sig2':
        hash_func_evaluator = HashFuncEvaluatorSig2(elf_file_path, hash_func.addr, proj=proj)
        patched_hash_func_evaluator = HashFuncEvaluatorSig2(patched_elf_file_path, hash_func.addr)
    else:
        raise Exception("Unknown signature: {}".format(sig))

    for i in range(1, 11):

        buf = 'a' * i
        ret_state_action_pairs, irregularities = hash_func_evaluator.evaluate_ext_mem_refs(buf, i)
        assert_equal(len(irregularities), 0, msg="We were not expecting any irregularities for elf {} and hash {}, but found: {}".format(elf_file_path, hash_func_name, irregularities))

        hash_func_ext_mem_read_addrs = set()
        for ret_state, action in ret_state_action_pairs:
            if action.action == angr.state_plugins.SimActionData.READ:
                addr = ret_state.solver.eval(action.addr.to_claripy())
                hash_func_ext_mem_read_addrs.add(addr)

        ret_state_action_pairs, irregularities = patched_hash_func_evaluator.evaluate_ext_mem_refs(buf, i, read_addr_whitelist=hash_func_ext_mem_read_addrs)
        assert_equal(len(irregularities), 0, msg="We were not expecting any irregularities for elf {} and hash {}, but found: {}".format(patched_elf_file_path, hash_func_name, [str(irregularity) for irregularity in irregularities]))

