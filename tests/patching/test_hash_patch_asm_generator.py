import os
from nose.tools import *
import sys
import tempfile
import shutil
import subprocess

import angr

from hash_patcher.static_patcher import StaticPatcher
from hash_patcher.hash_patch_asm_generator import HashPatchAsmGenerator

test_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'test_binaries')


def test_hook_func1():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()



    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov eax, 1", "pop rbp", "ret"] # A patch function that returns 1
    hpag = HashPatchAsmGenerator(proj, asm_code=patch_asm_code) # Since our patch function ignores the buffer and buffer_len argument registers, we do not need to change them
    hash_patch_asm_code = hpag.get_asm_code()

    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    output = subprocess.check_output([patched_elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 1', msg='The patched binary {} created from {} should have returned 1, not {}'.format(patched_elf_file_path, elf_file_name, output))

    shutil.rmtree(tempdir)

def test_hook_func2():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    # Our hash func returns the buffer length (in rsi), but it expects it in rdi
    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov rax, rdi", "pop rbp", "ret"] # Return arg2, BUT, the call site puts arg 2 in rsi (where the patch code expects rdi)
    hpag = HashPatchAsmGenerator(proj, asm_code=patch_asm_code, buf_in_reg='rsi') # buf_in_reg='rsi' should tell the generator to move rsi (where arg2 is) to rdi (where the patch code wants it)
    hash_patch_asm_code = hpag.get_asm_code()

    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    # The return code is the string length, 4, (that can be confirmed by looking at the source code
    output = subprocess.check_output([patched_elf_file_path, 'abcd']).strip()
    assert_equal(output, b'h(abcd) = 4', msg='The patched binary {} created from {} should have returned 4, not {}'.format(patched_elf_file_path, elf_file_name, output))

    shutil.rmtree(tempdir)

def test_hook_func3():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    # Our hash func returns the buffer length (in rsi), but the buffer length is not provided
    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov rax, rsi", "pop rbp", "ret"] # Return arg2, BUT, the call site does not provide an arg2
    hpag = HashPatchAsmGenerator(proj, asm_code=patch_asm_code, len_in_reg=None) # buf_in_reg=None should tell the generator that the string length is not available at the call site. It will assume the string is \0 termianted and calcualte the string length, before putting it in rsi
    hash_patch_asm_code = hpag.get_asm_code()

    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    output = subprocess.check_output([patched_elf_file_path, 'abcd']).strip()
    # The return code is the string length, 4, (that can be confirmed by looking at the source code
    assert_equal(output, b'h(abcd) = 4', 'The patched binary {} created from {} should have returned 4, not {}'.format(patched_elf_file_path, elf_file_name, output))

    shutil.rmtree(tempdir)

def test_hook_func4():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()



    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov eax, 6", "pop rbp", "ret"] # A patch function that returns 6
    hpag = HashPatchAsmGenerator(proj, asm_code=patch_asm_code, out_mod=5) # We want the output to be MOD 5 (so the final output will be 1)
    hash_patch_asm_code = hpag.get_asm_code()

    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    output = subprocess.check_output([patched_elf_file_path, 'a']).strip()
    assert_equal(output, b'h(a) = 1', msg='The patched binary {} created from {} should have returned 1, not {}'.format(patched_elf_file_path, elf_file_name, output))

    shutil.rmtree(tempdir)

def test_hook_func5():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    # Our hash func returns the buffer length (in rsi), but the buffer length is not provided
    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov rax, rsi", "pop rbp", "ret"] # Return arg2, BUT, the call site does not provide an arg2
    hpag = HashPatchAsmGenerator(proj, asm_code=patch_asm_code, len_in_reg=None, out_mod=7) # len_in_reg=None should tell the generator that the string length is not available at the call site. It will assume the string is \0 termianted and calcualte the string length, before putting it in rsi (arg2); out_mod=7 will MOD7 the return value (the string length) before returning it.
    hash_patch_asm_code = hpag.get_asm_code()

    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    output = subprocess.check_output([patched_elf_file_path, 'abcd']).strip()
    assert_equal(output, b'h(abcd) = 4', 'The patched binary {} created from {} should have returned 4, not {}'.format(patched_elf_file_path, elf_file_name, output))

    output = subprocess.check_output([patched_elf_file_path, 'abcdefg']).strip()
    assert_equal(output, b'h(abcdefg) = 0', 'The patched binary {} created from {} should have returned 0, not {}'.format(patched_elf_file_path, elf_file_name, output))

    shutil.rmtree(tempdir)

def test_hook_func6():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    # Our hash func returns the buffer length (in rsi), but the buffer length is not provided
    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov rax, rsi", "pop rbp", "ret"] # Return arg2, BUT, the call site does not provide an arg2
    hpag = HashPatchAsmGenerator(proj, asm_code=patch_asm_code, len_in_reg=None, out_mod=256) # len_in_reg=None should tell the generator that the string length is not available at the call site. It will assume the string is \0 termianted and calcualte the string length, before putting it in rsi (arg2); out_mod=7 will MOD7 the return value (the string length) before returning it.
    hash_patch_asm_code = hpag.get_asm_code()

    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    for i in range(1, 256):
        output = subprocess.check_output([patched_elf_file_path, 'a' * i]).strip()
        assert_equal(output, bytes('h({}) = {}'.format('a' * i, i), 'utf-8'), 'The patched binary {} created from {} should have returned 0, not {}'.format(patched_elf_file_path, elf_file_name, output))

    output = subprocess.check_output([patched_elf_file_path, 'a' * 256]).strip()
    assert_equal(output, bytes('h({}) = 0'.format('a' * 256), 'utf-8'), 'The patched binary {} created from {} should have returned 0, not {}'.format(patched_elf_file_path, elf_file_name, output))

    shutil.rmtree(tempdir)

def test_hook_func7():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()


    # Our hash func returns the buffer length (in rsi), but the buffer length is not provided
    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov rax, rsi", "pop rbp", "ret"] # Return arg2, BUT, the call site does not provide an arg2
    hpag = HashPatchAsmGenerator(proj, asm_code=patch_asm_code, len_in_reg=None, out_mod=257) # len_in_reg=None should tell the generator that the string length is not available at the call site. It will assume the string is \0 termianted and calcualte the string length, before putting it in rsi (arg2); out_mod=7 will MOD7 the return value (the string length) before returning it.
    hash_patch_asm_code = hpag.get_asm_code()

    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    for i in range(1, 257):
        output = subprocess.check_output([patched_elf_file_path, 'a' * i]).strip()
        assert_equal(output, bytes('h({}) = {}'.format('a' * i, i), 'utf-8'), 'The patched binary {} created from {} should have returned 0, not {}'.format(patched_elf_file_path, elf_file_name, output))

    output = subprocess.check_output([patched_elf_file_path, 'a' * 257]).strip()
    assert_equal(output, bytes('h({}) = 0'.format('a' * 257), 'utf-8'), 'The patched binary {} created from {} should have returned 0, not {}'.format(patched_elf_file_path, elf_file_name, output))

    shutil.rmtree(tempdir)

def test_detect_clobbered_regs1():
    # The elf_file does not really matter here, but we need a proj to pass to HashPatchAsmGenerator (so that it can get the arch)
    elf_file_name = os.path.join(test_location, 'ret_hash_sig2_expanded')
    proj = angr.Project(elf_file_name, auto_load_libs=False)

    hpag = HashPatchAsmGenerator(proj, asm_code=[]) # We don't use the asm_code here
    # Our hash func returns the buffer length (in rsi), but the buffer length is not provided

    patch_asm_code = [] # Trivial case
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(), "Detected clobbered registers: {} | actual clobbered registers: []".format(clobbered_regs))

    patch_asm_code = [''] # Trivial case
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(), "Detected clobbered registers: {} | actual clobbered registers: []".format(clobbered_regs))

    patch_asm_code = ['label:'] # label
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(), "Detected clobbered registers: {} | actual clobbered registers: []".format(clobbered_regs))

    patch_asm_code = ["inc rax"] # Clobber rax
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(['rax']), "Detected clobbered registers: {} | actual clobbered registers: [rax]".format(clobbered_regs))

    patch_asm_code = ["push rax"] # Implicit clobbering of stack pointer (rsp)
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(['rsp']), "Detected clobbered registers: {} | actual clobbered registers: [rsp]".format(clobbered_regs))

    patch_asm_code = ["pop rdi"] # Implicit clobbering of stack pointer (rsp) ; explicit clobbering of rdi
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(['rsp', 'rdi']), "Detected clobbered registers: {} | actual clobbered registers: [rsp, rdi]".format(clobbered_regs))

    patch_asm_code = ["mov rdi,1"] # Clobber rdi
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(['rdi']), "Detected clobbered registers: {} | actual clobbered registers: [rdi]".format(clobbered_regs))

    patch_asm_code = ["mov [rdi],rax"] # Does NOT clobber rdi (nor rax)
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(), "Detected clobbered registers: {} | actual clobbered registers: []".format(clobbered_regs))

    patch_asm_code = ["mov [rdi],rax", 'inc rdi'] # Clobbers rdi
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(['rdi']), "Detected clobbered registers: {} | actual clobbered registers: [rdi]".format(clobbered_regs))

    patch_asm_code = ['label: mov rax,1']
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(['rax']), "Detected clobbered registers: {} | actual clobbered registers: [rax]".format(clobbered_regs))

    patch_asm_code = ['mov rax,1 ; comment']
    clobbered_regs = hpag.detect_clobbered_regs(patch_asm_code)
    assert_equal(clobbered_regs, set(['rax']), "Detected clobbered registers: {} | actual clobbered registers: [rax]".format(clobbered_regs))
