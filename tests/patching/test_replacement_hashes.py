import os
from nose.tools import *
import sys
import tempfile
import shutil
import subprocess

import angr

from hash_patcher.static_patcher import StaticPatcher
from hash_patcher.hash_patch_asm_generator import HashPatchAsmGenerator

test_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'test_binaries')


def test_siphash():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig1_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    

    patch_asm_code_file = '/home/nweidema/hash_func_patches/sip_hash_func.s'
    hpag = HashPatchAsmGenerator(proj, asm_file=patch_asm_code_file, buf_in_reg='rsi', len_in_reg='rdi')
    hash_patch_asm_code = hpag.get_asm_code()

    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    # The return code is the string length, 4, (that can be confirmed by looking at the source code
    output = subprocess.check_output([patched_elf_file_path, 'asdf']).strip()
    assert_equal(output, b'h(asdf) = 1120073065', msg='The patched binary {} created from {} should have returned 4, not {}'.format(patched_elf_file_path, elf_file_name, output))

    shutil.rmtree(tempdir)

def test_hook_func3():
    elf_file_name = os.path.join(test_location, 'ret_hash_sig2_expanded')
    output = subprocess.check_output([elf_file_name, 'a']).strip()
    assert_equal(output, b'h(a) = 0', msg='The test binary {} did not output as expected. It\'s probably broken.'.format(elf_file_name))

    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = os.path.basename(elf_file_name + '_patched')
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)
    cfg = proj.analyses.CFGFast()
    

    # Our hash func returns the buffer length (in rsi), but the buffer length is not provided
    patch_asm_code = ["push rbp", "mov rbp, rsp", "mov rax, rsi", "pop rbp", "ret"] # Return arg2, BUT, the call site does not provide an arg2
    hpag = HashPatchAsmGenerator(proj, asm_code=patch_asm_code, len_in_reg=None) # buf_in_reg=None should tell the generator that the string length is not available at the call site. It will assume the string is \0 termianted and calcualte the string length, before putting it in rsi
    hash_patch_asm_code = hpag.get_asm_code()

    patch_target_func = cfg.functions.function(name='patch_target_func')
    patcher = StaticPatcher(elf_file_name)
    patcher.hook_func(patch_target_func.addr, hash_patch_asm_code)
    patcher.apply_patches(patched_elf_file_path)

    output = subprocess.check_output([patched_elf_file_path, 'abcd']).strip()
    # The return code is the string length, 4, (that can be confirmed by looking at the source code
    assert_equal(output, b'h(abcd) = 4', 'The patched binary {} created from {} should have returned 4, not {}'.format(patched_elf_file_path, elf_file_name, output))

    shutil.rmtree(tempdir)

