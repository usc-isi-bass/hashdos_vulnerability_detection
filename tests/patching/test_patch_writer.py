import os
import subprocess
import tempfile
import shutil
from nose.tools import *

import angr

from hash_patcher.patch_writer import PatchWriter

test_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'test_binaries')

def test_patch_writer():
    elf_file_name = os.path.join(test_location, 'exit_0')
    tempdir = tempfile.mkdtemp(prefix="bin_patch_test_")
    patched_elf_file = elf_file_name + '_patched'
    patched_elf_file_path = os.path.join(tempdir, patched_elf_file)
    proj = angr.Project(elf_file_name, auto_load_libs=False)

    return_code = subprocess.run(elf_file_name).returncode
    
    assert_equal(return_code, 0, msg='The test binary {} did not exit with code 0, as expected. It\'s probably broken.'.format(elf_file_name))

    patch_writer = PatchWriter(proj)
    patch_writer.add_patch(0x401129, b'\xb8\x01\x00\x00\x00') # mov eax, 1
    patch_writer.write_patches(patched_elf_file_path)

    return_code = subprocess.run(patched_elf_file_path).returncode
    
    assert_equal(return_code, 1, msg='The patched binary {} created from {} should have returned 1, not {}'.format(patched_elf_file_path, elf_file_name, return_code))

    shutil.rmtree(tempdir)

def test_patch_writer_overlap_exceptions():
    elf_file_name = os.path.join(test_location, 'exit_0')
    proj = angr.Project(elf_file_name, auto_load_libs=False)

    patch_writer = PatchWriter(proj)
    patch_writer.add_patch(0x401129, b'\x90\x90') 
    assert_raises(Exception, patch_writer.add_patch, args=(0x401129, b''), msg='Should have raised an exception, because we add two patches at the same addr.')
    assert_raises(Exception, patch_writer.add_patch, args=(0x401130, b'\xcc'), msg='Should have raised an exception, because it overlaps an existing patch (to the left).')
    assert_raises(Exception, patch_writer.add_patch, args=(0x401128, b'\xcc\xcc'), msg='Should have raised an exception, because it overlaps an existing patch (to the right).')

