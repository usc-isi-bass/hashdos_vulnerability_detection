import stashed_extended.stashed as stashed

def get_glibc_hash_func(proj, cfg):
    hash_symbols_to_search = ['hsearch', 'hsearch_r']
    hash_funcs = set()
    for hash_symbol in hash_symbols_to_search:
        hash_func = cfg.functions.function(name=hash_symbol)
        if hash_func:
            hash_funcs.add(hash_func)
    return hash_funcs

def get_stashed_hash_funcs(proj, cfg, result_dict):
    hash_func_list = []
    result_dict['hash_funcs'] = hash_func_list
    result_dict['stash_times'] = {}
    # Do a quick scan for hash-function constants to see if we should investigate further
    #if False:
    if not constant_search(proj, cfg):
        return []
    stash = stashed.Stashed(proj, cfg)
    stash_times = stash.get_times()
    for k, v in stash_times.items():
        result_dict['stash_times'][k] = v
    # func_match is the hash function name (str) that the one in the binary appears to be
    for func_match in stash.func_matches:
        hash_func, hash_func_addr, hash_func_score = stash.func_matches[func_match]
        if hash_func_score >= 55:
            hash_func_num_blocks = len(list(hash_func.blocks))
            # The number of bytes the hash funtion is
            hash_func_byte_size = sum(len(block.bytes) for block in hash_func.blocks)
            hash_func_metrics = {'hash_func_byte_size':hash_func_byte_size, 'hash_func_num_blocks':hash_func_num_blocks}
            hash_func_list.append((func_match, "{}@0x{:x}".format(hash_func.name, hash_func.addr), hash_func_score, hash_func_metrics))
            yield hash_func
        #if hash_func_score > 60: # Chosen arbitrarily
        #    hash_funcs.add(hash_func)
    #return hash_funcs

def get_hash_funcs_constant_search(proj, cfg, result_dict):
    hash_func_const_map = {'rshash': {0x5c6b7:{'imul', 'mov'}, 0xf8c9:{'mov'}},
            'jshash':{0x4e67c6a7:{'mov', 'xor'}, 0xe092c689:{'xor'}},
            'pjwhash':{0xffffffff:{'mov'}, 0xF0000000:{'and'}, 0xfffffff:{'and'}, 0x4:{'shl'}, 0x18:{'shr'}},
            'elf_hash':{0xF0000000:{'and', 'xor'}},
            'bkdrhash':{0x1f:{'imul', 'mov'}, 0x83:{'imul', 'mov'}, 0x521:{'imul', 'mov'}, 0x334b:{'imul', 'mov'}, 0x200f1:{'imul', 'mov'}},
            'fnvhash':{0x811c9dc5:{'mov', 'imul'}},
            'sdbmhash':{0x1003f:{'imul'}, 0x10040:{'imul'}},
            'djbhash':{0x1505:{'mov'}, 0x21:{'imul'}},
            'bphash':{0x7:{'shl'}},
            'dekhash':{0x1b:{'ror', 'shr'}, 0x5:{'rol'}},
            'aphash':{0xaaaaaaaa:{'mov'}}}
    result_dict['hash_funcs'] = hash_func_set
    hash_func_set = set()
    return_set = set()
    def maybe_hash_func(func):
        for hash_func_name in hash_func_const_map:
            for block in func.blocks:
                insns = block.capstone.insns
                for insn in insns:
                    for op in ins.operands:
                        for con in hash_func_const_map[hash_func_name]:
                            for use in hash_func_const_map[hash_func_name][con]:
                                if op.imm == con and (insn.mnemonic.find(use) > -1 or use.find(insn.mnemonic) > -1):
                                    # We believe this function is the hash function
                                    hash_func_set.add((hash_func, "{}@0x{:x}".format(func.name, func.addr)))
                                    return True
        return False
    for func_addr in cfg.functions:
        func = cfg.functions(func_addr)
        if maybe_hash_func(func):
            return_set.add(func)
        
    return return_set

def constant_search(proj, cfg):
    for addr, func in cfg.functions.items():
        for block in func.blocks:
            insns = block.capstone.insns
            for insn in insns:
                for op in insn.operands:
                    #if (insn.mnemonic, op.imm) in constants:
                    #    print(func.name, insn.mnemonic, op.imm)
                    for mmnem, mimm in constants:
                        mhash = constants[(mmnem, mimm)]
                        if mimm == op.imm and (insn.mnemonic in mmnem or mmnem in insn.mnemonic):
                                return True
    return False
                

constants = {
    ('imul', 0x5c6b7):'rshash',
    ('mov', 0x5c6b7):'rshash',
    ('mov', 0xf8c9):'rshash',
    ('mov', 0x4e67c6a7):'jshash',
    ('xor', 0x4e67c6a7):'jshash',
    ('add', 0xe092c689):'jshash',
    ('and', 0xF0000000):'elfhash',
    ('xor', 0xF0000000):'elfhash',
    #('imul', 0x1f):'bkdrhash',
    #('mov', 0x1f):'bkdrhash',
    ('imul', 0x83):'bkdrhash',
    ('mov', 0x83):'bkdrhash',
    ('imul', 0x521):'bkdrhash',
    ('mov', 0x521):'bkdrhash',
    ('imul', 0x334b):'bkdrhash',
    ('mov', 0x334b):'bkdrhash',
    ('imul', 0x200f1):'bkdrhash',
    ('mov', 0x200f1):'bkdrhash',
    ('mov', 0x811c9dc5):'fnvhash',
    ('imul', 0x811c9dc5):'fnvhash',
    ('imul', 0x1003f):'sdbmhash',
    ('imul', 0x10040):'sdbmhash',
    ('mov', 0x1505):'djbhash',
    ('imul', 0x21):'djbhash',
    ('ror', 0x1b):'dekhash',
    ('shr', 0x1b):'dekhash',
    ('rol', 0x5):'dekhash',
    ('mov', 0xaaaaaaaa):'aphash'
}

